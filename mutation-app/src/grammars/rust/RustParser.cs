//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.7.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from rust/RustParser.g4 by ANTLR 4.7.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.7.2")]
[System.CLSCompliant(false)]
public partial class RustParser : RustParserBase {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		KW_AS=1, KW_BREAK=2, KW_CONST=3, KW_CONTINUE=4, KW_CRATE=5, KW_ELSE=6, 
		KW_ENUM=7, KW_EXTERN=8, KW_FALSE=9, KW_FN=10, KW_FOR=11, KW_IF=12, KW_IMPL=13, 
		KW_IN=14, KW_LET=15, KW_LOOP=16, KW_MATCH=17, KW_MOD=18, KW_MOVE=19, KW_MUT=20, 
		KW_PUB=21, KW_REF=22, KW_RETURN=23, KW_SELFVALUE=24, KW_SELFTYPE=25, KW_STATIC=26, 
		KW_STRUCT=27, KW_SUPER=28, KW_TRAIT=29, KW_TRUE=30, KW_TYPE=31, KW_UNSAFE=32, 
		KW_USE=33, KW_WHERE=34, KW_WHILE=35, KW_ASYNC=36, KW_AWAIT=37, KW_DYN=38, 
		KW_ABSTRACT=39, KW_BECOME=40, KW_BOX=41, KW_DO=42, KW_FINAL=43, KW_MACRO=44, 
		KW_OVERRIDE=45, KW_PRIV=46, KW_TYPEOF=47, KW_UNSIZED=48, KW_VIRTUAL=49, 
		KW_YIELD=50, KW_TRY=51, KW_UNION=52, KW_STATICLIFETIME=53, KW_MACRORULES=54, 
		KW_UNDERLINELIFETIME=55, KW_DOLLARCRATE=56, NON_KEYWORD_IDENTIFIER=57, 
		RAW_IDENTIFIER=58, LINE_COMMENT=59, BLOCK_COMMENT=60, INNER_LINE_DOC=61, 
		INNER_BLOCK_DOC=62, OUTER_LINE_DOC=63, OUTER_BLOCK_DOC=64, BLOCK_COMMENT_OR_DOC=65, 
		SHEBANG=66, WHITESPACE=67, NEWLINE=68, CHAR_LITERAL=69, STRING_LITERAL=70, 
		RAW_STRING_LITERAL=71, BYTE_LITERAL=72, BYTE_STRING_LITERAL=73, RAW_BYTE_STRING_LITERAL=74, 
		INTEGER_LITERAL=75, DEC_LITERAL=76, HEX_LITERAL=77, OCT_LITERAL=78, BIN_LITERAL=79, 
		FLOAT_LITERAL=80, LIFETIME_OR_LABEL=81, PLUS=82, MINUS=83, STAR=84, SLASH=85, 
		PERCENT=86, CARET=87, NOT=88, AND=89, OR=90, ANDAND=91, OROR=92, PLUSEQ=93, 
		MINUSEQ=94, STAREQ=95, SLASHEQ=96, PERCENTEQ=97, CARETEQ=98, ANDEQ=99, 
		OREQ=100, SHLEQ=101, SHREQ=102, EQ=103, EQEQ=104, NE=105, GT=106, LT=107, 
		GE=108, LE=109, AT=110, UNDERSCORE=111, DOT=112, DOTDOT=113, DOTDOTDOT=114, 
		DOTDOTEQ=115, COMMA=116, SEMI=117, COLON=118, PATHSEP=119, RARROW=120, 
		FATARROW=121, POUND=122, DOLLAR=123, QUESTION=124, LCURLYBRACE=125, RCURLYBRACE=126, 
		LSQUAREBRACKET=127, RSQUAREBRACKET=128, LPAREN=129, RPAREN=130;
	public const int
		RULE_crate = 0, RULE_macroInvocation = 1, RULE_delimTokenTree = 2, RULE_tokenTree = 3, 
		RULE_tokenTreeToken = 4, RULE_macroInvocationSemi = 5, RULE_macroRulesDefinition = 6, 
		RULE_macroRulesDef = 7, RULE_macroRules = 8, RULE_macroRule = 9, RULE_macroMatcher = 10, 
		RULE_macroMatch = 11, RULE_macroMatchToken = 12, RULE_macroFragSpec = 13, 
		RULE_macroRepSep = 14, RULE_macroRepOp = 15, RULE_macroTranscriber = 16, 
		RULE_item = 17, RULE_visItem = 18, RULE_macroItem = 19, RULE_module = 20, 
		RULE_externCrate = 21, RULE_crateRef = 22, RULE_asClause = 23, RULE_useDeclaration = 24, 
		RULE_useTree = 25, RULE_function_ = 26, RULE_functionQualifiers = 27, 
		RULE_abi = 28, RULE_functionParameters = 29, RULE_selfParam = 30, RULE_shorthandSelf = 31, 
		RULE_typedSelf = 32, RULE_functionParam = 33, RULE_functionParamPattern = 34, 
		RULE_functionReturnType = 35, RULE_typeAlias = 36, RULE_struct_ = 37, 
		RULE_structStruct = 38, RULE_tupleStruct = 39, RULE_structFields = 40, 
		RULE_structField = 41, RULE_tupleFields = 42, RULE_tupleField = 43, RULE_enumeration = 44, 
		RULE_enumItems = 45, RULE_enumItem = 46, RULE_enumItemTuple = 47, RULE_enumItemStruct = 48, 
		RULE_enumItemDiscriminant = 49, RULE_union_ = 50, RULE_constantItem = 51, 
		RULE_staticItem = 52, RULE_trait_ = 53, RULE_implementation = 54, RULE_inherentImpl = 55, 
		RULE_traitImpl = 56, RULE_externBlock = 57, RULE_externalItem = 58, RULE_genericParams = 59, 
		RULE_genericParam = 60, RULE_lifetimeParam = 61, RULE_typeParam = 62, 
		RULE_constParam = 63, RULE_whereClause = 64, RULE_whereClauseItem = 65, 
		RULE_lifetimeWhereClauseItem = 66, RULE_typeBoundWhereClauseItem = 67, 
		RULE_forLifetimes = 68, RULE_associatedItem = 69, RULE_innerAttribute = 70, 
		RULE_outerAttribute = 71, RULE_attr = 72, RULE_attrInput = 73, RULE_statement = 74, 
		RULE_letStatement = 75, RULE_expressionStatement = 76, RULE_expression = 77, 
		RULE_comparisonOperator = 78, RULE_compoundAssignOperator = 79, RULE_expressionWithBlock = 80, 
		RULE_literalExpression = 81, RULE_pathExpression = 82, RULE_blockExpression = 83, 
		RULE_statements = 84, RULE_asyncBlockExpression = 85, RULE_unsafeBlockExpression = 86, 
		RULE_arrayElements = 87, RULE_tupleElements = 88, RULE_tupleIndex = 89, 
		RULE_structExpression = 90, RULE_structExprStruct = 91, RULE_structExprFields = 92, 
		RULE_structExprField = 93, RULE_structBase = 94, RULE_structExprTuple = 95, 
		RULE_structExprUnit = 96, RULE_enumerationVariantExpression = 97, RULE_enumExprStruct = 98, 
		RULE_enumExprFields = 99, RULE_enumExprField = 100, RULE_enumExprTuple = 101, 
		RULE_enumExprFieldless = 102, RULE_callParams = 103, RULE_closureExpression = 104, 
		RULE_closureParameters = 105, RULE_closureParam = 106, RULE_loopExpression = 107, 
		RULE_infiniteLoopExpression = 108, RULE_predicateLoopExpression = 109, 
		RULE_predicatePatternLoopExpression = 110, RULE_iteratorLoopExpression = 111, 
		RULE_loopLabel = 112, RULE_ifExpression = 113, RULE_ifLetExpression = 114, 
		RULE_matchExpression = 115, RULE_matchArms = 116, RULE_matchArmExpression = 117, 
		RULE_matchArm = 118, RULE_matchArmGuard = 119, RULE_pattern = 120, RULE_patternNoTopAlt = 121, 
		RULE_patternWithoutRange = 122, RULE_literalPattern = 123, RULE_identifierPattern = 124, 
		RULE_wildcardPattern = 125, RULE_restPattern = 126, RULE_rangePattern = 127, 
		RULE_rangePatternBound = 128, RULE_referencePattern = 129, RULE_structPattern = 130, 
		RULE_structPatternElements = 131, RULE_structPatternFields = 132, RULE_structPatternField = 133, 
		RULE_structPatternEtCetera = 134, RULE_tupleStructPattern = 135, RULE_tupleStructItems = 136, 
		RULE_tuplePattern = 137, RULE_tuplePatternItems = 138, RULE_groupedPattern = 139, 
		RULE_slicePattern = 140, RULE_slicePatternItems = 141, RULE_pathPattern = 142, 
		RULE_type_ = 143, RULE_typeNoBounds = 144, RULE_parenthesizedType = 145, 
		RULE_neverType = 146, RULE_tupleType = 147, RULE_arrayType = 148, RULE_sliceType = 149, 
		RULE_referenceType = 150, RULE_rawPointerType = 151, RULE_bareFunctionType = 152, 
		RULE_functionTypeQualifiers = 153, RULE_bareFunctionReturnType = 154, 
		RULE_functionParametersMaybeNamedVariadic = 155, RULE_maybeNamedFunctionParameters = 156, 
		RULE_maybeNamedParam = 157, RULE_maybeNamedFunctionParametersVariadic = 158, 
		RULE_traitObjectType = 159, RULE_traitObjectTypeOneBound = 160, RULE_implTraitType = 161, 
		RULE_implTraitTypeOneBound = 162, RULE_inferredType = 163, RULE_typeParamBounds = 164, 
		RULE_typeParamBound = 165, RULE_traitBound = 166, RULE_lifetimeBounds = 167, 
		RULE_lifetime = 168, RULE_simplePath = 169, RULE_simplePathSegment = 170, 
		RULE_pathInExpression = 171, RULE_pathExprSegment = 172, RULE_pathIdentSegment = 173, 
		RULE_genericArgs = 174, RULE_genericArg = 175, RULE_genericArgsConst = 176, 
		RULE_genericArgsLifetimes = 177, RULE_genericArgsTypes = 178, RULE_genericArgsBindings = 179, 
		RULE_genericArgsBinding = 180, RULE_qualifiedPathInExpression = 181, RULE_qualifiedPathType = 182, 
		RULE_qualifiedPathInType = 183, RULE_typePath = 184, RULE_typePathSegment = 185, 
		RULE_typePathFn = 186, RULE_typePathInputs = 187, RULE_visibility = 188, 
		RULE_identifier = 189, RULE_keyword = 190, RULE_macroIdentifierLikeToken = 191, 
		RULE_macroLiteralToken = 192, RULE_macroPunctuationToken = 193, RULE_shl = 194, 
		RULE_shr = 195;
	public static readonly string[] ruleNames = {
		"crate", "macroInvocation", "delimTokenTree", "tokenTree", "tokenTreeToken", 
		"macroInvocationSemi", "macroRulesDefinition", "macroRulesDef", "macroRules", 
		"macroRule", "macroMatcher", "macroMatch", "macroMatchToken", "macroFragSpec", 
		"macroRepSep", "macroRepOp", "macroTranscriber", "item", "visItem", "macroItem", 
		"module", "externCrate", "crateRef", "asClause", "useDeclaration", "useTree", 
		"function_", "functionQualifiers", "abi", "functionParameters", "selfParam", 
		"shorthandSelf", "typedSelf", "functionParam", "functionParamPattern", 
		"functionReturnType", "typeAlias", "struct_", "structStruct", "tupleStruct", 
		"structFields", "structField", "tupleFields", "tupleField", "enumeration", 
		"enumItems", "enumItem", "enumItemTuple", "enumItemStruct", "enumItemDiscriminant", 
		"union_", "constantItem", "staticItem", "trait_", "implementation", "inherentImpl", 
		"traitImpl", "externBlock", "externalItem", "genericParams", "genericParam", 
		"lifetimeParam", "typeParam", "constParam", "whereClause", "whereClauseItem", 
		"lifetimeWhereClauseItem", "typeBoundWhereClauseItem", "forLifetimes", 
		"associatedItem", "innerAttribute", "outerAttribute", "attr", "attrInput", 
		"statement", "letStatement", "expressionStatement", "expression", "comparisonOperator", 
		"compoundAssignOperator", "expressionWithBlock", "literalExpression", 
		"pathExpression", "blockExpression", "statements", "asyncBlockExpression", 
		"unsafeBlockExpression", "arrayElements", "tupleElements", "tupleIndex", 
		"structExpression", "structExprStruct", "structExprFields", "structExprField", 
		"structBase", "structExprTuple", "structExprUnit", "enumerationVariantExpression", 
		"enumExprStruct", "enumExprFields", "enumExprField", "enumExprTuple", 
		"enumExprFieldless", "callParams", "closureExpression", "closureParameters", 
		"closureParam", "loopExpression", "infiniteLoopExpression", "predicateLoopExpression", 
		"predicatePatternLoopExpression", "iteratorLoopExpression", "loopLabel", 
		"ifExpression", "ifLetExpression", "matchExpression", "matchArms", "matchArmExpression", 
		"matchArm", "matchArmGuard", "pattern", "patternNoTopAlt", "patternWithoutRange", 
		"literalPattern", "identifierPattern", "wildcardPattern", "restPattern", 
		"rangePattern", "rangePatternBound", "referencePattern", "structPattern", 
		"structPatternElements", "structPatternFields", "structPatternField", 
		"structPatternEtCetera", "tupleStructPattern", "tupleStructItems", "tuplePattern", 
		"tuplePatternItems", "groupedPattern", "slicePattern", "slicePatternItems", 
		"pathPattern", "type_", "typeNoBounds", "parenthesizedType", "neverType", 
		"tupleType", "arrayType", "sliceType", "referenceType", "rawPointerType", 
		"bareFunctionType", "functionTypeQualifiers", "bareFunctionReturnType", 
		"functionParametersMaybeNamedVariadic", "maybeNamedFunctionParameters", 
		"maybeNamedParam", "maybeNamedFunctionParametersVariadic", "traitObjectType", 
		"traitObjectTypeOneBound", "implTraitType", "implTraitTypeOneBound", "inferredType", 
		"typeParamBounds", "typeParamBound", "traitBound", "lifetimeBounds", "lifetime", 
		"simplePath", "simplePathSegment", "pathInExpression", "pathExprSegment", 
		"pathIdentSegment", "genericArgs", "genericArg", "genericArgsConst", "genericArgsLifetimes", 
		"genericArgsTypes", "genericArgsBindings", "genericArgsBinding", "qualifiedPathInExpression", 
		"qualifiedPathType", "qualifiedPathInType", "typePath", "typePathSegment", 
		"typePathFn", "typePathInputs", "visibility", "identifier", "keyword", 
		"macroIdentifierLikeToken", "macroLiteralToken", "macroPunctuationToken", 
		"shl", "shr"
	};

	private static readonly string[] _LiteralNames = {
		null, "'as'", "'break'", "'const'", "'continue'", "'crate'", "'else'", 
		"'enum'", "'extern'", "'false'", "'fn'", "'for'", "'if'", "'impl'", "'in'", 
		"'let'", "'loop'", "'match'", "'mod'", "'move'", "'mut'", "'pub'", "'ref'", 
		"'return'", "'self'", "'Self'", "'static'", "'struct'", "'super'", "'trait'", 
		"'true'", "'type'", "'unsafe'", "'use'", "'where'", "'while'", "'async'", 
		"'await'", "'dyn'", "'abstract'", "'become'", "'box'", "'do'", "'final'", 
		"'macro'", "'override'", "'priv'", "'typeof'", "'unsized'", "'virtual'", 
		"'yield'", "'try'", "'union'", "''static'", "'macro_rules'", "''_'", "'$crate'", 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, "'+'", "'-'", "'*'", "'/'", "'%'", "'^'", "'!'", "'&'", "'|'", "'&&'", 
		"'||'", "'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'&='", "'|='", 
		"'<<='", "'>>='", "'='", "'=='", "'!='", "'>'", "'<'", "'>='", "'<='", 
		"'@'", "'_'", "'.'", "'..'", "'...'", "'..='", "','", "';'", "':'", "'::'", 
		"'->'", "'=>'", "'#'", "'$'", "'?'", "'{'", "'}'", "'['", "']'", "'('", 
		"')'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "KW_AS", "KW_BREAK", "KW_CONST", "KW_CONTINUE", "KW_CRATE", "KW_ELSE", 
		"KW_ENUM", "KW_EXTERN", "KW_FALSE", "KW_FN", "KW_FOR", "KW_IF", "KW_IMPL", 
		"KW_IN", "KW_LET", "KW_LOOP", "KW_MATCH", "KW_MOD", "KW_MOVE", "KW_MUT", 
		"KW_PUB", "KW_REF", "KW_RETURN", "KW_SELFVALUE", "KW_SELFTYPE", "KW_STATIC", 
		"KW_STRUCT", "KW_SUPER", "KW_TRAIT", "KW_TRUE", "KW_TYPE", "KW_UNSAFE", 
		"KW_USE", "KW_WHERE", "KW_WHILE", "KW_ASYNC", "KW_AWAIT", "KW_DYN", "KW_ABSTRACT", 
		"KW_BECOME", "KW_BOX", "KW_DO", "KW_FINAL", "KW_MACRO", "KW_OVERRIDE", 
		"KW_PRIV", "KW_TYPEOF", "KW_UNSIZED", "KW_VIRTUAL", "KW_YIELD", "KW_TRY", 
		"KW_UNION", "KW_STATICLIFETIME", "KW_MACRORULES", "KW_UNDERLINELIFETIME", 
		"KW_DOLLARCRATE", "NON_KEYWORD_IDENTIFIER", "RAW_IDENTIFIER", "LINE_COMMENT", 
		"BLOCK_COMMENT", "INNER_LINE_DOC", "INNER_BLOCK_DOC", "OUTER_LINE_DOC", 
		"OUTER_BLOCK_DOC", "BLOCK_COMMENT_OR_DOC", "SHEBANG", "WHITESPACE", "NEWLINE", 
		"CHAR_LITERAL", "STRING_LITERAL", "RAW_STRING_LITERAL", "BYTE_LITERAL", 
		"BYTE_STRING_LITERAL", "RAW_BYTE_STRING_LITERAL", "INTEGER_LITERAL", "DEC_LITERAL", 
		"HEX_LITERAL", "OCT_LITERAL", "BIN_LITERAL", "FLOAT_LITERAL", "LIFETIME_OR_LABEL", 
		"PLUS", "MINUS", "STAR", "SLASH", "PERCENT", "CARET", "NOT", "AND", "OR", 
		"ANDAND", "OROR", "PLUSEQ", "MINUSEQ", "STAREQ", "SLASHEQ", "PERCENTEQ", 
		"CARETEQ", "ANDEQ", "OREQ", "SHLEQ", "SHREQ", "EQ", "EQEQ", "NE", "GT", 
		"LT", "GE", "LE", "AT", "UNDERSCORE", "DOT", "DOTDOT", "DOTDOTDOT", "DOTDOTEQ", 
		"COMMA", "SEMI", "COLON", "PATHSEP", "RARROW", "FATARROW", "POUND", "DOLLAR", 
		"QUESTION", "LCURLYBRACE", "RCURLYBRACE", "LSQUAREBRACKET", "RSQUAREBRACKET", 
		"LPAREN", "RPAREN"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "RustParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static RustParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public RustParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public RustParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class CrateContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(RustParser.Eof, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public ItemContext[] item() {
			return GetRuleContexts<ItemContext>();
		}
		public ItemContext item(int i) {
			return GetRuleContext<ItemContext>(i);
		}
		public CrateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_crate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterCrate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitCrate(this);
		}
	}

	[RuleVersion(0)]
	public CrateContext crate() {
		CrateContext _localctx = new CrateContext(Context, State);
		EnterRule(_localctx, 0, RULE_crate);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 395;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,0,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 392; innerAttribute();
					}
					} 
				}
				State = 397;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,0,Context);
			}
			State = 401;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CONST) | (1L << KW_CRATE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_IMPL) | (1L << KW_MOD) | (1L << KW_PUB) | (1L << KW_SELFVALUE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_ASYNC) | (1L << KW_UNION) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==PATHSEP || _la==POUND) {
				{
				{
				State = 398; item();
				}
				}
				State = 403;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 404; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroInvocationContext : ParserRuleContext {
		public SimplePathContext simplePath() {
			return GetRuleContext<SimplePathContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(RustParser.NOT, 0); }
		public DelimTokenTreeContext delimTokenTree() {
			return GetRuleContext<DelimTokenTreeContext>(0);
		}
		public MacroInvocationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroInvocation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroInvocation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroInvocation(this);
		}
	}

	[RuleVersion(0)]
	public MacroInvocationContext macroInvocation() {
		MacroInvocationContext _localctx = new MacroInvocationContext(Context, State);
		EnterRule(_localctx, 2, RULE_macroInvocation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 406; simplePath();
			State = 407; Match(NOT);
			State = 408; delimTokenTree();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DelimTokenTreeContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public TokenTreeContext[] tokenTree() {
			return GetRuleContexts<TokenTreeContext>();
		}
		public TokenTreeContext tokenTree(int i) {
			return GetRuleContext<TokenTreeContext>(i);
		}
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public DelimTokenTreeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delimTokenTree; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterDelimTokenTree(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitDelimTokenTree(this);
		}
	}

	[RuleVersion(0)]
	public DelimTokenTreeContext delimTokenTree() {
		DelimTokenTreeContext _localctx = new DelimTokenTreeContext(Context, State);
		EnterRule(_localctx, 4, RULE_delimTokenTree);
		int _la;
		try {
			State = 434;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 410; Match(LPAREN);
				State = 414;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 411; tokenTree();
					}
					}
					State = 416;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 417; Match(RPAREN);
				}
				break;
			case LSQUAREBRACKET:
				EnterOuterAlt(_localctx, 2);
				{
				State = 418; Match(LSQUAREBRACKET);
				State = 422;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 419; tokenTree();
					}
					}
					State = 424;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 425; Match(RSQUAREBRACKET);
				}
				break;
			case LCURLYBRACE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 426; Match(LCURLYBRACE);
				State = 430;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 427; tokenTree();
					}
					}
					State = 432;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 433; Match(RCURLYBRACE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TokenTreeContext : ParserRuleContext {
		public TokenTreeTokenContext[] tokenTreeToken() {
			return GetRuleContexts<TokenTreeTokenContext>();
		}
		public TokenTreeTokenContext tokenTreeToken(int i) {
			return GetRuleContext<TokenTreeTokenContext>(i);
		}
		public DelimTokenTreeContext delimTokenTree() {
			return GetRuleContext<DelimTokenTreeContext>(0);
		}
		public TokenTreeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokenTree; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTokenTree(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTokenTree(this);
		}
	}

	[RuleVersion(0)]
	public TokenTreeContext tokenTree() {
		TokenTreeContext _localctx = new TokenTreeContext(Context, State);
		EnterRule(_localctx, 6, RULE_tokenTree);
		try {
			int _alt;
			State = 442;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_AS:
			case KW_BREAK:
			case KW_CONST:
			case KW_CONTINUE:
			case KW_CRATE:
			case KW_ELSE:
			case KW_ENUM:
			case KW_EXTERN:
			case KW_FALSE:
			case KW_FN:
			case KW_FOR:
			case KW_IF:
			case KW_IMPL:
			case KW_IN:
			case KW_LET:
			case KW_LOOP:
			case KW_MATCH:
			case KW_MOD:
			case KW_MOVE:
			case KW_MUT:
			case KW_PUB:
			case KW_REF:
			case KW_RETURN:
			case KW_SELFVALUE:
			case KW_SELFTYPE:
			case KW_STATIC:
			case KW_STRUCT:
			case KW_SUPER:
			case KW_TRAIT:
			case KW_TRUE:
			case KW_TYPE:
			case KW_UNSAFE:
			case KW_USE:
			case KW_WHERE:
			case KW_WHILE:
			case KW_ASYNC:
			case KW_AWAIT:
			case KW_DYN:
			case KW_ABSTRACT:
			case KW_BECOME:
			case KW_BOX:
			case KW_DO:
			case KW_FINAL:
			case KW_MACRO:
			case KW_OVERRIDE:
			case KW_PRIV:
			case KW_TYPEOF:
			case KW_UNSIZED:
			case KW_VIRTUAL:
			case KW_YIELD:
			case KW_TRY:
			case KW_UNION:
			case KW_STATICLIFETIME:
			case KW_MACRORULES:
			case KW_UNDERLINELIFETIME:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case CHAR_LITERAL:
			case STRING_LITERAL:
			case RAW_STRING_LITERAL:
			case BYTE_LITERAL:
			case BYTE_STRING_LITERAL:
			case RAW_BYTE_STRING_LITERAL:
			case INTEGER_LITERAL:
			case FLOAT_LITERAL:
			case LIFETIME_OR_LABEL:
			case PLUS:
			case MINUS:
			case STAR:
			case SLASH:
			case PERCENT:
			case CARET:
			case NOT:
			case AND:
			case OR:
			case ANDAND:
			case OROR:
			case PLUSEQ:
			case MINUSEQ:
			case STAREQ:
			case SLASHEQ:
			case PERCENTEQ:
			case CARETEQ:
			case ANDEQ:
			case OREQ:
			case SHLEQ:
			case SHREQ:
			case EQ:
			case EQEQ:
			case NE:
			case GT:
			case LT:
			case GE:
			case LE:
			case AT:
			case UNDERSCORE:
			case DOT:
			case DOTDOT:
			case DOTDOTDOT:
			case DOTDOTEQ:
			case COMMA:
			case SEMI:
			case COLON:
			case PATHSEP:
			case RARROW:
			case FATARROW:
			case POUND:
			case DOLLAR:
			case QUESTION:
				EnterOuterAlt(_localctx, 1);
				{
				State = 437;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 436; tokenTreeToken();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 439;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case LCURLYBRACE:
			case LSQUAREBRACKET:
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 441; delimTokenTree();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TokenTreeTokenContext : ParserRuleContext {
		public MacroIdentifierLikeTokenContext macroIdentifierLikeToken() {
			return GetRuleContext<MacroIdentifierLikeTokenContext>(0);
		}
		public MacroLiteralTokenContext macroLiteralToken() {
			return GetRuleContext<MacroLiteralTokenContext>(0);
		}
		public MacroPunctuationTokenContext macroPunctuationToken() {
			return GetRuleContext<MacroPunctuationTokenContext>(0);
		}
		public MacroRepOpContext macroRepOp() {
			return GetRuleContext<MacroRepOpContext>(0);
		}
		public ITerminalNode DOLLAR() { return GetToken(RustParser.DOLLAR, 0); }
		public TokenTreeTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokenTreeToken; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTokenTreeToken(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTokenTreeToken(this);
		}
	}

	[RuleVersion(0)]
	public TokenTreeTokenContext tokenTreeToken() {
		TokenTreeTokenContext _localctx = new TokenTreeTokenContext(Context, State);
		EnterRule(_localctx, 8, RULE_tokenTreeToken);
		try {
			State = 449;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 444; macroIdentifierLikeToken();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 445; macroLiteralToken();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 446; macroPunctuationToken();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 447; macroRepOp();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 448; Match(DOLLAR);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroInvocationSemiContext : ParserRuleContext {
		public SimplePathContext simplePath() {
			return GetRuleContext<SimplePathContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(RustParser.NOT, 0); }
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public TokenTreeContext[] tokenTree() {
			return GetRuleContexts<TokenTreeContext>();
		}
		public TokenTreeContext tokenTree(int i) {
			return GetRuleContext<TokenTreeContext>(i);
		}
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public MacroInvocationSemiContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroInvocationSemi; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroInvocationSemi(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroInvocationSemi(this);
		}
	}

	[RuleVersion(0)]
	public MacroInvocationSemiContext macroInvocationSemi() {
		MacroInvocationSemiContext _localctx = new MacroInvocationSemiContext(Context, State);
		EnterRule(_localctx, 10, RULE_macroInvocationSemi);
		int _la;
		try {
			State = 486;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 451; simplePath();
				State = 452; Match(NOT);
				State = 453; Match(LPAREN);
				State = 457;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 454; tokenTree();
					}
					}
					State = 459;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 460; Match(RPAREN);
				State = 461; Match(SEMI);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 463; simplePath();
				State = 464; Match(NOT);
				State = 465; Match(LSQUAREBRACKET);
				State = 469;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 466; tokenTree();
					}
					}
					State = 471;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 472; Match(RSQUAREBRACKET);
				State = 473; Match(SEMI);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 475; simplePath();
				State = 476; Match(NOT);
				State = 477; Match(LCURLYBRACE);
				State = 481;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 478; tokenTree();
					}
					}
					State = 483;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 484; Match(RCURLYBRACE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroRulesDefinitionContext : ParserRuleContext {
		public ITerminalNode KW_MACRORULES() { return GetToken(RustParser.KW_MACRORULES, 0); }
		public ITerminalNode NOT() { return GetToken(RustParser.NOT, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public MacroRulesDefContext macroRulesDef() {
			return GetRuleContext<MacroRulesDefContext>(0);
		}
		public MacroRulesDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroRulesDefinition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroRulesDefinition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroRulesDefinition(this);
		}
	}

	[RuleVersion(0)]
	public MacroRulesDefinitionContext macroRulesDefinition() {
		MacroRulesDefinitionContext _localctx = new MacroRulesDefinitionContext(Context, State);
		EnterRule(_localctx, 12, RULE_macroRulesDefinition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 488; Match(KW_MACRORULES);
			State = 489; Match(NOT);
			State = 490; identifier();
			State = 491; macroRulesDef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroRulesDefContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public MacroRulesContext macroRules() {
			return GetRuleContext<MacroRulesContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public MacroRulesDefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroRulesDef; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroRulesDef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroRulesDef(this);
		}
	}

	[RuleVersion(0)]
	public MacroRulesDefContext macroRulesDef() {
		MacroRulesDefContext _localctx = new MacroRulesDefContext(Context, State);
		EnterRule(_localctx, 14, RULE_macroRulesDef);
		try {
			State = 507;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 493; Match(LPAREN);
				State = 494; macroRules();
				State = 495; Match(RPAREN);
				State = 496; Match(SEMI);
				}
				break;
			case LSQUAREBRACKET:
				EnterOuterAlt(_localctx, 2);
				{
				State = 498; Match(LSQUAREBRACKET);
				State = 499; macroRules();
				State = 500; Match(RSQUAREBRACKET);
				State = 501; Match(SEMI);
				}
				break;
			case LCURLYBRACE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 503; Match(LCURLYBRACE);
				State = 504; macroRules();
				State = 505; Match(RCURLYBRACE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroRulesContext : ParserRuleContext {
		public MacroRuleContext[] macroRule() {
			return GetRuleContexts<MacroRuleContext>();
		}
		public MacroRuleContext macroRule(int i) {
			return GetRuleContext<MacroRuleContext>(i);
		}
		public ITerminalNode[] SEMI() { return GetTokens(RustParser.SEMI); }
		public ITerminalNode SEMI(int i) {
			return GetToken(RustParser.SEMI, i);
		}
		public MacroRulesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroRules; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroRules(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroRules(this);
		}
	}

	[RuleVersion(0)]
	public MacroRulesContext macroRules() {
		MacroRulesContext _localctx = new MacroRulesContext(Context, State);
		EnterRule(_localctx, 16, RULE_macroRules);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 509; macroRule();
			State = 514;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,14,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 510; Match(SEMI);
					State = 511; macroRule();
					}
					} 
				}
				State = 516;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,14,Context);
			}
			State = 518;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEMI) {
				{
				State = 517; Match(SEMI);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroRuleContext : ParserRuleContext {
		public MacroMatcherContext macroMatcher() {
			return GetRuleContext<MacroMatcherContext>(0);
		}
		public ITerminalNode FATARROW() { return GetToken(RustParser.FATARROW, 0); }
		public MacroTranscriberContext macroTranscriber() {
			return GetRuleContext<MacroTranscriberContext>(0);
		}
		public MacroRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroRule(this);
		}
	}

	[RuleVersion(0)]
	public MacroRuleContext macroRule() {
		MacroRuleContext _localctx = new MacroRuleContext(Context, State);
		EnterRule(_localctx, 18, RULE_macroRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 520; macroMatcher();
			State = 521; Match(FATARROW);
			State = 522; macroTranscriber();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroMatcherContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public MacroMatchContext[] macroMatch() {
			return GetRuleContexts<MacroMatchContext>();
		}
		public MacroMatchContext macroMatch(int i) {
			return GetRuleContext<MacroMatchContext>(i);
		}
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public MacroMatcherContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroMatcher; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroMatcher(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroMatcher(this);
		}
	}

	[RuleVersion(0)]
	public MacroMatcherContext macroMatcher() {
		MacroMatcherContext _localctx = new MacroMatcherContext(Context, State);
		EnterRule(_localctx, 20, RULE_macroMatcher);
		int _la;
		try {
			State = 548;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 524; Match(LPAREN);
				State = 528;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 525; macroMatch();
					}
					}
					State = 530;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 531; Match(RPAREN);
				}
				break;
			case LSQUAREBRACKET:
				EnterOuterAlt(_localctx, 2);
				{
				State = 532; Match(LSQUAREBRACKET);
				State = 536;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 533; macroMatch();
					}
					}
					State = 538;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 539; Match(RSQUAREBRACKET);
				}
				break;
			case LCURLYBRACE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 540; Match(LCURLYBRACE);
				State = 544;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					{
					State = 541; macroMatch();
					}
					}
					State = 546;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 547; Match(RCURLYBRACE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroMatchContext : ParserRuleContext {
		public MacroMatchTokenContext[] macroMatchToken() {
			return GetRuleContexts<MacroMatchTokenContext>();
		}
		public MacroMatchTokenContext macroMatchToken(int i) {
			return GetRuleContext<MacroMatchTokenContext>(i);
		}
		public MacroMatcherContext macroMatcher() {
			return GetRuleContext<MacroMatcherContext>(0);
		}
		public ITerminalNode DOLLAR() { return GetToken(RustParser.DOLLAR, 0); }
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public MacroFragSpecContext macroFragSpec() {
			return GetRuleContext<MacroFragSpecContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode KW_SELFVALUE() { return GetToken(RustParser.KW_SELFVALUE, 0); }
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public MacroRepOpContext macroRepOp() {
			return GetRuleContext<MacroRepOpContext>(0);
		}
		public MacroMatchContext[] macroMatch() {
			return GetRuleContexts<MacroMatchContext>();
		}
		public MacroMatchContext macroMatch(int i) {
			return GetRuleContext<MacroMatchContext>(i);
		}
		public MacroRepSepContext macroRepSep() {
			return GetRuleContext<MacroRepSepContext>(0);
		}
		public MacroMatchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroMatch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroMatch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroMatch(this);
		}
	}

	[RuleVersion(0)]
	public MacroMatchContext macroMatch() {
		MacroMatchContext _localctx = new MacroMatchContext(Context, State);
		EnterRule(_localctx, 22, RULE_macroMatch);
		int _la;
		try {
			int _alt;
			State = 576;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,24,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 551;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 550; macroMatchToken();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 553;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 555; macroMatcher();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 556; Match(DOLLAR);
				State = 559;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case KW_MACRORULES:
				case NON_KEYWORD_IDENTIFIER:
				case RAW_IDENTIFIER:
					{
					State = 557; identifier();
					}
					break;
				case KW_SELFVALUE:
					{
					State = 558; Match(KW_SELFVALUE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 561; Match(COLON);
				State = 562; macroFragSpec();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 563; Match(DOLLAR);
				State = 564; Match(LPAREN);
				State = 566;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 565; macroMatch();
					}
					}
					State = 568;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (PLUS - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)) | (1L << (QUESTION - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0) );
				State = 570; Match(RPAREN);
				State = 572;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (SLASH - 69)) | (1L << (PERCENT - 69)) | (1L << (CARET - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (PLUSEQ - 69)) | (1L << (MINUSEQ - 69)) | (1L << (STAREQ - 69)) | (1L << (SLASHEQ - 69)) | (1L << (PERCENTEQ - 69)) | (1L << (CARETEQ - 69)) | (1L << (ANDEQ - 69)) | (1L << (OREQ - 69)) | (1L << (SHLEQ - 69)) | (1L << (SHREQ - 69)) | (1L << (EQ - 69)) | (1L << (EQEQ - 69)) | (1L << (NE - 69)) | (1L << (GT - 69)) | (1L << (LT - 69)) | (1L << (GE - 69)) | (1L << (LE - 69)) | (1L << (AT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (COMMA - 69)) | (1L << (SEMI - 69)) | (1L << (COLON - 69)) | (1L << (PATHSEP - 69)) | (1L << (RARROW - 69)) | (1L << (FATARROW - 69)) | (1L << (POUND - 69)) | (1L << (DOLLAR - 69)))) != 0)) {
					{
					State = 571; macroRepSep();
					}
				}

				State = 574; macroRepOp();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroMatchTokenContext : ParserRuleContext {
		public MacroIdentifierLikeTokenContext macroIdentifierLikeToken() {
			return GetRuleContext<MacroIdentifierLikeTokenContext>(0);
		}
		public MacroLiteralTokenContext macroLiteralToken() {
			return GetRuleContext<MacroLiteralTokenContext>(0);
		}
		public MacroPunctuationTokenContext macroPunctuationToken() {
			return GetRuleContext<MacroPunctuationTokenContext>(0);
		}
		public MacroRepOpContext macroRepOp() {
			return GetRuleContext<MacroRepOpContext>(0);
		}
		public MacroMatchTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroMatchToken; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroMatchToken(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroMatchToken(this);
		}
	}

	[RuleVersion(0)]
	public MacroMatchTokenContext macroMatchToken() {
		MacroMatchTokenContext _localctx = new MacroMatchTokenContext(Context, State);
		EnterRule(_localctx, 24, RULE_macroMatchToken);
		try {
			State = 582;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 578; macroIdentifierLikeToken();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 579; macroLiteralToken();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 580; macroPunctuationToken();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 581; macroRepOp();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroFragSpecContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public MacroFragSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroFragSpec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroFragSpec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroFragSpec(this);
		}
	}

	[RuleVersion(0)]
	public MacroFragSpecContext macroFragSpec() {
		MacroFragSpecContext _localctx = new MacroFragSpecContext(Context, State);
		EnterRule(_localctx, 26, RULE_macroFragSpec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 584; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroRepSepContext : ParserRuleContext {
		public MacroIdentifierLikeTokenContext macroIdentifierLikeToken() {
			return GetRuleContext<MacroIdentifierLikeTokenContext>(0);
		}
		public MacroLiteralTokenContext macroLiteralToken() {
			return GetRuleContext<MacroLiteralTokenContext>(0);
		}
		public MacroPunctuationTokenContext macroPunctuationToken() {
			return GetRuleContext<MacroPunctuationTokenContext>(0);
		}
		public ITerminalNode DOLLAR() { return GetToken(RustParser.DOLLAR, 0); }
		public MacroRepSepContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroRepSep; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroRepSep(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroRepSep(this);
		}
	}

	[RuleVersion(0)]
	public MacroRepSepContext macroRepSep() {
		MacroRepSepContext _localctx = new MacroRepSepContext(Context, State);
		EnterRule(_localctx, 28, RULE_macroRepSep);
		try {
			State = 590;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 586; macroIdentifierLikeToken();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 587; macroLiteralToken();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 588; macroPunctuationToken();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 589; Match(DOLLAR);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroRepOpContext : ParserRuleContext {
		public ITerminalNode STAR() { return GetToken(RustParser.STAR, 0); }
		public ITerminalNode PLUS() { return GetToken(RustParser.PLUS, 0); }
		public ITerminalNode QUESTION() { return GetToken(RustParser.QUESTION, 0); }
		public MacroRepOpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroRepOp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroRepOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroRepOp(this);
		}
	}

	[RuleVersion(0)]
	public MacroRepOpContext macroRepOp() {
		MacroRepOpContext _localctx = new MacroRepOpContext(Context, State);
		EnterRule(_localctx, 30, RULE_macroRepOp);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 592;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 82)) & ~0x3f) == 0 && ((1L << (_la - 82)) & ((1L << (PLUS - 82)) | (1L << (STAR - 82)) | (1L << (QUESTION - 82)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroTranscriberContext : ParserRuleContext {
		public DelimTokenTreeContext delimTokenTree() {
			return GetRuleContext<DelimTokenTreeContext>(0);
		}
		public MacroTranscriberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroTranscriber; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroTranscriber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroTranscriber(this);
		}
	}

	[RuleVersion(0)]
	public MacroTranscriberContext macroTranscriber() {
		MacroTranscriberContext _localctx = new MacroTranscriberContext(Context, State);
		EnterRule(_localctx, 32, RULE_macroTranscriber);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 594; delimTokenTree();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ItemContext : ParserRuleContext {
		public VisItemContext visItem() {
			return GetRuleContext<VisItemContext>(0);
		}
		public MacroItemContext macroItem() {
			return GetRuleContext<MacroItemContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public ItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_item; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitItem(this);
		}
	}

	[RuleVersion(0)]
	public ItemContext item() {
		ItemContext _localctx = new ItemContext(Context, State);
		EnterRule(_localctx, 34, RULE_item);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 599;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 596; outerAttribute();
				}
				}
				State = 601;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 604;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_CONST:
			case KW_ENUM:
			case KW_EXTERN:
			case KW_FN:
			case KW_IMPL:
			case KW_MOD:
			case KW_PUB:
			case KW_STATIC:
			case KW_STRUCT:
			case KW_TRAIT:
			case KW_TYPE:
			case KW_UNSAFE:
			case KW_USE:
			case KW_ASYNC:
			case KW_UNION:
				{
				State = 602; visItem();
				}
				break;
			case KW_CRATE:
			case KW_SELFVALUE:
			case KW_SUPER:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case PATHSEP:
				{
				State = 603; macroItem();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VisItemContext : ParserRuleContext {
		public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		public ExternCrateContext externCrate() {
			return GetRuleContext<ExternCrateContext>(0);
		}
		public UseDeclarationContext useDeclaration() {
			return GetRuleContext<UseDeclarationContext>(0);
		}
		public Function_Context function_() {
			return GetRuleContext<Function_Context>(0);
		}
		public TypeAliasContext typeAlias() {
			return GetRuleContext<TypeAliasContext>(0);
		}
		public Struct_Context struct_() {
			return GetRuleContext<Struct_Context>(0);
		}
		public EnumerationContext enumeration() {
			return GetRuleContext<EnumerationContext>(0);
		}
		public Union_Context union_() {
			return GetRuleContext<Union_Context>(0);
		}
		public ConstantItemContext constantItem() {
			return GetRuleContext<ConstantItemContext>(0);
		}
		public StaticItemContext staticItem() {
			return GetRuleContext<StaticItemContext>(0);
		}
		public Trait_Context trait_() {
			return GetRuleContext<Trait_Context>(0);
		}
		public ImplementationContext implementation() {
			return GetRuleContext<ImplementationContext>(0);
		}
		public ExternBlockContext externBlock() {
			return GetRuleContext<ExternBlockContext>(0);
		}
		public VisibilityContext visibility() {
			return GetRuleContext<VisibilityContext>(0);
		}
		public VisItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_visItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterVisItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitVisItem(this);
		}
	}

	[RuleVersion(0)]
	public VisItemContext visItem() {
		VisItemContext _localctx = new VisItemContext(Context, State);
		EnterRule(_localctx, 36, RULE_visItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 607;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_PUB) {
				{
				State = 606; visibility();
				}
			}

			State = 622;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				{
				State = 609; module();
				}
				break;
			case 2:
				{
				State = 610; externCrate();
				}
				break;
			case 3:
				{
				State = 611; useDeclaration();
				}
				break;
			case 4:
				{
				State = 612; function_();
				}
				break;
			case 5:
				{
				State = 613; typeAlias();
				}
				break;
			case 6:
				{
				State = 614; struct_();
				}
				break;
			case 7:
				{
				State = 615; enumeration();
				}
				break;
			case 8:
				{
				State = 616; union_();
				}
				break;
			case 9:
				{
				State = 617; constantItem();
				}
				break;
			case 10:
				{
				State = 618; staticItem();
				}
				break;
			case 11:
				{
				State = 619; trait_();
				}
				break;
			case 12:
				{
				State = 620; implementation();
				}
				break;
			case 13:
				{
				State = 621; externBlock();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroItemContext : ParserRuleContext {
		public MacroInvocationSemiContext macroInvocationSemi() {
			return GetRuleContext<MacroInvocationSemiContext>(0);
		}
		public MacroRulesDefinitionContext macroRulesDefinition() {
			return GetRuleContext<MacroRulesDefinitionContext>(0);
		}
		public MacroItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroItem(this);
		}
	}

	[RuleVersion(0)]
	public MacroItemContext macroItem() {
		MacroItemContext _localctx = new MacroItemContext(Context, State);
		EnterRule(_localctx, 38, RULE_macroItem);
		try {
			State = 626;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 624; macroInvocationSemi();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 625; macroRulesDefinition();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleContext : ParserRuleContext {
		public ITerminalNode KW_MOD() { return GetToken(RustParser.KW_MOD, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public ITerminalNode KW_UNSAFE() { return GetToken(RustParser.KW_UNSAFE, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public ItemContext[] item() {
			return GetRuleContexts<ItemContext>();
		}
		public ItemContext item(int i) {
			return GetRuleContext<ItemContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
	}

	[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 40, RULE_module);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 629;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_UNSAFE) {
				{
				State = 628; Match(KW_UNSAFE);
				}
			}

			State = 631; Match(KW_MOD);
			State = 632; identifier();
			State = 648;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SEMI:
				{
				State = 633; Match(SEMI);
				}
				break;
			case LCURLYBRACE:
				{
				State = 634; Match(LCURLYBRACE);
				State = 638;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 635; innerAttribute();
						}
						} 
					}
					State = 640;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
				}
				State = 644;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CONST) | (1L << KW_CRATE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_IMPL) | (1L << KW_MOD) | (1L << KW_PUB) | (1L << KW_SELFVALUE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_ASYNC) | (1L << KW_UNION) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==PATHSEP || _la==POUND) {
					{
					{
					State = 641; item();
					}
					}
					State = 646;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 647; Match(RCURLYBRACE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExternCrateContext : ParserRuleContext {
		public ITerminalNode KW_EXTERN() { return GetToken(RustParser.KW_EXTERN, 0); }
		public ITerminalNode KW_CRATE() { return GetToken(RustParser.KW_CRATE, 0); }
		public CrateRefContext crateRef() {
			return GetRuleContext<CrateRefContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public AsClauseContext asClause() {
			return GetRuleContext<AsClauseContext>(0);
		}
		public ExternCrateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_externCrate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterExternCrate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitExternCrate(this);
		}
	}

	[RuleVersion(0)]
	public ExternCrateContext externCrate() {
		ExternCrateContext _localctx = new ExternCrateContext(Context, State);
		EnterRule(_localctx, 42, RULE_externCrate);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 650; Match(KW_EXTERN);
			State = 651; Match(KW_CRATE);
			State = 652; crateRef();
			State = 654;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_AS) {
				{
				State = 653; asClause();
				}
			}

			State = 656; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CrateRefContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode KW_SELFVALUE() { return GetToken(RustParser.KW_SELFVALUE, 0); }
		public CrateRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_crateRef; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterCrateRef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitCrateRef(this);
		}
	}

	[RuleVersion(0)]
	public CrateRefContext crateRef() {
		CrateRefContext _localctx = new CrateRefContext(Context, State);
		EnterRule(_localctx, 44, RULE_crateRef);
		try {
			State = 660;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_MACRORULES:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 658; identifier();
				}
				break;
			case KW_SELFVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 659; Match(KW_SELFVALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsClauseContext : ParserRuleContext {
		public ITerminalNode KW_AS() { return GetToken(RustParser.KW_AS, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode UNDERSCORE() { return GetToken(RustParser.UNDERSCORE, 0); }
		public AsClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAsClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAsClause(this);
		}
	}

	[RuleVersion(0)]
	public AsClauseContext asClause() {
		AsClauseContext _localctx = new AsClauseContext(Context, State);
		EnterRule(_localctx, 46, RULE_asClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 662; Match(KW_AS);
			State = 665;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_MACRORULES:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
				{
				State = 663; identifier();
				}
				break;
			case UNDERSCORE:
				{
				State = 664; Match(UNDERSCORE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseDeclarationContext : ParserRuleContext {
		public ITerminalNode KW_USE() { return GetToken(RustParser.KW_USE, 0); }
		public UseTreeContext useTree() {
			return GetRuleContext<UseTreeContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public UseDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useDeclaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterUseDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitUseDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public UseDeclarationContext useDeclaration() {
		UseDeclarationContext _localctx = new UseDeclarationContext(Context, State);
		EnterRule(_localctx, 48, RULE_useDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 667; Match(KW_USE);
			State = 668; useTree();
			State = 669; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseTreeContext : ParserRuleContext {
		public ITerminalNode STAR() { return GetToken(RustParser.STAR, 0); }
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public ITerminalNode PATHSEP() { return GetToken(RustParser.PATHSEP, 0); }
		public UseTreeContext[] useTree() {
			return GetRuleContexts<UseTreeContext>();
		}
		public UseTreeContext useTree(int i) {
			return GetRuleContext<UseTreeContext>(i);
		}
		public SimplePathContext simplePath() {
			return GetRuleContext<SimplePathContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public ITerminalNode KW_AS() { return GetToken(RustParser.KW_AS, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode UNDERSCORE() { return GetToken(RustParser.UNDERSCORE, 0); }
		public UseTreeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useTree; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterUseTree(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitUseTree(this);
		}
	}

	[RuleVersion(0)]
	public UseTreeContext useTree() {
		UseTreeContext _localctx = new UseTreeContext(Context, State);
		EnterRule(_localctx, 50, RULE_useTree);
		int _la;
		try {
			int _alt;
			State = 703;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 675;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_SELFVALUE) | (1L << KW_SUPER) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==PATHSEP) {
					{
					State = 672;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
					case 1:
						{
						State = 671; simplePath();
						}
						break;
					}
					State = 674; Match(PATHSEP);
					}
				}

				State = 693;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STAR:
					{
					State = 677; Match(STAR);
					}
					break;
				case LCURLYBRACE:
					{
					State = 678; Match(LCURLYBRACE);
					State = 690;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_SELFVALUE) | (1L << KW_SUPER) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 84)) & ~0x3f) == 0 && ((1L << (_la - 84)) & ((1L << (STAR - 84)) | (1L << (PATHSEP - 84)) | (1L << (LCURLYBRACE - 84)))) != 0)) {
						{
						State = 679; useTree();
						State = 684;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
						while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
							if ( _alt==1 ) {
								{
								{
								State = 680; Match(COMMA);
								State = 681; useTree();
								}
								} 
							}
							State = 686;
							ErrorHandler.Sync(this);
							_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
						}
						State = 688;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 687; Match(COMMA);
							}
						}

						}
					}

					State = 692; Match(RCURLYBRACE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 695; simplePath();
				State = 701;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KW_AS) {
					{
					State = 696; Match(KW_AS);
					State = 699;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case KW_MACRORULES:
					case NON_KEYWORD_IDENTIFIER:
					case RAW_IDENTIFIER:
						{
						State = 697; identifier();
						}
						break;
					case UNDERSCORE:
						{
						State = 698; Match(UNDERSCORE);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_Context : ParserRuleContext {
		public FunctionQualifiersContext functionQualifiers() {
			return GetRuleContext<FunctionQualifiersContext>(0);
		}
		public ITerminalNode KW_FN() { return GetToken(RustParser.KW_FN, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public FunctionParametersContext functionParameters() {
			return GetRuleContext<FunctionParametersContext>(0);
		}
		public FunctionReturnTypeContext functionReturnType() {
			return GetRuleContext<FunctionReturnTypeContext>(0);
		}
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public Function_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFunction_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFunction_(this);
		}
	}

	[RuleVersion(0)]
	public Function_Context function_() {
		Function_Context _localctx = new Function_Context(Context, State);
		EnterRule(_localctx, 52, RULE_function_);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 705; functionQualifiers();
			State = 706; Match(KW_FN);
			State = 707; identifier();
			State = 709;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 708; genericParams();
				}
			}

			State = 711; Match(LPAREN);
			State = 713;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IMPL) | (1L << KW_MUT) | (1L << KW_REF) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_DYN) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (LT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTDOT - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (QUESTION - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 712; functionParameters();
				}
			}

			State = 715; Match(RPAREN);
			State = 717;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RARROW) {
				{
				State = 716; functionReturnType();
				}
			}

			State = 720;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 719; whereClause();
				}
			}

			State = 724;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LCURLYBRACE:
				{
				State = 722; blockExpression();
				}
				break;
			case SEMI:
				{
				State = 723; Match(SEMI);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionQualifiersContext : ParserRuleContext {
		public ITerminalNode KW_CONST() { return GetToken(RustParser.KW_CONST, 0); }
		public ITerminalNode KW_ASYNC() { return GetToken(RustParser.KW_ASYNC, 0); }
		public ITerminalNode KW_UNSAFE() { return GetToken(RustParser.KW_UNSAFE, 0); }
		public ITerminalNode KW_EXTERN() { return GetToken(RustParser.KW_EXTERN, 0); }
		public AbiContext abi() {
			return GetRuleContext<AbiContext>(0);
		}
		public FunctionQualifiersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionQualifiers; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFunctionQualifiers(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFunctionQualifiers(this);
		}
	}

	[RuleVersion(0)]
	public FunctionQualifiersContext functionQualifiers() {
		FunctionQualifiersContext _localctx = new FunctionQualifiersContext(Context, State);
		EnterRule(_localctx, 54, RULE_functionQualifiers);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 727;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_CONST) {
				{
				State = 726; Match(KW_CONST);
				}
			}

			State = 730;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_ASYNC) {
				{
				State = 729; Match(KW_ASYNC);
				}
			}

			State = 733;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_UNSAFE) {
				{
				State = 732; Match(KW_UNSAFE);
				}
			}

			State = 739;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_EXTERN) {
				{
				State = 735; Match(KW_EXTERN);
				State = 737;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STRING_LITERAL || _la==RAW_STRING_LITERAL) {
					{
					State = 736; abi();
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AbiContext : ParserRuleContext {
		public ITerminalNode STRING_LITERAL() { return GetToken(RustParser.STRING_LITERAL, 0); }
		public ITerminalNode RAW_STRING_LITERAL() { return GetToken(RustParser.RAW_STRING_LITERAL, 0); }
		public AbiContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abi; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAbi(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAbi(this);
		}
	}

	[RuleVersion(0)]
	public AbiContext abi() {
		AbiContext _localctx = new AbiContext(Context, State);
		EnterRule(_localctx, 56, RULE_abi);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 741;
			_la = TokenStream.LA(1);
			if ( !(_la==STRING_LITERAL || _la==RAW_STRING_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParametersContext : ParserRuleContext {
		public SelfParamContext selfParam() {
			return GetRuleContext<SelfParamContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public FunctionParamContext[] functionParam() {
			return GetRuleContexts<FunctionParamContext>();
		}
		public FunctionParamContext functionParam(int i) {
			return GetRuleContext<FunctionParamContext>(i);
		}
		public FunctionParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFunctionParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFunctionParameters(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParametersContext functionParameters() {
		FunctionParametersContext _localctx = new FunctionParametersContext(Context, State);
		EnterRule(_localctx, 58, RULE_functionParameters);
		int _la;
		try {
			int _alt;
			State = 763;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,62,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 743; selfParam();
				State = 745;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 744; Match(COMMA);
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 750;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
				case 1:
					{
					State = 747; selfParam();
					State = 748; Match(COMMA);
					}
					break;
				}
				State = 752; functionParam();
				State = 757;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,60,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 753; Match(COMMA);
						State = 754; functionParam();
						}
						} 
					}
					State = 759;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,60,Context);
				}
				State = 761;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 760; Match(COMMA);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelfParamContext : ParserRuleContext {
		public ShorthandSelfContext shorthandSelf() {
			return GetRuleContext<ShorthandSelfContext>(0);
		}
		public TypedSelfContext typedSelf() {
			return GetRuleContext<TypedSelfContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public SelfParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selfParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterSelfParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitSelfParam(this);
		}
	}

	[RuleVersion(0)]
	public SelfParamContext selfParam() {
		SelfParamContext _localctx = new SelfParamContext(Context, State);
		EnterRule(_localctx, 60, RULE_selfParam);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 768;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 765; outerAttribute();
				}
				}
				State = 770;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 773;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,64,Context) ) {
			case 1:
				{
				State = 771; shorthandSelf();
				}
				break;
			case 2:
				{
				State = 772; typedSelf();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShorthandSelfContext : ParserRuleContext {
		public ITerminalNode KW_SELFVALUE() { return GetToken(RustParser.KW_SELFVALUE, 0); }
		public ITerminalNode AND() { return GetToken(RustParser.AND, 0); }
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public LifetimeContext lifetime() {
			return GetRuleContext<LifetimeContext>(0);
		}
		public ShorthandSelfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shorthandSelf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterShorthandSelf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitShorthandSelf(this);
		}
	}

	[RuleVersion(0)]
	public ShorthandSelfContext shorthandSelf() {
		ShorthandSelfContext _localctx = new ShorthandSelfContext(Context, State);
		EnterRule(_localctx, 62, RULE_shorthandSelf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 779;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND) {
				{
				State = 775; Match(AND);
				State = 777;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 53)) & ~0x3f) == 0 && ((1L << (_la - 53)) & ((1L << (KW_STATICLIFETIME - 53)) | (1L << (KW_UNDERLINELIFETIME - 53)) | (1L << (LIFETIME_OR_LABEL - 53)))) != 0)) {
					{
					State = 776; lifetime();
					}
				}

				}
			}

			State = 782;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_MUT) {
				{
				State = 781; Match(KW_MUT);
				}
			}

			State = 784; Match(KW_SELFVALUE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedSelfContext : ParserRuleContext {
		public ITerminalNode KW_SELFVALUE() { return GetToken(RustParser.KW_SELFVALUE, 0); }
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public TypedSelfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedSelf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypedSelf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypedSelf(this);
		}
	}

	[RuleVersion(0)]
	public TypedSelfContext typedSelf() {
		TypedSelfContext _localctx = new TypedSelfContext(Context, State);
		EnterRule(_localctx, 64, RULE_typedSelf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 787;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_MUT) {
				{
				State = 786; Match(KW_MUT);
				}
			}

			State = 789; Match(KW_SELFVALUE);
			State = 790; Match(COLON);
			State = 791; type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParamContext : ParserRuleContext {
		public FunctionParamPatternContext functionParamPattern() {
			return GetRuleContext<FunctionParamPatternContext>(0);
		}
		public ITerminalNode DOTDOTDOT() { return GetToken(RustParser.DOTDOTDOT, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public FunctionParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFunctionParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFunctionParam(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParamContext functionParam() {
		FunctionParamContext _localctx = new FunctionParamContext(Context, State);
		EnterRule(_localctx, 66, RULE_functionParam);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 796;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 793; outerAttribute();
				}
				}
				State = 798;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 802;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,70,Context) ) {
			case 1:
				{
				State = 799; functionParamPattern();
				}
				break;
			case 2:
				{
				State = 800; Match(DOTDOTDOT);
				}
				break;
			case 3:
				{
				State = 801; type_();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParamPatternContext : ParserRuleContext {
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode DOTDOTDOT() { return GetToken(RustParser.DOTDOTDOT, 0); }
		public FunctionParamPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParamPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFunctionParamPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFunctionParamPattern(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParamPatternContext functionParamPattern() {
		FunctionParamPatternContext _localctx = new FunctionParamPatternContext(Context, State);
		EnterRule(_localctx, 68, RULE_functionParamPattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 804; pattern();
			State = 805; Match(COLON);
			State = 808;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_CRATE:
			case KW_EXTERN:
			case KW_FN:
			case KW_FOR:
			case KW_IMPL:
			case KW_SELFVALUE:
			case KW_SELFTYPE:
			case KW_SUPER:
			case KW_UNSAFE:
			case KW_DYN:
			case KW_STATICLIFETIME:
			case KW_MACRORULES:
			case KW_UNDERLINELIFETIME:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case LIFETIME_OR_LABEL:
			case STAR:
			case NOT:
			case AND:
			case LT:
			case UNDERSCORE:
			case PATHSEP:
			case QUESTION:
			case LSQUAREBRACKET:
			case LPAREN:
				{
				State = 806; type_();
				}
				break;
			case DOTDOTDOT:
				{
				State = 807; Match(DOTDOTDOT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionReturnTypeContext : ParserRuleContext {
		public ITerminalNode RARROW() { return GetToken(RustParser.RARROW, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public FunctionReturnTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionReturnType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFunctionReturnType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFunctionReturnType(this);
		}
	}

	[RuleVersion(0)]
	public FunctionReturnTypeContext functionReturnType() {
		FunctionReturnTypeContext _localctx = new FunctionReturnTypeContext(Context, State);
		EnterRule(_localctx, 70, RULE_functionReturnType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 810; Match(RARROW);
			State = 811; type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeAliasContext : ParserRuleContext {
		public ITerminalNode KW_TYPE() { return GetToken(RustParser.KW_TYPE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public TypeAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeAlias; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypeAlias(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypeAlias(this);
		}
	}

	[RuleVersion(0)]
	public TypeAliasContext typeAlias() {
		TypeAliasContext _localctx = new TypeAliasContext(Context, State);
		EnterRule(_localctx, 72, RULE_typeAlias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 813; Match(KW_TYPE);
			State = 814; identifier();
			State = 816;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 815; genericParams();
				}
			}

			State = 819;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 818; whereClause();
				}
			}

			State = 823;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQ) {
				{
				State = 821; Match(EQ);
				State = 822; type_();
				}
			}

			State = 825; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Struct_Context : ParserRuleContext {
		public StructStructContext structStruct() {
			return GetRuleContext<StructStructContext>(0);
		}
		public TupleStructContext tupleStruct() {
			return GetRuleContext<TupleStructContext>(0);
		}
		public Struct_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_struct_; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStruct_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStruct_(this);
		}
	}

	[RuleVersion(0)]
	public Struct_Context struct_() {
		Struct_Context _localctx = new Struct_Context(Context, State);
		EnterRule(_localctx, 74, RULE_struct_);
		try {
			State = 829;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,75,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 827; structStruct();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 828; tupleStruct();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructStructContext : ParserRuleContext {
		public ITerminalNode KW_STRUCT() { return GetToken(RustParser.KW_STRUCT, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public StructFieldsContext structFields() {
			return GetRuleContext<StructFieldsContext>(0);
		}
		public StructStructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structStruct; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructStruct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructStruct(this);
		}
	}

	[RuleVersion(0)]
	public StructStructContext structStruct() {
		StructStructContext _localctx = new StructStructContext(Context, State);
		EnterRule(_localctx, 76, RULE_structStruct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 831; Match(KW_STRUCT);
			State = 832; identifier();
			State = 834;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 833; genericParams();
				}
			}

			State = 837;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 836; whereClause();
				}
			}

			State = 845;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LCURLYBRACE:
				{
				State = 839; Match(LCURLYBRACE);
				State = 841;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_PUB) | (1L << KW_MACRORULES) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==POUND) {
					{
					State = 840; structFields();
					}
				}

				State = 843; Match(RCURLYBRACE);
				}
				break;
			case SEMI:
				{
				State = 844; Match(SEMI);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleStructContext : ParserRuleContext {
		public ITerminalNode KW_STRUCT() { return GetToken(RustParser.KW_STRUCT, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public TupleFieldsContext tupleFields() {
			return GetRuleContext<TupleFieldsContext>(0);
		}
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public TupleStructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleStruct; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleStruct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleStruct(this);
		}
	}

	[RuleVersion(0)]
	public TupleStructContext tupleStruct() {
		TupleStructContext _localctx = new TupleStructContext(Context, State);
		EnterRule(_localctx, 78, RULE_tupleStruct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 847; Match(KW_STRUCT);
			State = 848; identifier();
			State = 850;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 849; genericParams();
				}
			}

			State = 852; Match(LPAREN);
			State = 854;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IMPL) | (1L << KW_PUB) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_UNSAFE) | (1L << KW_DYN) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (STAR - 81)) | (1L << (NOT - 81)) | (1L << (AND - 81)) | (1L << (LT - 81)) | (1L << (UNDERSCORE - 81)) | (1L << (PATHSEP - 81)) | (1L << (POUND - 81)) | (1L << (QUESTION - 81)) | (1L << (LSQUAREBRACKET - 81)) | (1L << (LPAREN - 81)))) != 0)) {
				{
				State = 853; tupleFields();
				}
			}

			State = 856; Match(RPAREN);
			State = 858;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 857; whereClause();
				}
			}

			State = 860; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldsContext : ParserRuleContext {
		public StructFieldContext[] structField() {
			return GetRuleContexts<StructFieldContext>();
		}
		public StructFieldContext structField(int i) {
			return GetRuleContext<StructFieldContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public StructFieldsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structFields; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructFields(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructFields(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldsContext structFields() {
		StructFieldsContext _localctx = new StructFieldsContext(Context, State);
		EnterRule(_localctx, 80, RULE_structFields);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 862; structField();
			State = 867;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,83,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 863; Match(COMMA);
					State = 864; structField();
					}
					} 
				}
				State = 869;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,83,Context);
			}
			State = 871;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 870; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public VisibilityContext visibility() {
			return GetRuleContext<VisibilityContext>(0);
		}
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 82, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 876;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 873; outerAttribute();
				}
				}
				State = 878;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 880;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_PUB) {
				{
				State = 879; visibility();
				}
			}

			State = 882; identifier();
			State = 883; Match(COLON);
			State = 884; type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleFieldsContext : ParserRuleContext {
		public TupleFieldContext[] tupleField() {
			return GetRuleContexts<TupleFieldContext>();
		}
		public TupleFieldContext tupleField(int i) {
			return GetRuleContext<TupleFieldContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public TupleFieldsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleFields; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleFields(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleFields(this);
		}
	}

	[RuleVersion(0)]
	public TupleFieldsContext tupleFields() {
		TupleFieldsContext _localctx = new TupleFieldsContext(Context, State);
		EnterRule(_localctx, 84, RULE_tupleFields);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 886; tupleField();
			State = 891;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,87,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 887; Match(COMMA);
					State = 888; tupleField();
					}
					} 
				}
				State = 893;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,87,Context);
			}
			State = 895;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 894; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleFieldContext : ParserRuleContext {
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public VisibilityContext visibility() {
			return GetRuleContext<VisibilityContext>(0);
		}
		public TupleFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleField(this);
		}
	}

	[RuleVersion(0)]
	public TupleFieldContext tupleField() {
		TupleFieldContext _localctx = new TupleFieldContext(Context, State);
		EnterRule(_localctx, 86, RULE_tupleField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 900;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 897; outerAttribute();
				}
				}
				State = 902;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 904;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_PUB) {
				{
				State = 903; visibility();
				}
			}

			State = 906; type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumerationContext : ParserRuleContext {
		public ITerminalNode KW_ENUM() { return GetToken(RustParser.KW_ENUM, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public EnumItemsContext enumItems() {
			return GetRuleContext<EnumItemsContext>(0);
		}
		public EnumerationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumeration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumeration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumeration(this);
		}
	}

	[RuleVersion(0)]
	public EnumerationContext enumeration() {
		EnumerationContext _localctx = new EnumerationContext(Context, State);
		EnterRule(_localctx, 88, RULE_enumeration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 908; Match(KW_ENUM);
			State = 909; identifier();
			State = 911;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 910; genericParams();
				}
			}

			State = 914;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 913; whereClause();
				}
			}

			State = 916; Match(LCURLYBRACE);
			State = 918;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_PUB) | (1L << KW_MACRORULES) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==POUND) {
				{
				State = 917; enumItems();
				}
			}

			State = 920; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumItemsContext : ParserRuleContext {
		public EnumItemContext[] enumItem() {
			return GetRuleContexts<EnumItemContext>();
		}
		public EnumItemContext enumItem(int i) {
			return GetRuleContext<EnumItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public EnumItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumItems; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumItems(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumItems(this);
		}
	}

	[RuleVersion(0)]
	public EnumItemsContext enumItems() {
		EnumItemsContext _localctx = new EnumItemsContext(Context, State);
		EnterRule(_localctx, 90, RULE_enumItems);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 922; enumItem();
			State = 927;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,94,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 923; Match(COMMA);
					State = 924; enumItem();
					}
					} 
				}
				State = 929;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,94,Context);
			}
			State = 931;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 930; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumItemContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public VisibilityContext visibility() {
			return GetRuleContext<VisibilityContext>(0);
		}
		public EnumItemTupleContext enumItemTuple() {
			return GetRuleContext<EnumItemTupleContext>(0);
		}
		public EnumItemStructContext enumItemStruct() {
			return GetRuleContext<EnumItemStructContext>(0);
		}
		public EnumItemDiscriminantContext enumItemDiscriminant() {
			return GetRuleContext<EnumItemDiscriminantContext>(0);
		}
		public EnumItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumItem(this);
		}
	}

	[RuleVersion(0)]
	public EnumItemContext enumItem() {
		EnumItemContext _localctx = new EnumItemContext(Context, State);
		EnterRule(_localctx, 92, RULE_enumItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 936;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 933; outerAttribute();
				}
				}
				State = 938;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 940;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_PUB) {
				{
				State = 939; visibility();
				}
			}

			State = 942; identifier();
			State = 946;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				{
				State = 943; enumItemTuple();
				}
				break;
			case LCURLYBRACE:
				{
				State = 944; enumItemStruct();
				}
				break;
			case EQ:
				{
				State = 945; enumItemDiscriminant();
				}
				break;
			case COMMA:
			case RCURLYBRACE:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumItemTupleContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public TupleFieldsContext tupleFields() {
			return GetRuleContext<TupleFieldsContext>(0);
		}
		public EnumItemTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumItemTuple; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumItemTuple(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumItemTuple(this);
		}
	}

	[RuleVersion(0)]
	public EnumItemTupleContext enumItemTuple() {
		EnumItemTupleContext _localctx = new EnumItemTupleContext(Context, State);
		EnterRule(_localctx, 94, RULE_enumItemTuple);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 948; Match(LPAREN);
			State = 950;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IMPL) | (1L << KW_PUB) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_UNSAFE) | (1L << KW_DYN) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (STAR - 81)) | (1L << (NOT - 81)) | (1L << (AND - 81)) | (1L << (LT - 81)) | (1L << (UNDERSCORE - 81)) | (1L << (PATHSEP - 81)) | (1L << (POUND - 81)) | (1L << (QUESTION - 81)) | (1L << (LSQUAREBRACKET - 81)) | (1L << (LPAREN - 81)))) != 0)) {
				{
				State = 949; tupleFields();
				}
			}

			State = 952; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumItemStructContext : ParserRuleContext {
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public StructFieldsContext structFields() {
			return GetRuleContext<StructFieldsContext>(0);
		}
		public EnumItemStructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumItemStruct; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumItemStruct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumItemStruct(this);
		}
	}

	[RuleVersion(0)]
	public EnumItemStructContext enumItemStruct() {
		EnumItemStructContext _localctx = new EnumItemStructContext(Context, State);
		EnterRule(_localctx, 96, RULE_enumItemStruct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 954; Match(LCURLYBRACE);
			State = 956;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_PUB) | (1L << KW_MACRORULES) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==POUND) {
				{
				State = 955; structFields();
				}
			}

			State = 958; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumItemDiscriminantContext : ParserRuleContext {
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public EnumItemDiscriminantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumItemDiscriminant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumItemDiscriminant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumItemDiscriminant(this);
		}
	}

	[RuleVersion(0)]
	public EnumItemDiscriminantContext enumItemDiscriminant() {
		EnumItemDiscriminantContext _localctx = new EnumItemDiscriminantContext(Context, State);
		EnterRule(_localctx, 98, RULE_enumItemDiscriminant);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 960; Match(EQ);
			State = 961; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Union_Context : ParserRuleContext {
		public ITerminalNode KW_UNION() { return GetToken(RustParser.KW_UNION, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public StructFieldsContext structFields() {
			return GetRuleContext<StructFieldsContext>(0);
		}
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public Union_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_union_; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterUnion_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitUnion_(this);
		}
	}

	[RuleVersion(0)]
	public Union_Context union_() {
		Union_Context _localctx = new Union_Context(Context, State);
		EnterRule(_localctx, 100, RULE_union_);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 963; Match(KW_UNION);
			State = 964; identifier();
			State = 966;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 965; genericParams();
				}
			}

			State = 969;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 968; whereClause();
				}
			}

			State = 971; Match(LCURLYBRACE);
			State = 972; structFields();
			State = 973; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantItemContext : ParserRuleContext {
		public ITerminalNode KW_CONST() { return GetToken(RustParser.KW_CONST, 0); }
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode UNDERSCORE() { return GetToken(RustParser.UNDERSCORE, 0); }
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConstantItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterConstantItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitConstantItem(this);
		}
	}

	[RuleVersion(0)]
	public ConstantItemContext constantItem() {
		ConstantItemContext _localctx = new ConstantItemContext(Context, State);
		EnterRule(_localctx, 102, RULE_constantItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 975; Match(KW_CONST);
			State = 978;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_MACRORULES:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
				{
				State = 976; identifier();
				}
				break;
			case UNDERSCORE:
				{
				State = 977; Match(UNDERSCORE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 980; Match(COLON);
			State = 981; type_();
			State = 984;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQ) {
				{
				State = 982; Match(EQ);
				State = 983; expression(0);
				}
			}

			State = 986; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StaticItemContext : ParserRuleContext {
		public ITerminalNode KW_STATIC() { return GetToken(RustParser.KW_STATIC, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StaticItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_staticItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStaticItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStaticItem(this);
		}
	}

	[RuleVersion(0)]
	public StaticItemContext staticItem() {
		StaticItemContext _localctx = new StaticItemContext(Context, State);
		EnterRule(_localctx, 104, RULE_staticItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 988; Match(KW_STATIC);
			State = 990;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_MUT) {
				{
				State = 989; Match(KW_MUT);
				}
			}

			State = 992; identifier();
			State = 993; Match(COLON);
			State = 994; type_();
			State = 997;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQ) {
				{
				State = 995; Match(EQ);
				State = 996; expression(0);
				}
			}

			State = 999; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trait_Context : ParserRuleContext {
		public ITerminalNode KW_TRAIT() { return GetToken(RustParser.KW_TRAIT, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public ITerminalNode KW_UNSAFE() { return GetToken(RustParser.KW_UNSAFE, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public AssociatedItemContext[] associatedItem() {
			return GetRuleContexts<AssociatedItemContext>();
		}
		public AssociatedItemContext associatedItem(int i) {
			return GetRuleContext<AssociatedItemContext>(i);
		}
		public TypeParamBoundsContext typeParamBounds() {
			return GetRuleContext<TypeParamBoundsContext>(0);
		}
		public Trait_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trait_; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTrait_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTrait_(this);
		}
	}

	[RuleVersion(0)]
	public Trait_Context trait_() {
		Trait_Context _localctx = new Trait_Context(Context, State);
		EnterRule(_localctx, 106, RULE_trait_);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1002;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_UNSAFE) {
				{
				State = 1001; Match(KW_UNSAFE);
				}
			}

			State = 1004; Match(KW_TRAIT);
			State = 1005; identifier();
			State = 1007;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 1006; genericParams();
				}
			}

			State = 1013;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLON) {
				{
				State = 1009; Match(COLON);
				State = 1011;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_FOR) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (PATHSEP - 81)) | (1L << (QUESTION - 81)) | (1L << (LPAREN - 81)))) != 0)) {
					{
					State = 1010; typeParamBounds();
					}
				}

				}
			}

			State = 1016;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 1015; whereClause();
				}
			}

			State = 1018; Match(LCURLYBRACE);
			State = 1022;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,112,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1019; innerAttribute();
					}
					} 
				}
				State = 1024;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,112,Context);
			}
			State = 1028;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CONST) | (1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_PUB) | (1L << KW_SELFVALUE) | (1L << KW_SUPER) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==PATHSEP || _la==POUND) {
				{
				{
				State = 1025; associatedItem();
				}
				}
				State = 1030;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1031; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImplementationContext : ParserRuleContext {
		public InherentImplContext inherentImpl() {
			return GetRuleContext<InherentImplContext>(0);
		}
		public TraitImplContext traitImpl() {
			return GetRuleContext<TraitImplContext>(0);
		}
		public ImplementationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_implementation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterImplementation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitImplementation(this);
		}
	}

	[RuleVersion(0)]
	public ImplementationContext implementation() {
		ImplementationContext _localctx = new ImplementationContext(Context, State);
		EnterRule(_localctx, 108, RULE_implementation);
		try {
			State = 1035;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,114,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1033; inherentImpl();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1034; traitImpl();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InherentImplContext : ParserRuleContext {
		public ITerminalNode KW_IMPL() { return GetToken(RustParser.KW_IMPL, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public AssociatedItemContext[] associatedItem() {
			return GetRuleContexts<AssociatedItemContext>();
		}
		public AssociatedItemContext associatedItem(int i) {
			return GetRuleContext<AssociatedItemContext>(i);
		}
		public InherentImplContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inherentImpl; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterInherentImpl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitInherentImpl(this);
		}
	}

	[RuleVersion(0)]
	public InherentImplContext inherentImpl() {
		InherentImplContext _localctx = new InherentImplContext(Context, State);
		EnterRule(_localctx, 110, RULE_inherentImpl);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1037; Match(KW_IMPL);
			State = 1039;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,115,Context) ) {
			case 1:
				{
				State = 1038; genericParams();
				}
				break;
			}
			State = 1041; type_();
			State = 1043;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 1042; whereClause();
				}
			}

			State = 1045; Match(LCURLYBRACE);
			State = 1049;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,117,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1046; innerAttribute();
					}
					} 
				}
				State = 1051;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,117,Context);
			}
			State = 1055;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CONST) | (1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_PUB) | (1L << KW_SELFVALUE) | (1L << KW_SUPER) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==PATHSEP || _la==POUND) {
				{
				{
				State = 1052; associatedItem();
				}
				}
				State = 1057;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1058; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TraitImplContext : ParserRuleContext {
		public ITerminalNode KW_IMPL() { return GetToken(RustParser.KW_IMPL, 0); }
		public TypePathContext typePath() {
			return GetRuleContext<TypePathContext>(0);
		}
		public ITerminalNode KW_FOR() { return GetToken(RustParser.KW_FOR, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public ITerminalNode KW_UNSAFE() { return GetToken(RustParser.KW_UNSAFE, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(RustParser.NOT, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public AssociatedItemContext[] associatedItem() {
			return GetRuleContexts<AssociatedItemContext>();
		}
		public AssociatedItemContext associatedItem(int i) {
			return GetRuleContext<AssociatedItemContext>(i);
		}
		public TraitImplContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_traitImpl; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTraitImpl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTraitImpl(this);
		}
	}

	[RuleVersion(0)]
	public TraitImplContext traitImpl() {
		TraitImplContext _localctx = new TraitImplContext(Context, State);
		EnterRule(_localctx, 112, RULE_traitImpl);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1061;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_UNSAFE) {
				{
				State = 1060; Match(KW_UNSAFE);
				}
			}

			State = 1063; Match(KW_IMPL);
			State = 1065;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 1064; genericParams();
				}
			}

			State = 1068;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 1067; Match(NOT);
				}
			}

			State = 1070; typePath();
			State = 1071; Match(KW_FOR);
			State = 1072; type_();
			State = 1074;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_WHERE) {
				{
				State = 1073; whereClause();
				}
			}

			State = 1076; Match(LCURLYBRACE);
			State = 1080;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,123,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1077; innerAttribute();
					}
					} 
				}
				State = 1082;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,123,Context);
			}
			State = 1086;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CONST) | (1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_PUB) | (1L << KW_SELFVALUE) | (1L << KW_SUPER) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==PATHSEP || _la==POUND) {
				{
				{
				State = 1083; associatedItem();
				}
				}
				State = 1088;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1089; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExternBlockContext : ParserRuleContext {
		public ITerminalNode KW_EXTERN() { return GetToken(RustParser.KW_EXTERN, 0); }
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public ITerminalNode KW_UNSAFE() { return GetToken(RustParser.KW_UNSAFE, 0); }
		public AbiContext abi() {
			return GetRuleContext<AbiContext>(0);
		}
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public ExternalItemContext[] externalItem() {
			return GetRuleContexts<ExternalItemContext>();
		}
		public ExternalItemContext externalItem(int i) {
			return GetRuleContext<ExternalItemContext>(i);
		}
		public ExternBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_externBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterExternBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitExternBlock(this);
		}
	}

	[RuleVersion(0)]
	public ExternBlockContext externBlock() {
		ExternBlockContext _localctx = new ExternBlockContext(Context, State);
		EnterRule(_localctx, 114, RULE_externBlock);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1092;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_UNSAFE) {
				{
				State = 1091; Match(KW_UNSAFE);
				}
			}

			State = 1094; Match(KW_EXTERN);
			State = 1096;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STRING_LITERAL || _la==RAW_STRING_LITERAL) {
				{
				State = 1095; abi();
				}
			}

			State = 1098; Match(LCURLYBRACE);
			State = 1102;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,127,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1099; innerAttribute();
					}
					} 
				}
				State = 1104;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,127,Context);
			}
			State = 1108;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CONST) | (1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_PUB) | (1L << KW_SELFVALUE) | (1L << KW_STATIC) | (1L << KW_SUPER) | (1L << KW_UNSAFE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==PATHSEP || _la==POUND) {
				{
				{
				State = 1105; externalItem();
				}
				}
				State = 1110;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1111; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExternalItemContext : ParserRuleContext {
		public MacroInvocationSemiContext macroInvocationSemi() {
			return GetRuleContext<MacroInvocationSemiContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public StaticItemContext staticItem() {
			return GetRuleContext<StaticItemContext>(0);
		}
		public Function_Context function_() {
			return GetRuleContext<Function_Context>(0);
		}
		public VisibilityContext visibility() {
			return GetRuleContext<VisibilityContext>(0);
		}
		public ExternalItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_externalItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterExternalItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitExternalItem(this);
		}
	}

	[RuleVersion(0)]
	public ExternalItemContext externalItem() {
		ExternalItemContext _localctx = new ExternalItemContext(Context, State);
		EnterRule(_localctx, 116, RULE_externalItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1116;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 1113; outerAttribute();
				}
				}
				State = 1118;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1127;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_CRATE:
			case KW_SELFVALUE:
			case KW_SUPER:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case PATHSEP:
				{
				State = 1119; macroInvocationSemi();
				}
				break;
			case KW_CONST:
			case KW_EXTERN:
			case KW_FN:
			case KW_PUB:
			case KW_STATIC:
			case KW_UNSAFE:
			case KW_ASYNC:
				{
				State = 1121;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KW_PUB) {
					{
					State = 1120; visibility();
					}
				}

				State = 1125;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case KW_STATIC:
					{
					State = 1123; staticItem();
					}
					break;
				case KW_CONST:
				case KW_EXTERN:
				case KW_FN:
				case KW_UNSAFE:
				case KW_ASYNC:
					{
					State = 1124; function_();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericParamsContext : ParserRuleContext {
		public ITerminalNode LT() { return GetToken(RustParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(RustParser.GT, 0); }
		public GenericParamContext[] genericParam() {
			return GetRuleContexts<GenericParamContext>();
		}
		public GenericParamContext genericParam(int i) {
			return GetRuleContext<GenericParamContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public GenericParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericParams(this);
		}
	}

	[RuleVersion(0)]
	public GenericParamsContext genericParams() {
		GenericParamsContext _localctx = new GenericParamsContext(Context, State);
		EnterRule(_localctx, 118, RULE_genericParams);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1129; Match(LT);
			State = 1142;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CONST) | (1L << KW_MACRORULES) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || _la==LIFETIME_OR_LABEL || _la==POUND) {
				{
				State = 1135;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,133,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1130; genericParam();
						State = 1131; Match(COMMA);
						}
						} 
					}
					State = 1137;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,133,Context);
				}
				State = 1138; genericParam();
				State = 1140;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1139; Match(COMMA);
					}
				}

				}
			}

			State = 1144; Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericParamContext : ParserRuleContext {
		public LifetimeParamContext lifetimeParam() {
			return GetRuleContext<LifetimeParamContext>(0);
		}
		public TypeParamContext typeParam() {
			return GetRuleContext<TypeParamContext>(0);
		}
		public ConstParamContext constParam() {
			return GetRuleContext<ConstParamContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public GenericParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericParam(this);
		}
	}

	[RuleVersion(0)]
	public GenericParamContext genericParam() {
		GenericParamContext _localctx = new GenericParamContext(Context, State);
		EnterRule(_localctx, 120, RULE_genericParam);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1149;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,136,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1146; outerAttribute();
					}
					} 
				}
				State = 1151;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,136,Context);
			}
			State = 1155;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,137,Context) ) {
			case 1:
				{
				State = 1152; lifetimeParam();
				}
				break;
			case 2:
				{
				State = 1153; typeParam();
				}
				break;
			case 3:
				{
				State = 1154; constParam();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LifetimeParamContext : ParserRuleContext {
		public ITerminalNode LIFETIME_OR_LABEL() { return GetToken(RustParser.LIFETIME_OR_LABEL, 0); }
		public OuterAttributeContext outerAttribute() {
			return GetRuleContext<OuterAttributeContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public LifetimeBoundsContext lifetimeBounds() {
			return GetRuleContext<LifetimeBoundsContext>(0);
		}
		public LifetimeParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lifetimeParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLifetimeParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLifetimeParam(this);
		}
	}

	[RuleVersion(0)]
	public LifetimeParamContext lifetimeParam() {
		LifetimeParamContext _localctx = new LifetimeParamContext(Context, State);
		EnterRule(_localctx, 122, RULE_lifetimeParam);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==POUND) {
				{
				State = 1157; outerAttribute();
				}
			}

			State = 1160; Match(LIFETIME_OR_LABEL);
			State = 1163;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLON) {
				{
				State = 1161; Match(COLON);
				State = 1162; lifetimeBounds();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeParamContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public OuterAttributeContext outerAttribute() {
			return GetRuleContext<OuterAttributeContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public TypeParamBoundsContext typeParamBounds() {
			return GetRuleContext<TypeParamBoundsContext>(0);
		}
		public TypeParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypeParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypeParam(this);
		}
	}

	[RuleVersion(0)]
	public TypeParamContext typeParam() {
		TypeParamContext _localctx = new TypeParamContext(Context, State);
		EnterRule(_localctx, 124, RULE_typeParam);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1166;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==POUND) {
				{
				State = 1165; outerAttribute();
				}
			}

			State = 1168; identifier();
			State = 1173;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLON) {
				{
				State = 1169; Match(COLON);
				State = 1171;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_FOR) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (PATHSEP - 81)) | (1L << (QUESTION - 81)) | (1L << (LPAREN - 81)))) != 0)) {
					{
					State = 1170; typeParamBounds();
					}
				}

				}
			}

			State = 1177;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQ) {
				{
				State = 1175; Match(EQ);
				State = 1176; type_();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstParamContext : ParserRuleContext {
		public ITerminalNode KW_CONST() { return GetToken(RustParser.KW_CONST, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ConstParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterConstParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitConstParam(this);
		}
	}

	[RuleVersion(0)]
	public ConstParamContext constParam() {
		ConstParamContext _localctx = new ConstParamContext(Context, State);
		EnterRule(_localctx, 126, RULE_constParam);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1179; Match(KW_CONST);
			State = 1180; identifier();
			State = 1181; Match(COLON);
			State = 1182; type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhereClauseContext : ParserRuleContext {
		public ITerminalNode KW_WHERE() { return GetToken(RustParser.KW_WHERE, 0); }
		public WhereClauseItemContext[] whereClauseItem() {
			return GetRuleContexts<WhereClauseItemContext>();
		}
		public WhereClauseItemContext whereClauseItem(int i) {
			return GetRuleContext<WhereClauseItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public WhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whereClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterWhereClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitWhereClause(this);
		}
	}

	[RuleVersion(0)]
	public WhereClauseContext whereClause() {
		WhereClauseContext _localctx = new WhereClauseContext(Context, State);
		EnterRule(_localctx, 128, RULE_whereClause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1184; Match(KW_WHERE);
			State = 1190;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,144,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1185; whereClauseItem();
					State = 1186; Match(COMMA);
					}
					} 
				}
				State = 1192;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,144,Context);
			}
			State = 1194;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IMPL) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_UNSAFE) | (1L << KW_DYN) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (STAR - 81)) | (1L << (NOT - 81)) | (1L << (AND - 81)) | (1L << (LT - 81)) | (1L << (UNDERSCORE - 81)) | (1L << (PATHSEP - 81)) | (1L << (QUESTION - 81)) | (1L << (LSQUAREBRACKET - 81)) | (1L << (LPAREN - 81)))) != 0)) {
				{
				State = 1193; whereClauseItem();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhereClauseItemContext : ParserRuleContext {
		public LifetimeWhereClauseItemContext lifetimeWhereClauseItem() {
			return GetRuleContext<LifetimeWhereClauseItemContext>(0);
		}
		public TypeBoundWhereClauseItemContext typeBoundWhereClauseItem() {
			return GetRuleContext<TypeBoundWhereClauseItemContext>(0);
		}
		public WhereClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whereClauseItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterWhereClauseItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitWhereClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public WhereClauseItemContext whereClauseItem() {
		WhereClauseItemContext _localctx = new WhereClauseItemContext(Context, State);
		EnterRule(_localctx, 130, RULE_whereClauseItem);
		try {
			State = 1198;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,146,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1196; lifetimeWhereClauseItem();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1197; typeBoundWhereClauseItem();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LifetimeWhereClauseItemContext : ParserRuleContext {
		public LifetimeContext lifetime() {
			return GetRuleContext<LifetimeContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public LifetimeBoundsContext lifetimeBounds() {
			return GetRuleContext<LifetimeBoundsContext>(0);
		}
		public LifetimeWhereClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lifetimeWhereClauseItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLifetimeWhereClauseItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLifetimeWhereClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public LifetimeWhereClauseItemContext lifetimeWhereClauseItem() {
		LifetimeWhereClauseItemContext _localctx = new LifetimeWhereClauseItemContext(Context, State);
		EnterRule(_localctx, 132, RULE_lifetimeWhereClauseItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1200; lifetime();
			State = 1201; Match(COLON);
			State = 1202; lifetimeBounds();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeBoundWhereClauseItemContext : ParserRuleContext {
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public ForLifetimesContext forLifetimes() {
			return GetRuleContext<ForLifetimesContext>(0);
		}
		public TypeParamBoundsContext typeParamBounds() {
			return GetRuleContext<TypeParamBoundsContext>(0);
		}
		public TypeBoundWhereClauseItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeBoundWhereClauseItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypeBoundWhereClauseItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypeBoundWhereClauseItem(this);
		}
	}

	[RuleVersion(0)]
	public TypeBoundWhereClauseItemContext typeBoundWhereClauseItem() {
		TypeBoundWhereClauseItemContext _localctx = new TypeBoundWhereClauseItemContext(Context, State);
		EnterRule(_localctx, 134, RULE_typeBoundWhereClauseItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1205;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,147,Context) ) {
			case 1:
				{
				State = 1204; forLifetimes();
				}
				break;
			}
			State = 1207; type_();
			State = 1208; Match(COLON);
			State = 1210;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_FOR) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (PATHSEP - 81)) | (1L << (QUESTION - 81)) | (1L << (LPAREN - 81)))) != 0)) {
				{
				State = 1209; typeParamBounds();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForLifetimesContext : ParserRuleContext {
		public ITerminalNode KW_FOR() { return GetToken(RustParser.KW_FOR, 0); }
		public GenericParamsContext genericParams() {
			return GetRuleContext<GenericParamsContext>(0);
		}
		public ForLifetimesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forLifetimes; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterForLifetimes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitForLifetimes(this);
		}
	}

	[RuleVersion(0)]
	public ForLifetimesContext forLifetimes() {
		ForLifetimesContext _localctx = new ForLifetimesContext(Context, State);
		EnterRule(_localctx, 136, RULE_forLifetimes);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1212; Match(KW_FOR);
			State = 1213; genericParams();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssociatedItemContext : ParserRuleContext {
		public MacroInvocationSemiContext macroInvocationSemi() {
			return GetRuleContext<MacroInvocationSemiContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public TypeAliasContext typeAlias() {
			return GetRuleContext<TypeAliasContext>(0);
		}
		public ConstantItemContext constantItem() {
			return GetRuleContext<ConstantItemContext>(0);
		}
		public Function_Context function_() {
			return GetRuleContext<Function_Context>(0);
		}
		public VisibilityContext visibility() {
			return GetRuleContext<VisibilityContext>(0);
		}
		public AssociatedItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_associatedItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAssociatedItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAssociatedItem(this);
		}
	}

	[RuleVersion(0)]
	public AssociatedItemContext associatedItem() {
		AssociatedItemContext _localctx = new AssociatedItemContext(Context, State);
		EnterRule(_localctx, 138, RULE_associatedItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1218;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 1215; outerAttribute();
				}
				}
				State = 1220;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1230;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_CRATE:
			case KW_SELFVALUE:
			case KW_SUPER:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case PATHSEP:
				{
				State = 1221; macroInvocationSemi();
				}
				break;
			case KW_CONST:
			case KW_EXTERN:
			case KW_FN:
			case KW_PUB:
			case KW_TYPE:
			case KW_UNSAFE:
			case KW_ASYNC:
				{
				State = 1223;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KW_PUB) {
					{
					State = 1222; visibility();
					}
				}

				State = 1228;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,151,Context) ) {
				case 1:
					{
					State = 1225; typeAlias();
					}
					break;
				case 2:
					{
					State = 1226; constantItem();
					}
					break;
				case 3:
					{
					State = 1227; function_();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InnerAttributeContext : ParserRuleContext {
		public ITerminalNode POUND() { return GetToken(RustParser.POUND, 0); }
		public ITerminalNode NOT() { return GetToken(RustParser.NOT, 0); }
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public AttrContext attr() {
			return GetRuleContext<AttrContext>(0);
		}
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public InnerAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_innerAttribute; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterInnerAttribute(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitInnerAttribute(this);
		}
	}

	[RuleVersion(0)]
	public InnerAttributeContext innerAttribute() {
		InnerAttributeContext _localctx = new InnerAttributeContext(Context, State);
		EnterRule(_localctx, 140, RULE_innerAttribute);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1232; Match(POUND);
			State = 1233; Match(NOT);
			State = 1234; Match(LSQUAREBRACKET);
			State = 1235; attr();
			State = 1236; Match(RSQUAREBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterAttributeContext : ParserRuleContext {
		public ITerminalNode POUND() { return GetToken(RustParser.POUND, 0); }
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public AttrContext attr() {
			return GetRuleContext<AttrContext>(0);
		}
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public OuterAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerAttribute; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterOuterAttribute(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitOuterAttribute(this);
		}
	}

	[RuleVersion(0)]
	public OuterAttributeContext outerAttribute() {
		OuterAttributeContext _localctx = new OuterAttributeContext(Context, State);
		EnterRule(_localctx, 142, RULE_outerAttribute);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1238; Match(POUND);
			State = 1239; Match(LSQUAREBRACKET);
			State = 1240; attr();
			State = 1241; Match(RSQUAREBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttrContext : ParserRuleContext {
		public SimplePathContext simplePath() {
			return GetRuleContext<SimplePathContext>(0);
		}
		public AttrInputContext attrInput() {
			return GetRuleContext<AttrInputContext>(0);
		}
		public AttrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAttr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAttr(this);
		}
	}

	[RuleVersion(0)]
	public AttrContext attr() {
		AttrContext _localctx = new AttrContext(Context, State);
		EnterRule(_localctx, 144, RULE_attr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1243; simplePath();
			State = 1245;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 103)) & ~0x3f) == 0 && ((1L << (_la - 103)) & ((1L << (EQ - 103)) | (1L << (LCURLYBRACE - 103)) | (1L << (LSQUAREBRACKET - 103)) | (1L << (LPAREN - 103)))) != 0)) {
				{
				State = 1244; attrInput();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttrInputContext : ParserRuleContext {
		public DelimTokenTreeContext delimTokenTree() {
			return GetRuleContext<DelimTokenTreeContext>(0);
		}
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public AttrInputContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attrInput; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAttrInput(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAttrInput(this);
		}
	}

	[RuleVersion(0)]
	public AttrInputContext attrInput() {
		AttrInputContext _localctx = new AttrInputContext(Context, State);
		EnterRule(_localctx, 146, RULE_attrInput);
		try {
			State = 1250;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LCURLYBRACE:
			case LSQUAREBRACKET:
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1247; delimTokenTree();
				}
				break;
			case EQ:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1248; Match(EQ);
				State = 1249; literalExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public ItemContext item() {
			return GetRuleContext<ItemContext>(0);
		}
		public LetStatementContext letStatement() {
			return GetRuleContext<LetStatementContext>(0);
		}
		public ExpressionStatementContext expressionStatement() {
			return GetRuleContext<ExpressionStatementContext>(0);
		}
		public MacroInvocationSemiContext macroInvocationSemi() {
			return GetRuleContext<MacroInvocationSemiContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 148, RULE_statement);
		try {
			State = 1257;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,155,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1252; Match(SEMI);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1253; item();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1254; letStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1255; expressionStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1256; macroInvocationSemi();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetStatementContext : ParserRuleContext {
		public ITerminalNode KW_LET() { return GetToken(RustParser.KW_LET, 0); }
		public PatternNoTopAltContext patternNoTopAlt() {
			return GetRuleContext<PatternNoTopAltContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LetStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLetStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLetStatement(this);
		}
	}

	[RuleVersion(0)]
	public LetStatementContext letStatement() {
		LetStatementContext _localctx = new LetStatementContext(Context, State);
		EnterRule(_localctx, 150, RULE_letStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1262;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 1259; outerAttribute();
				}
				}
				State = 1264;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1265; Match(KW_LET);
			State = 1266; patternNoTopAlt();
			State = 1269;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLON) {
				{
				State = 1267; Match(COLON);
				State = 1268; type_();
				}
			}

			State = 1273;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQ) {
				{
				State = 1271; Match(EQ);
				State = 1272; expression(0);
				}
			}

			State = 1275; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionStatementContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public ExpressionWithBlockContext expressionWithBlock() {
			return GetRuleContext<ExpressionWithBlockContext>(0);
		}
		public ExpressionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterExpressionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitExpressionStatement(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionStatementContext expressionStatement() {
		ExpressionStatementContext _localctx = new ExpressionStatementContext(Context, State);
		EnterRule(_localctx, 152, RULE_expressionStatement);
		try {
			State = 1284;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,160,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1277; expression(0);
				State = 1278; Match(SEMI);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1280; expressionWithBlock();
				State = 1282;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,159,Context) ) {
				case 1:
					{
					State = 1281; Match(SEMI);
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TypeCastExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode KW_AS() { return GetToken(RustParser.KW_AS, 0); }
		public TypeNoBoundsContext typeNoBounds() {
			return GetRuleContext<TypeNoBoundsContext>(0);
		}
		public TypeCastExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypeCastExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypeCastExpression(this);
		}
	}
	public partial class PathExpression_Context : ExpressionContext {
		public PathExpressionContext pathExpression() {
			return GetRuleContext<PathExpressionContext>(0);
		}
		public PathExpression_Context(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPathExpression_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPathExpression_(this);
		}
	}
	public partial class TupleExpressionContext : ExpressionContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public TupleElementsContext tupleElements() {
			return GetRuleContext<TupleElementsContext>(0);
		}
		public TupleExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleExpression(this);
		}
	}
	public partial class IndexExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public IndexExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterIndexExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitIndexExpression(this);
		}
	}
	public partial class RangeExpressionContext : ExpressionContext {
		public ITerminalNode DOTDOT() { return GetToken(RustParser.DOTDOT, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode DOTDOTEQ() { return GetToken(RustParser.DOTDOTEQ, 0); }
		public RangeExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterRangeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitRangeExpression(this);
		}
	}
	public partial class MacroInvocationAsExpressionContext : ExpressionContext {
		public MacroInvocationContext macroInvocation() {
			return GetRuleContext<MacroInvocationContext>(0);
		}
		public MacroInvocationAsExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroInvocationAsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroInvocationAsExpression(this);
		}
	}
	public partial class ReturnExpressionContext : ExpressionContext {
		public ITerminalNode KW_RETURN() { return GetToken(RustParser.KW_RETURN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ReturnExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterReturnExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitReturnExpression(this);
		}
	}
	public partial class AwaitExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(RustParser.DOT, 0); }
		public ITerminalNode KW_AWAIT() { return GetToken(RustParser.KW_AWAIT, 0); }
		public AwaitExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAwaitExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAwaitExpression(this);
		}
	}
	public partial class ErrorPropagationExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode QUESTION() { return GetToken(RustParser.QUESTION, 0); }
		public ErrorPropagationExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterErrorPropagationExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitErrorPropagationExpression(this);
		}
	}
	public partial class ContinueExpressionContext : ExpressionContext {
		public ITerminalNode KW_CONTINUE() { return GetToken(RustParser.KW_CONTINUE, 0); }
		public ITerminalNode LIFETIME_OR_LABEL() { return GetToken(RustParser.LIFETIME_OR_LABEL, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ContinueExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterContinueExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitContinueExpression(this);
		}
	}
	public partial class AssignmentExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public AssignmentExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAssignmentExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAssignmentExpression(this);
		}
	}
	public partial class MethodCallExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(RustParser.DOT, 0); }
		public PathExprSegmentContext pathExprSegment() {
			return GetRuleContext<PathExprSegmentContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public CallParamsContext callParams() {
			return GetRuleContext<CallParamsContext>(0);
		}
		public MethodCallExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMethodCallExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMethodCallExpression(this);
		}
	}
	public partial class LiteralExpression_Context : ExpressionContext {
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public LiteralExpression_Context(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpression_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpression_(this);
		}
	}
	public partial class StructExpression_Context : ExpressionContext {
		public StructExpressionContext structExpression() {
			return GetRuleContext<StructExpressionContext>(0);
		}
		public StructExpression_Context(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructExpression_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructExpression_(this);
		}
	}
	public partial class TupleIndexingExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(RustParser.DOT, 0); }
		public TupleIndexContext tupleIndex() {
			return GetRuleContext<TupleIndexContext>(0);
		}
		public TupleIndexingExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleIndexingExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleIndexingExpression(this);
		}
	}
	public partial class NegationExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(RustParser.MINUS, 0); }
		public ITerminalNode NOT() { return GetToken(RustParser.NOT, 0); }
		public NegationExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterNegationExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitNegationExpression(this);
		}
	}
	public partial class CallExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public CallParamsContext callParams() {
			return GetRuleContext<CallParamsContext>(0);
		}
		public CallExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterCallExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitCallExpression(this);
		}
	}
	public partial class LazyBooleanExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode ANDAND() { return GetToken(RustParser.ANDAND, 0); }
		public ITerminalNode OROR() { return GetToken(RustParser.OROR, 0); }
		public LazyBooleanExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLazyBooleanExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLazyBooleanExpression(this);
		}
	}
	public partial class DereferenceExpressionContext : ExpressionContext {
		public ITerminalNode STAR() { return GetToken(RustParser.STAR, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DereferenceExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterDereferenceExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitDereferenceExpression(this);
		}
	}
	public partial class ExpressionWithBlock_Context : ExpressionContext {
		public ExpressionWithBlockContext expressionWithBlock() {
			return GetRuleContext<ExpressionWithBlockContext>(0);
		}
		public ExpressionWithBlock_Context(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterExpressionWithBlock_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitExpressionWithBlock_(this);
		}
	}
	public partial class GroupedExpressionContext : ExpressionContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public GroupedExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGroupedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGroupedExpression(this);
		}
	}
	public partial class BreakExpressionContext : ExpressionContext {
		public ITerminalNode KW_BREAK() { return GetToken(RustParser.KW_BREAK, 0); }
		public ITerminalNode LIFETIME_OR_LABEL() { return GetToken(RustParser.LIFETIME_OR_LABEL, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BreakExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterBreakExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitBreakExpression(this);
		}
	}
	public partial class ArithmeticOrLogicalExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode STAR() { return GetToken(RustParser.STAR, 0); }
		public ITerminalNode SLASH() { return GetToken(RustParser.SLASH, 0); }
		public ITerminalNode PERCENT() { return GetToken(RustParser.PERCENT, 0); }
		public ITerminalNode PLUS() { return GetToken(RustParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(RustParser.MINUS, 0); }
		public ShlContext shl() {
			return GetRuleContext<ShlContext>(0);
		}
		public ShrContext shr() {
			return GetRuleContext<ShrContext>(0);
		}
		public ITerminalNode AND() { return GetToken(RustParser.AND, 0); }
		public ITerminalNode CARET() { return GetToken(RustParser.CARET, 0); }
		public ITerminalNode OR() { return GetToken(RustParser.OR, 0); }
		public ArithmeticOrLogicalExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterArithmeticOrLogicalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitArithmeticOrLogicalExpression(this);
		}
	}
	public partial class FieldExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(RustParser.DOT, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public FieldExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFieldExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFieldExpression(this);
		}
	}
	public partial class EnumerationVariantExpression_Context : ExpressionContext {
		public EnumerationVariantExpressionContext enumerationVariantExpression() {
			return GetRuleContext<EnumerationVariantExpressionContext>(0);
		}
		public EnumerationVariantExpression_Context(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumerationVariantExpression_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumerationVariantExpression_(this);
		}
	}
	public partial class ComparisonExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ComparisonOperatorContext comparisonOperator() {
			return GetRuleContext<ComparisonOperatorContext>(0);
		}
		public ComparisonExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterComparisonExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitComparisonExpression(this);
		}
	}
	public partial class AttributedExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public AttributedExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAttributedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAttributedExpression(this);
		}
	}
	public partial class BorrowExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AND() { return GetToken(RustParser.AND, 0); }
		public ITerminalNode ANDAND() { return GetToken(RustParser.ANDAND, 0); }
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public BorrowExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterBorrowExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitBorrowExpression(this);
		}
	}
	public partial class CompoundAssignmentExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public CompoundAssignOperatorContext compoundAssignOperator() {
			return GetRuleContext<CompoundAssignOperatorContext>(0);
		}
		public CompoundAssignmentExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterCompoundAssignmentExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitCompoundAssignmentExpression(this);
		}
	}
	public partial class ClosureExpression_Context : ExpressionContext {
		public ClosureExpressionContext closureExpression() {
			return GetRuleContext<ClosureExpressionContext>(0);
		}
		public ClosureExpression_Context(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterClosureExpression_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitClosureExpression_(this);
		}
	}
	public partial class ArrayExpressionContext : ExpressionContext {
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public ArrayElementsContext arrayElements() {
			return GetRuleContext<ArrayElementsContext>(0);
		}
		public ArrayExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterArrayExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitArrayExpression(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 154;
		EnterRecursionRule(_localctx, 154, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1366;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,174,Context) ) {
			case 1:
				{
				_localctx = new AttributedExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 1288;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 1287; outerAttribute();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 1290;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,161,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 1292; expression(40);
				}
				break;
			case 2:
				{
				_localctx = new LiteralExpression_Context(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1294; literalExpression();
				}
				break;
			case 3:
				{
				_localctx = new PathExpression_Context(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1295; pathExpression();
				}
				break;
			case 4:
				{
				_localctx = new BorrowExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1296;
				_la = TokenStream.LA(1);
				if ( !(_la==AND || _la==ANDAND) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1298;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KW_MUT) {
					{
					State = 1297; Match(KW_MUT);
					}
				}

				State = 1300; expression(30);
				}
				break;
			case 5:
				{
				_localctx = new DereferenceExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1301; Match(STAR);
				State = 1302; expression(29);
				}
				break;
			case 6:
				{
				_localctx = new NegationExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1303;
				_la = TokenStream.LA(1);
				if ( !(_la==MINUS || _la==NOT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1304; expression(28);
				}
				break;
			case 7:
				{
				_localctx = new RangeExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1305; Match(DOTDOT);
				State = 1307;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,163,Context) ) {
				case 1:
					{
					State = 1306; expression(0);
					}
					break;
				}
				}
				break;
			case 8:
				{
				_localctx = new RangeExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1309; Match(DOTDOTEQ);
				State = 1310; expression(15);
				}
				break;
			case 9:
				{
				_localctx = new ContinueExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1311; Match(KW_CONTINUE);
				State = 1313;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,164,Context) ) {
				case 1:
					{
					State = 1312; Match(LIFETIME_OR_LABEL);
					}
					break;
				}
				State = 1316;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,165,Context) ) {
				case 1:
					{
					State = 1315; expression(0);
					}
					break;
				}
				}
				break;
			case 10:
				{
				_localctx = new BreakExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1318; Match(KW_BREAK);
				State = 1320;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,166,Context) ) {
				case 1:
					{
					State = 1319; Match(LIFETIME_OR_LABEL);
					}
					break;
				}
				State = 1323;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,167,Context) ) {
				case 1:
					{
					State = 1322; expression(0);
					}
					break;
				}
				}
				break;
			case 11:
				{
				_localctx = new ReturnExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1325; Match(KW_RETURN);
				State = 1327;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,168,Context) ) {
				case 1:
					{
					State = 1326; expression(0);
					}
					break;
				}
				}
				break;
			case 12:
				{
				_localctx = new GroupedExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1329; Match(LPAREN);
				State = 1333;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,169,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1330; innerAttribute();
						}
						} 
					}
					State = 1335;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,169,Context);
				}
				State = 1336; expression(0);
				State = 1337; Match(RPAREN);
				}
				break;
			case 13:
				{
				_localctx = new ArrayExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1339; Match(LSQUAREBRACKET);
				State = 1343;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,170,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1340; innerAttribute();
						}
						} 
					}
					State = 1345;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,170,Context);
				}
				State = 1347;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOVE) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					State = 1346; arrayElements();
					}
				}

				State = 1349; Match(RSQUAREBRACKET);
				}
				break;
			case 14:
				{
				_localctx = new TupleExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1350; Match(LPAREN);
				State = 1354;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,172,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1351; innerAttribute();
						}
						} 
					}
					State = 1356;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,172,Context);
				}
				State = 1358;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOVE) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					State = 1357; tupleElements();
					}
				}

				State = 1360; Match(RPAREN);
				}
				break;
			case 15:
				{
				_localctx = new StructExpression_Context(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1361; structExpression();
				}
				break;
			case 16:
				{
				_localctx = new EnumerationVariantExpression_Context(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1362; enumerationVariantExpression();
				}
				break;
			case 17:
				{
				_localctx = new ClosureExpression_Context(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1363; closureExpression();
				}
				break;
			case 18:
				{
				_localctx = new ExpressionWithBlock_Context(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1364; expressionWithBlock();
				}
				break;
			case 19:
				{
				_localctx = new MacroInvocationAsExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 1365; macroInvocation();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 1451;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,180,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 1449;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,179,Context) ) {
					case 1:
						{
						_localctx = new ArithmeticOrLogicalExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1368;
						if (!(Precpred(Context, 26))) throw new FailedPredicateException(this, "Precpred(Context, 26)");
						State = 1369;
						_la = TokenStream.LA(1);
						if ( !(((((_la - 84)) & ~0x3f) == 0 && ((1L << (_la - 84)) & ((1L << (STAR - 84)) | (1L << (SLASH - 84)) | (1L << (PERCENT - 84)))) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 1370; expression(27);
						}
						break;
					case 2:
						{
						_localctx = new ArithmeticOrLogicalExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1371;
						if (!(Precpred(Context, 25))) throw new FailedPredicateException(this, "Precpred(Context, 25)");
						State = 1372;
						_la = TokenStream.LA(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 1373; expression(26);
						}
						break;
					case 3:
						{
						_localctx = new ArithmeticOrLogicalExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1374;
						if (!(Precpred(Context, 24))) throw new FailedPredicateException(this, "Precpred(Context, 24)");
						State = 1377;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case LT:
							{
							State = 1375; shl();
							}
							break;
						case GT:
							{
							State = 1376; shr();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 1379; expression(25);
						}
						break;
					case 4:
						{
						_localctx = new ArithmeticOrLogicalExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1381;
						if (!(Precpred(Context, 23))) throw new FailedPredicateException(this, "Precpred(Context, 23)");
						State = 1382; Match(AND);
						State = 1383; expression(24);
						}
						break;
					case 5:
						{
						_localctx = new ArithmeticOrLogicalExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1384;
						if (!(Precpred(Context, 22))) throw new FailedPredicateException(this, "Precpred(Context, 22)");
						State = 1385; Match(CARET);
						State = 1386; expression(23);
						}
						break;
					case 6:
						{
						_localctx = new ArithmeticOrLogicalExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1387;
						if (!(Precpred(Context, 21))) throw new FailedPredicateException(this, "Precpred(Context, 21)");
						State = 1388; Match(OR);
						State = 1389; expression(22);
						}
						break;
					case 7:
						{
						_localctx = new ComparisonExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1390;
						if (!(Precpred(Context, 20))) throw new FailedPredicateException(this, "Precpred(Context, 20)");
						State = 1391; comparisonOperator();
						State = 1392; expression(21);
						}
						break;
					case 8:
						{
						_localctx = new LazyBooleanExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1394;
						if (!(Precpred(Context, 19))) throw new FailedPredicateException(this, "Precpred(Context, 19)");
						State = 1395; Match(ANDAND);
						State = 1396; expression(20);
						}
						break;
					case 9:
						{
						_localctx = new LazyBooleanExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1397;
						if (!(Precpred(Context, 18))) throw new FailedPredicateException(this, "Precpred(Context, 18)");
						State = 1398; Match(OROR);
						State = 1399; expression(19);
						}
						break;
					case 10:
						{
						_localctx = new RangeExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1400;
						if (!(Precpred(Context, 14))) throw new FailedPredicateException(this, "Precpred(Context, 14)");
						State = 1401; Match(DOTDOTEQ);
						State = 1402; expression(15);
						}
						break;
					case 11:
						{
						_localctx = new AssignmentExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1403;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 1404; Match(EQ);
						State = 1405; expression(14);
						}
						break;
					case 12:
						{
						_localctx = new CompoundAssignmentExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1406;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 1407; compoundAssignOperator();
						State = 1408; expression(13);
						}
						break;
					case 13:
						{
						_localctx = new MethodCallExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1410;
						if (!(Precpred(Context, 37))) throw new FailedPredicateException(this, "Precpred(Context, 37)");
						State = 1411; Match(DOT);
						State = 1412; pathExprSegment();
						State = 1413; Match(LPAREN);
						State = 1415;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOVE) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
							{
							State = 1414; callParams();
							}
						}

						State = 1417; Match(RPAREN);
						}
						break;
					case 14:
						{
						_localctx = new FieldExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1419;
						if (!(Precpred(Context, 36))) throw new FailedPredicateException(this, "Precpred(Context, 36)");
						State = 1420; Match(DOT);
						State = 1421; identifier();
						}
						break;
					case 15:
						{
						_localctx = new TupleIndexingExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1422;
						if (!(Precpred(Context, 35))) throw new FailedPredicateException(this, "Precpred(Context, 35)");
						State = 1423; Match(DOT);
						State = 1424; tupleIndex();
						}
						break;
					case 16:
						{
						_localctx = new AwaitExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1425;
						if (!(Precpred(Context, 34))) throw new FailedPredicateException(this, "Precpred(Context, 34)");
						State = 1426; Match(DOT);
						State = 1427; Match(KW_AWAIT);
						}
						break;
					case 17:
						{
						_localctx = new CallExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1428;
						if (!(Precpred(Context, 33))) throw new FailedPredicateException(this, "Precpred(Context, 33)");
						State = 1429; Match(LPAREN);
						State = 1431;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOVE) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
							{
							State = 1430; callParams();
							}
						}

						State = 1433; Match(RPAREN);
						}
						break;
					case 18:
						{
						_localctx = new IndexExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1434;
						if (!(Precpred(Context, 32))) throw new FailedPredicateException(this, "Precpred(Context, 32)");
						State = 1435; Match(LSQUAREBRACKET);
						State = 1436; expression(0);
						State = 1437; Match(RSQUAREBRACKET);
						}
						break;
					case 19:
						{
						_localctx = new ErrorPropagationExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1439;
						if (!(Precpred(Context, 31))) throw new FailedPredicateException(this, "Precpred(Context, 31)");
						State = 1440; Match(QUESTION);
						}
						break;
					case 20:
						{
						_localctx = new TypeCastExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1441;
						if (!(Precpred(Context, 27))) throw new FailedPredicateException(this, "Precpred(Context, 27)");
						State = 1442; Match(KW_AS);
						State = 1443; typeNoBounds();
						}
						break;
					case 21:
						{
						_localctx = new RangeExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 1444;
						if (!(Precpred(Context, 17))) throw new FailedPredicateException(this, "Precpred(Context, 17)");
						State = 1445; Match(DOTDOT);
						State = 1447;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,178,Context) ) {
						case 1:
							{
							State = 1446; expression(0);
							}
							break;
						}
						}
						break;
					}
					} 
				}
				State = 1453;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,180,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ComparisonOperatorContext : ParserRuleContext {
		public ITerminalNode EQEQ() { return GetToken(RustParser.EQEQ, 0); }
		public ITerminalNode NE() { return GetToken(RustParser.NE, 0); }
		public ITerminalNode GT() { return GetToken(RustParser.GT, 0); }
		public ITerminalNode LT() { return GetToken(RustParser.LT, 0); }
		public ITerminalNode GE() { return GetToken(RustParser.GE, 0); }
		public ITerminalNode LE() { return GetToken(RustParser.LE, 0); }
		public ComparisonOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterComparisonOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitComparisonOperator(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonOperatorContext comparisonOperator() {
		ComparisonOperatorContext _localctx = new ComparisonOperatorContext(Context, State);
		EnterRule(_localctx, 156, RULE_comparisonOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1454;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 104)) & ~0x3f) == 0 && ((1L << (_la - 104)) & ((1L << (EQEQ - 104)) | (1L << (NE - 104)) | (1L << (GT - 104)) | (1L << (LT - 104)) | (1L << (GE - 104)) | (1L << (LE - 104)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundAssignOperatorContext : ParserRuleContext {
		public ITerminalNode PLUSEQ() { return GetToken(RustParser.PLUSEQ, 0); }
		public ITerminalNode MINUSEQ() { return GetToken(RustParser.MINUSEQ, 0); }
		public ITerminalNode STAREQ() { return GetToken(RustParser.STAREQ, 0); }
		public ITerminalNode SLASHEQ() { return GetToken(RustParser.SLASHEQ, 0); }
		public ITerminalNode PERCENTEQ() { return GetToken(RustParser.PERCENTEQ, 0); }
		public ITerminalNode ANDEQ() { return GetToken(RustParser.ANDEQ, 0); }
		public ITerminalNode OREQ() { return GetToken(RustParser.OREQ, 0); }
		public ITerminalNode CARETEQ() { return GetToken(RustParser.CARETEQ, 0); }
		public ITerminalNode SHLEQ() { return GetToken(RustParser.SHLEQ, 0); }
		public ITerminalNode SHREQ() { return GetToken(RustParser.SHREQ, 0); }
		public CompoundAssignOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundAssignOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterCompoundAssignOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitCompoundAssignOperator(this);
		}
	}

	[RuleVersion(0)]
	public CompoundAssignOperatorContext compoundAssignOperator() {
		CompoundAssignOperatorContext _localctx = new CompoundAssignOperatorContext(Context, State);
		EnterRule(_localctx, 158, RULE_compoundAssignOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1456;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 93)) & ~0x3f) == 0 && ((1L << (_la - 93)) & ((1L << (PLUSEQ - 93)) | (1L << (MINUSEQ - 93)) | (1L << (STAREQ - 93)) | (1L << (SLASHEQ - 93)) | (1L << (PERCENTEQ - 93)) | (1L << (CARETEQ - 93)) | (1L << (ANDEQ - 93)) | (1L << (OREQ - 93)) | (1L << (SHLEQ - 93)) | (1L << (SHREQ - 93)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithBlockContext : ParserRuleContext {
		public ExpressionWithBlockContext expressionWithBlock() {
			return GetRuleContext<ExpressionWithBlockContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public AsyncBlockExpressionContext asyncBlockExpression() {
			return GetRuleContext<AsyncBlockExpressionContext>(0);
		}
		public UnsafeBlockExpressionContext unsafeBlockExpression() {
			return GetRuleContext<UnsafeBlockExpressionContext>(0);
		}
		public LoopExpressionContext loopExpression() {
			return GetRuleContext<LoopExpressionContext>(0);
		}
		public IfExpressionContext ifExpression() {
			return GetRuleContext<IfExpressionContext>(0);
		}
		public IfLetExpressionContext ifLetExpression() {
			return GetRuleContext<IfLetExpressionContext>(0);
		}
		public MatchExpressionContext matchExpression() {
			return GetRuleContext<MatchExpressionContext>(0);
		}
		public ExpressionWithBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterExpressionWithBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitExpressionWithBlock(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithBlockContext expressionWithBlock() {
		ExpressionWithBlockContext _localctx = new ExpressionWithBlockContext(Context, State);
		EnterRule(_localctx, 160, RULE_expressionWithBlock);
		try {
			int _alt;
			State = 1472;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,182,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1459;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 1458; outerAttribute();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 1461;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,181,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 1463; expressionWithBlock();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1465; blockExpression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1466; asyncBlockExpression();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1467; unsafeBlockExpression();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1468; loopExpression();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1469; ifExpression();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1470; ifLetExpression();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1471; matchExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralExpressionContext : ParserRuleContext {
		public ITerminalNode CHAR_LITERAL() { return GetToken(RustParser.CHAR_LITERAL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(RustParser.STRING_LITERAL, 0); }
		public ITerminalNode RAW_STRING_LITERAL() { return GetToken(RustParser.RAW_STRING_LITERAL, 0); }
		public ITerminalNode BYTE_LITERAL() { return GetToken(RustParser.BYTE_LITERAL, 0); }
		public ITerminalNode BYTE_STRING_LITERAL() { return GetToken(RustParser.BYTE_STRING_LITERAL, 0); }
		public ITerminalNode RAW_BYTE_STRING_LITERAL() { return GetToken(RustParser.RAW_BYTE_STRING_LITERAL, 0); }
		public ITerminalNode INTEGER_LITERAL() { return GetToken(RustParser.INTEGER_LITERAL, 0); }
		public ITerminalNode FLOAT_LITERAL() { return GetToken(RustParser.FLOAT_LITERAL, 0); }
		public ITerminalNode KW_TRUE() { return GetToken(RustParser.KW_TRUE, 0); }
		public ITerminalNode KW_FALSE() { return GetToken(RustParser.KW_FALSE, 0); }
		public LiteralExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpression(this);
		}
	}

	[RuleVersion(0)]
	public LiteralExpressionContext literalExpression() {
		LiteralExpressionContext _localctx = new LiteralExpressionContext(Context, State);
		EnterRule(_localctx, 162, RULE_literalExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1474;
			_la = TokenStream.LA(1);
			if ( !(_la==KW_FALSE || _la==KW_TRUE || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathExpressionContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public QualifiedPathInExpressionContext qualifiedPathInExpression() {
			return GetRuleContext<QualifiedPathInExpressionContext>(0);
		}
		public PathExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPathExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPathExpression(this);
		}
	}

	[RuleVersion(0)]
	public PathExpressionContext pathExpression() {
		PathExpressionContext _localctx = new PathExpressionContext(Context, State);
		EnterRule(_localctx, 164, RULE_pathExpression);
		try {
			State = 1478;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_CRATE:
			case KW_SELFVALUE:
			case KW_SELFTYPE:
			case KW_SUPER:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case PATHSEP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1476; pathInExpression();
				}
				break;
			case LT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1477; qualifiedPathInExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExpressionContext : ParserRuleContext {
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public BlockExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterBlockExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitBlockExpression(this);
		}
	}

	[RuleVersion(0)]
	public BlockExpressionContext blockExpression() {
		BlockExpressionContext _localctx = new BlockExpressionContext(Context, State);
		EnterRule(_localctx, 166, RULE_blockExpression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1480; Match(LCURLYBRACE);
			State = 1484;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,184,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1481; innerAttribute();
					}
					} 
				}
				State = 1486;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,184,Context);
			}
			State = 1488;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_PUB) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_UNION) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (SEMI - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 1487; statements();
				}
			}

			State = 1490; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementsContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStatements(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		StatementsContext _localctx = new StatementsContext(Context, State);
		EnterRule(_localctx, 168, RULE_statements);
		int _la;
		try {
			int _alt;
			State = 1501;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,188,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1493;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 1492; statement();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 1495;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,186,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 1498;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOVE) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
					{
					State = 1497; expression(0);
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1500; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsyncBlockExpressionContext : ParserRuleContext {
		public ITerminalNode KW_ASYNC() { return GetToken(RustParser.KW_ASYNC, 0); }
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public ITerminalNode KW_MOVE() { return GetToken(RustParser.KW_MOVE, 0); }
		public AsyncBlockExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asyncBlockExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterAsyncBlockExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitAsyncBlockExpression(this);
		}
	}

	[RuleVersion(0)]
	public AsyncBlockExpressionContext asyncBlockExpression() {
		AsyncBlockExpressionContext _localctx = new AsyncBlockExpressionContext(Context, State);
		EnterRule(_localctx, 170, RULE_asyncBlockExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1503; Match(KW_ASYNC);
			State = 1505;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_MOVE) {
				{
				State = 1504; Match(KW_MOVE);
				}
			}

			State = 1507; blockExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnsafeBlockExpressionContext : ParserRuleContext {
		public ITerminalNode KW_UNSAFE() { return GetToken(RustParser.KW_UNSAFE, 0); }
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public UnsafeBlockExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unsafeBlockExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterUnsafeBlockExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitUnsafeBlockExpression(this);
		}
	}

	[RuleVersion(0)]
	public UnsafeBlockExpressionContext unsafeBlockExpression() {
		UnsafeBlockExpressionContext _localctx = new UnsafeBlockExpressionContext(Context, State);
		EnterRule(_localctx, 172, RULE_unsafeBlockExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1509; Match(KW_UNSAFE);
			State = 1510; blockExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayElementsContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public ArrayElementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayElements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterArrayElements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitArrayElements(this);
		}
	}

	[RuleVersion(0)]
	public ArrayElementsContext arrayElements() {
		ArrayElementsContext _localctx = new ArrayElementsContext(Context, State);
		EnterRule(_localctx, 174, RULE_arrayElements);
		int _la;
		try {
			int _alt;
			State = 1527;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,192,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1512; expression(0);
				State = 1517;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,190,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1513; Match(COMMA);
						State = 1514; expression(0);
						}
						} 
					}
					State = 1519;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,190,Context);
				}
				State = 1521;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1520; Match(COMMA);
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1523; expression(0);
				State = 1524; Match(SEMI);
				State = 1525; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleElementsContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public TupleElementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleElements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleElements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleElements(this);
		}
	}

	[RuleVersion(0)]
	public TupleElementsContext tupleElements() {
		TupleElementsContext _localctx = new TupleElementsContext(Context, State);
		EnterRule(_localctx, 176, RULE_tupleElements);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1532;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 1529; expression(0);
					State = 1530; Match(COMMA);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1534;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,193,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 1537;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOVE) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 1536; expression(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleIndexContext : ParserRuleContext {
		public ITerminalNode INTEGER_LITERAL() { return GetToken(RustParser.INTEGER_LITERAL, 0); }
		public TupleIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleIndex; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleIndex(this);
		}
	}

	[RuleVersion(0)]
	public TupleIndexContext tupleIndex() {
		TupleIndexContext _localctx = new TupleIndexContext(Context, State);
		EnterRule(_localctx, 178, RULE_tupleIndex);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1539; Match(INTEGER_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructExpressionContext : ParserRuleContext {
		public StructExprStructContext structExprStruct() {
			return GetRuleContext<StructExprStructContext>(0);
		}
		public StructExprTupleContext structExprTuple() {
			return GetRuleContext<StructExprTupleContext>(0);
		}
		public StructExprUnitContext structExprUnit() {
			return GetRuleContext<StructExprUnitContext>(0);
		}
		public StructExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructExpression(this);
		}
	}

	[RuleVersion(0)]
	public StructExpressionContext structExpression() {
		StructExpressionContext _localctx = new StructExpressionContext(Context, State);
		EnterRule(_localctx, 180, RULE_structExpression);
		try {
			State = 1544;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,195,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1541; structExprStruct();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1542; structExprTuple();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1543; structExprUnit();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructExprStructContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public StructExprFieldsContext structExprFields() {
			return GetRuleContext<StructExprFieldsContext>(0);
		}
		public StructBaseContext structBase() {
			return GetRuleContext<StructBaseContext>(0);
		}
		public StructExprStructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExprStruct; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructExprStruct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructExprStruct(this);
		}
	}

	[RuleVersion(0)]
	public StructExprStructContext structExprStruct() {
		StructExprStructContext _localctx = new StructExprStructContext(Context, State);
		EnterRule(_localctx, 182, RULE_structExprStruct);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1546; pathInExpression();
			State = 1547; Match(LCURLYBRACE);
			State = 1551;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,196,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1548; innerAttribute();
					}
					} 
				}
				State = 1553;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,196,Context);
			}
			State = 1556;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_MACRORULES:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case INTEGER_LITERAL:
			case POUND:
				{
				State = 1554; structExprFields();
				}
				break;
			case DOTDOT:
				{
				State = 1555; structBase();
				}
				break;
			case RCURLYBRACE:
				break;
			default:
				break;
			}
			State = 1558; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructExprFieldsContext : ParserRuleContext {
		public StructExprFieldContext[] structExprField() {
			return GetRuleContexts<StructExprFieldContext>();
		}
		public StructExprFieldContext structExprField(int i) {
			return GetRuleContext<StructExprFieldContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public StructBaseContext structBase() {
			return GetRuleContext<StructBaseContext>(0);
		}
		public StructExprFieldsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExprFields; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructExprFields(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructExprFields(this);
		}
	}

	[RuleVersion(0)]
	public StructExprFieldsContext structExprFields() {
		StructExprFieldsContext _localctx = new StructExprFieldsContext(Context, State);
		EnterRule(_localctx, 184, RULE_structExprFields);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1560; structExprField();
			State = 1565;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,198,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1561; Match(COMMA);
					State = 1562; structExprField();
					}
					} 
				}
				State = 1567;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,198,Context);
			}
			State = 1573;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,200,Context) ) {
			case 1:
				{
				State = 1568; Match(COMMA);
				State = 1569; structBase();
				}
				break;
			case 2:
				{
				State = 1571;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1570; Match(COMMA);
					}
				}

				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructExprFieldContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public TupleIndexContext tupleIndex() {
			return GetRuleContext<TupleIndexContext>(0);
		}
		public StructExprFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExprField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructExprField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructExprField(this);
		}
	}

	[RuleVersion(0)]
	public StructExprFieldContext structExprField() {
		StructExprFieldContext _localctx = new StructExprFieldContext(Context, State);
		EnterRule(_localctx, 186, RULE_structExprField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1578;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 1575; outerAttribute();
				}
				}
				State = 1580;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1589;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,203,Context) ) {
			case 1:
				{
				State = 1581; identifier();
				}
				break;
			case 2:
				{
				State = 1584;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case KW_MACRORULES:
				case NON_KEYWORD_IDENTIFIER:
				case RAW_IDENTIFIER:
					{
					State = 1582; identifier();
					}
					break;
				case INTEGER_LITERAL:
					{
					State = 1583; tupleIndex();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1586; Match(COLON);
				State = 1587; expression(0);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructBaseContext : ParserRuleContext {
		public ITerminalNode DOTDOT() { return GetToken(RustParser.DOTDOT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StructBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructBase(this);
		}
	}

	[RuleVersion(0)]
	public StructBaseContext structBase() {
		StructBaseContext _localctx = new StructBaseContext(Context, State);
		EnterRule(_localctx, 188, RULE_structBase);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1591; Match(DOTDOT);
			State = 1592; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructExprTupleContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public StructExprTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExprTuple; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructExprTuple(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructExprTuple(this);
		}
	}

	[RuleVersion(0)]
	public StructExprTupleContext structExprTuple() {
		StructExprTupleContext _localctx = new StructExprTupleContext(Context, State);
		EnterRule(_localctx, 190, RULE_structExprTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1594; pathInExpression();
			State = 1595; Match(LPAREN);
			State = 1599;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,204,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1596; innerAttribute();
					}
					} 
				}
				State = 1601;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,204,Context);
			}
			State = 1613;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOVE) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 1602; expression(0);
				State = 1607;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,205,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1603; Match(COMMA);
						State = 1604; expression(0);
						}
						} 
					}
					State = 1609;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,205,Context);
				}
				State = 1611;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1610; Match(COMMA);
					}
				}

				}
			}

			State = 1615; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructExprUnitContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public StructExprUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExprUnit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructExprUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructExprUnit(this);
		}
	}

	[RuleVersion(0)]
	public StructExprUnitContext structExprUnit() {
		StructExprUnitContext _localctx = new StructExprUnitContext(Context, State);
		EnterRule(_localctx, 192, RULE_structExprUnit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1617; pathInExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumerationVariantExpressionContext : ParserRuleContext {
		public EnumExprStructContext enumExprStruct() {
			return GetRuleContext<EnumExprStructContext>(0);
		}
		public EnumExprTupleContext enumExprTuple() {
			return GetRuleContext<EnumExprTupleContext>(0);
		}
		public EnumExprFieldlessContext enumExprFieldless() {
			return GetRuleContext<EnumExprFieldlessContext>(0);
		}
		public EnumerationVariantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumerationVariantExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumerationVariantExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumerationVariantExpression(this);
		}
	}

	[RuleVersion(0)]
	public EnumerationVariantExpressionContext enumerationVariantExpression() {
		EnumerationVariantExpressionContext _localctx = new EnumerationVariantExpressionContext(Context, State);
		EnterRule(_localctx, 194, RULE_enumerationVariantExpression);
		try {
			State = 1622;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,208,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1619; enumExprStruct();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1620; enumExprTuple();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1621; enumExprFieldless();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumExprStructContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public EnumExprFieldsContext enumExprFields() {
			return GetRuleContext<EnumExprFieldsContext>(0);
		}
		public EnumExprStructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumExprStruct; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumExprStruct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumExprStruct(this);
		}
	}

	[RuleVersion(0)]
	public EnumExprStructContext enumExprStruct() {
		EnumExprStructContext _localctx = new EnumExprStructContext(Context, State);
		EnterRule(_localctx, 196, RULE_enumExprStruct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1624; pathInExpression();
			State = 1625; Match(LCURLYBRACE);
			State = 1627;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 54)) & ~0x3f) == 0 && ((1L << (_la - 54)) & ((1L << (KW_MACRORULES - 54)) | (1L << (NON_KEYWORD_IDENTIFIER - 54)) | (1L << (RAW_IDENTIFIER - 54)) | (1L << (INTEGER_LITERAL - 54)))) != 0)) {
				{
				State = 1626; enumExprFields();
				}
			}

			State = 1629; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumExprFieldsContext : ParserRuleContext {
		public EnumExprFieldContext[] enumExprField() {
			return GetRuleContexts<EnumExprFieldContext>();
		}
		public EnumExprFieldContext enumExprField(int i) {
			return GetRuleContext<EnumExprFieldContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public EnumExprFieldsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumExprFields; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumExprFields(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumExprFields(this);
		}
	}

	[RuleVersion(0)]
	public EnumExprFieldsContext enumExprFields() {
		EnumExprFieldsContext _localctx = new EnumExprFieldsContext(Context, State);
		EnterRule(_localctx, 198, RULE_enumExprFields);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1631; enumExprField();
			State = 1636;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,210,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1632; Match(COMMA);
					State = 1633; enumExprField();
					}
					} 
				}
				State = 1638;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,210,Context);
			}
			State = 1640;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1639; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumExprFieldContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TupleIndexContext tupleIndex() {
			return GetRuleContext<TupleIndexContext>(0);
		}
		public EnumExprFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumExprField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumExprField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumExprField(this);
		}
	}

	[RuleVersion(0)]
	public EnumExprFieldContext enumExprField() {
		EnumExprFieldContext _localctx = new EnumExprFieldContext(Context, State);
		EnterRule(_localctx, 200, RULE_enumExprField);
		try {
			State = 1650;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,213,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1642; identifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1645;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case KW_MACRORULES:
				case NON_KEYWORD_IDENTIFIER:
				case RAW_IDENTIFIER:
					{
					State = 1643; identifier();
					}
					break;
				case INTEGER_LITERAL:
					{
					State = 1644; tupleIndex();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1647; Match(COLON);
				State = 1648; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumExprTupleContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public EnumExprTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumExprTuple; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumExprTuple(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumExprTuple(this);
		}
	}

	[RuleVersion(0)]
	public EnumExprTupleContext enumExprTuple() {
		EnumExprTupleContext _localctx = new EnumExprTupleContext(Context, State);
		EnterRule(_localctx, 202, RULE_enumExprTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1652; pathInExpression();
			State = 1653; Match(LPAREN);
			State = 1665;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_BREAK) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOVE) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_UNSAFE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (LIFETIME_OR_LABEL - 69)) | (1L << (MINUS - 69)) | (1L << (STAR - 69)) | (1L << (NOT - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (OROR - 69)) | (1L << (LT - 69)) | (1L << (DOTDOT - 69)) | (1L << (DOTDOTEQ - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LCURLYBRACE - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 1654; expression(0);
				State = 1659;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,214,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1655; Match(COMMA);
						State = 1656; expression(0);
						}
						} 
					}
					State = 1661;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,214,Context);
				}
				State = 1663;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1662; Match(COMMA);
					}
				}

				}
			}

			State = 1667; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumExprFieldlessContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public EnumExprFieldlessContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumExprFieldless; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterEnumExprFieldless(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitEnumExprFieldless(this);
		}
	}

	[RuleVersion(0)]
	public EnumExprFieldlessContext enumExprFieldless() {
		EnumExprFieldlessContext _localctx = new EnumExprFieldlessContext(Context, State);
		EnterRule(_localctx, 204, RULE_enumExprFieldless);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1669; pathInExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallParamsContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public CallParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterCallParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitCallParams(this);
		}
	}

	[RuleVersion(0)]
	public CallParamsContext callParams() {
		CallParamsContext _localctx = new CallParamsContext(Context, State);
		EnterRule(_localctx, 206, RULE_callParams);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1671; expression(0);
			State = 1676;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,217,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1672; Match(COMMA);
					State = 1673; expression(0);
					}
					} 
				}
				State = 1678;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,217,Context);
			}
			State = 1680;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1679; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClosureExpressionContext : ParserRuleContext {
		public ITerminalNode OROR() { return GetToken(RustParser.OROR, 0); }
		public ITerminalNode[] OR() { return GetTokens(RustParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(RustParser.OR, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RARROW() { return GetToken(RustParser.RARROW, 0); }
		public TypeNoBoundsContext typeNoBounds() {
			return GetRuleContext<TypeNoBoundsContext>(0);
		}
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public ITerminalNode KW_MOVE() { return GetToken(RustParser.KW_MOVE, 0); }
		public ClosureParametersContext closureParameters() {
			return GetRuleContext<ClosureParametersContext>(0);
		}
		public ClosureExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_closureExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterClosureExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitClosureExpression(this);
		}
	}

	[RuleVersion(0)]
	public ClosureExpressionContext closureExpression() {
		ClosureExpressionContext _localctx = new ClosureExpressionContext(Context, State);
		EnterRule(_localctx, 208, RULE_closureExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1683;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_MOVE) {
				{
				State = 1682; Match(KW_MOVE);
				}
			}

			State = 1691;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OROR:
				{
				State = 1685; Match(OROR);
				}
				break;
			case OR:
				{
				State = 1686; Match(OR);
				State = 1688;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,220,Context) ) {
				case 1:
					{
					State = 1687; closureParameters();
					}
					break;
				}
				State = 1690; Match(OR);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1698;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_BREAK:
			case KW_CONTINUE:
			case KW_CRATE:
			case KW_FALSE:
			case KW_FOR:
			case KW_IF:
			case KW_LOOP:
			case KW_MATCH:
			case KW_MOVE:
			case KW_RETURN:
			case KW_SELFVALUE:
			case KW_SELFTYPE:
			case KW_SUPER:
			case KW_TRUE:
			case KW_UNSAFE:
			case KW_WHILE:
			case KW_ASYNC:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case CHAR_LITERAL:
			case STRING_LITERAL:
			case RAW_STRING_LITERAL:
			case BYTE_LITERAL:
			case BYTE_STRING_LITERAL:
			case RAW_BYTE_STRING_LITERAL:
			case INTEGER_LITERAL:
			case FLOAT_LITERAL:
			case LIFETIME_OR_LABEL:
			case MINUS:
			case STAR:
			case NOT:
			case AND:
			case OR:
			case ANDAND:
			case OROR:
			case LT:
			case DOTDOT:
			case DOTDOTEQ:
			case PATHSEP:
			case POUND:
			case LCURLYBRACE:
			case LSQUAREBRACKET:
			case LPAREN:
				{
				State = 1693; expression(0);
				}
				break;
			case RARROW:
				{
				State = 1694; Match(RARROW);
				State = 1695; typeNoBounds();
				State = 1696; blockExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClosureParametersContext : ParserRuleContext {
		public ClosureParamContext[] closureParam() {
			return GetRuleContexts<ClosureParamContext>();
		}
		public ClosureParamContext closureParam(int i) {
			return GetRuleContext<ClosureParamContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public ClosureParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_closureParameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterClosureParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitClosureParameters(this);
		}
	}

	[RuleVersion(0)]
	public ClosureParametersContext closureParameters() {
		ClosureParametersContext _localctx = new ClosureParametersContext(Context, State);
		EnterRule(_localctx, 210, RULE_closureParameters);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1700; closureParam();
			State = 1705;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,223,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1701; Match(COMMA);
					State = 1702; closureParam();
					}
					} 
				}
				State = 1707;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,223,Context);
			}
			State = 1709;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1708; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClosureParamContext : ParserRuleContext {
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ClosureParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_closureParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterClosureParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitClosureParam(this);
		}
	}

	[RuleVersion(0)]
	public ClosureParamContext closureParam() {
		ClosureParamContext _localctx = new ClosureParamContext(Context, State);
		EnterRule(_localctx, 212, RULE_closureParam);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1714;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 1711; outerAttribute();
				}
				}
				State = 1716;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1717; pattern();
			State = 1720;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLON) {
				{
				State = 1718; Match(COLON);
				State = 1719; type_();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopExpressionContext : ParserRuleContext {
		public InfiniteLoopExpressionContext infiniteLoopExpression() {
			return GetRuleContext<InfiniteLoopExpressionContext>(0);
		}
		public PredicateLoopExpressionContext predicateLoopExpression() {
			return GetRuleContext<PredicateLoopExpressionContext>(0);
		}
		public PredicatePatternLoopExpressionContext predicatePatternLoopExpression() {
			return GetRuleContext<PredicatePatternLoopExpressionContext>(0);
		}
		public IteratorLoopExpressionContext iteratorLoopExpression() {
			return GetRuleContext<IteratorLoopExpressionContext>(0);
		}
		public LoopLabelContext loopLabel() {
			return GetRuleContext<LoopLabelContext>(0);
		}
		public LoopExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLoopExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLoopExpression(this);
		}
	}

	[RuleVersion(0)]
	public LoopExpressionContext loopExpression() {
		LoopExpressionContext _localctx = new LoopExpressionContext(Context, State);
		EnterRule(_localctx, 214, RULE_loopExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1723;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIFETIME_OR_LABEL) {
				{
				State = 1722; loopLabel();
				}
			}

			State = 1729;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,228,Context) ) {
			case 1:
				{
				State = 1725; infiniteLoopExpression();
				}
				break;
			case 2:
				{
				State = 1726; predicateLoopExpression();
				}
				break;
			case 3:
				{
				State = 1727; predicatePatternLoopExpression();
				}
				break;
			case 4:
				{
				State = 1728; iteratorLoopExpression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InfiniteLoopExpressionContext : ParserRuleContext {
		public ITerminalNode KW_LOOP() { return GetToken(RustParser.KW_LOOP, 0); }
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public InfiniteLoopExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_infiniteLoopExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterInfiniteLoopExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitInfiniteLoopExpression(this);
		}
	}

	[RuleVersion(0)]
	public InfiniteLoopExpressionContext infiniteLoopExpression() {
		InfiniteLoopExpressionContext _localctx = new InfiniteLoopExpressionContext(Context, State);
		EnterRule(_localctx, 216, RULE_infiniteLoopExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1731; Match(KW_LOOP);
			State = 1732; blockExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredicateLoopExpressionContext : ParserRuleContext {
		public ITerminalNode KW_WHILE() { return GetToken(RustParser.KW_WHILE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public PredicateLoopExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predicateLoopExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPredicateLoopExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPredicateLoopExpression(this);
		}
	}

	[RuleVersion(0)]
	public PredicateLoopExpressionContext predicateLoopExpression() {
		PredicateLoopExpressionContext _localctx = new PredicateLoopExpressionContext(Context, State);
		EnterRule(_localctx, 218, RULE_predicateLoopExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1734; Match(KW_WHILE);
			State = 1735; expression(0);
			State = 1736; blockExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredicatePatternLoopExpressionContext : ParserRuleContext {
		public ITerminalNode KW_WHILE() { return GetToken(RustParser.KW_WHILE, 0); }
		public ITerminalNode KW_LET() { return GetToken(RustParser.KW_LET, 0); }
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public PredicatePatternLoopExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predicatePatternLoopExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPredicatePatternLoopExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPredicatePatternLoopExpression(this);
		}
	}

	[RuleVersion(0)]
	public PredicatePatternLoopExpressionContext predicatePatternLoopExpression() {
		PredicatePatternLoopExpressionContext _localctx = new PredicatePatternLoopExpressionContext(Context, State);
		EnterRule(_localctx, 220, RULE_predicatePatternLoopExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1738; Match(KW_WHILE);
			State = 1739; Match(KW_LET);
			State = 1740; pattern();
			State = 1741; Match(EQ);
			State = 1742; expression(0);
			State = 1743; blockExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IteratorLoopExpressionContext : ParserRuleContext {
		public ITerminalNode KW_FOR() { return GetToken(RustParser.KW_FOR, 0); }
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public ITerminalNode KW_IN() { return GetToken(RustParser.KW_IN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public IteratorLoopExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iteratorLoopExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterIteratorLoopExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitIteratorLoopExpression(this);
		}
	}

	[RuleVersion(0)]
	public IteratorLoopExpressionContext iteratorLoopExpression() {
		IteratorLoopExpressionContext _localctx = new IteratorLoopExpressionContext(Context, State);
		EnterRule(_localctx, 222, RULE_iteratorLoopExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1745; Match(KW_FOR);
			State = 1746; pattern();
			State = 1747; Match(KW_IN);
			State = 1748; expression(0);
			State = 1749; blockExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopLabelContext : ParserRuleContext {
		public ITerminalNode LIFETIME_OR_LABEL() { return GetToken(RustParser.LIFETIME_OR_LABEL, 0); }
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public LoopLabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopLabel; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLoopLabel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLoopLabel(this);
		}
	}

	[RuleVersion(0)]
	public LoopLabelContext loopLabel() {
		LoopLabelContext _localctx = new LoopLabelContext(Context, State);
		EnterRule(_localctx, 224, RULE_loopLabel);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1751; Match(LIFETIME_OR_LABEL);
			State = 1752; Match(COLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfExpressionContext : ParserRuleContext {
		public ITerminalNode KW_IF() { return GetToken(RustParser.KW_IF, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BlockExpressionContext[] blockExpression() {
			return GetRuleContexts<BlockExpressionContext>();
		}
		public BlockExpressionContext blockExpression(int i) {
			return GetRuleContext<BlockExpressionContext>(i);
		}
		public ITerminalNode KW_ELSE() { return GetToken(RustParser.KW_ELSE, 0); }
		public IfExpressionContext ifExpression() {
			return GetRuleContext<IfExpressionContext>(0);
		}
		public IfLetExpressionContext ifLetExpression() {
			return GetRuleContext<IfLetExpressionContext>(0);
		}
		public IfExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterIfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitIfExpression(this);
		}
	}

	[RuleVersion(0)]
	public IfExpressionContext ifExpression() {
		IfExpressionContext _localctx = new IfExpressionContext(Context, State);
		EnterRule(_localctx, 226, RULE_ifExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1754; Match(KW_IF);
			State = 1755; expression(0);
			State = 1756; blockExpression();
			State = 1763;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,230,Context) ) {
			case 1:
				{
				State = 1757; Match(KW_ELSE);
				State = 1761;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,229,Context) ) {
				case 1:
					{
					State = 1758; blockExpression();
					}
					break;
				case 2:
					{
					State = 1759; ifExpression();
					}
					break;
				case 3:
					{
					State = 1760; ifLetExpression();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfLetExpressionContext : ParserRuleContext {
		public ITerminalNode KW_IF() { return GetToken(RustParser.KW_IF, 0); }
		public ITerminalNode KW_LET() { return GetToken(RustParser.KW_LET, 0); }
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BlockExpressionContext[] blockExpression() {
			return GetRuleContexts<BlockExpressionContext>();
		}
		public BlockExpressionContext blockExpression(int i) {
			return GetRuleContext<BlockExpressionContext>(i);
		}
		public ITerminalNode KW_ELSE() { return GetToken(RustParser.KW_ELSE, 0); }
		public IfExpressionContext ifExpression() {
			return GetRuleContext<IfExpressionContext>(0);
		}
		public IfLetExpressionContext ifLetExpression() {
			return GetRuleContext<IfLetExpressionContext>(0);
		}
		public IfLetExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifLetExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterIfLetExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitIfLetExpression(this);
		}
	}

	[RuleVersion(0)]
	public IfLetExpressionContext ifLetExpression() {
		IfLetExpressionContext _localctx = new IfLetExpressionContext(Context, State);
		EnterRule(_localctx, 228, RULE_ifLetExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1765; Match(KW_IF);
			State = 1766; Match(KW_LET);
			State = 1767; pattern();
			State = 1768; Match(EQ);
			State = 1769; expression(0);
			State = 1770; blockExpression();
			State = 1777;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,232,Context) ) {
			case 1:
				{
				State = 1771; Match(KW_ELSE);
				State = 1775;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,231,Context) ) {
				case 1:
					{
					State = 1772; blockExpression();
					}
					break;
				case 2:
					{
					State = 1773; ifExpression();
					}
					break;
				case 3:
					{
					State = 1774; ifLetExpression();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchExpressionContext : ParserRuleContext {
		public ITerminalNode KW_MATCH() { return GetToken(RustParser.KW_MATCH, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public InnerAttributeContext[] innerAttribute() {
			return GetRuleContexts<InnerAttributeContext>();
		}
		public InnerAttributeContext innerAttribute(int i) {
			return GetRuleContext<InnerAttributeContext>(i);
		}
		public MatchArmsContext matchArms() {
			return GetRuleContext<MatchArmsContext>(0);
		}
		public MatchExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMatchExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMatchExpression(this);
		}
	}

	[RuleVersion(0)]
	public MatchExpressionContext matchExpression() {
		MatchExpressionContext _localctx = new MatchExpressionContext(Context, State);
		EnterRule(_localctx, 230, RULE_matchExpression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1779; Match(KW_MATCH);
			State = 1780; expression(0);
			State = 1781; Match(LCURLYBRACE);
			State = 1785;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,233,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1782; innerAttribute();
					}
					} 
				}
				State = 1787;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,233,Context);
			}
			State = 1789;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_MUT) | (1L << KW_REF) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (MINUS - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (LT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOTDOT - 69)) | (1L << (PATHSEP - 69)) | (1L << (POUND - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 1788; matchArms();
				}
			}

			State = 1791; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchArmsContext : ParserRuleContext {
		public MatchArmContext[] matchArm() {
			return GetRuleContexts<MatchArmContext>();
		}
		public MatchArmContext matchArm(int i) {
			return GetRuleContext<MatchArmContext>(i);
		}
		public ITerminalNode[] FATARROW() { return GetTokens(RustParser.FATARROW); }
		public ITerminalNode FATARROW(int i) {
			return GetToken(RustParser.FATARROW, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MatchArmExpressionContext[] matchArmExpression() {
			return GetRuleContexts<MatchArmExpressionContext>();
		}
		public MatchArmExpressionContext matchArmExpression(int i) {
			return GetRuleContext<MatchArmExpressionContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(RustParser.COMMA, 0); }
		public MatchArmsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchArms; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMatchArms(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMatchArms(this);
		}
	}

	[RuleVersion(0)]
	public MatchArmsContext matchArms() {
		MatchArmsContext _localctx = new MatchArmsContext(Context, State);
		EnterRule(_localctx, 232, RULE_matchArms);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1799;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,235,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1793; matchArm();
					State = 1794; Match(FATARROW);
					State = 1795; matchArmExpression();
					}
					} 
				}
				State = 1801;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,235,Context);
			}
			State = 1802; matchArm();
			State = 1803; Match(FATARROW);
			State = 1804; expression(0);
			State = 1806;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1805; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchArmExpressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(RustParser.COMMA, 0); }
		public ExpressionWithBlockContext expressionWithBlock() {
			return GetRuleContext<ExpressionWithBlockContext>(0);
		}
		public MatchArmExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchArmExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMatchArmExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMatchArmExpression(this);
		}
	}

	[RuleVersion(0)]
	public MatchArmExpressionContext matchArmExpression() {
		MatchArmExpressionContext _localctx = new MatchArmExpressionContext(Context, State);
		EnterRule(_localctx, 234, RULE_matchArmExpression);
		int _la;
		try {
			State = 1815;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,238,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1808; expression(0);
				State = 1809; Match(COMMA);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1811; expressionWithBlock();
				State = 1813;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1812; Match(COMMA);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchArmContext : ParserRuleContext {
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public MatchArmGuardContext matchArmGuard() {
			return GetRuleContext<MatchArmGuardContext>(0);
		}
		public MatchArmContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchArm; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMatchArm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMatchArm(this);
		}
	}

	[RuleVersion(0)]
	public MatchArmContext matchArm() {
		MatchArmContext _localctx = new MatchArmContext(Context, State);
		EnterRule(_localctx, 236, RULE_matchArm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1820;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 1817; outerAttribute();
				}
				}
				State = 1822;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1823; pattern();
			State = 1825;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_IF) {
				{
				State = 1824; matchArmGuard();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchArmGuardContext : ParserRuleContext {
		public ITerminalNode KW_IF() { return GetToken(RustParser.KW_IF, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MatchArmGuardContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchArmGuard; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMatchArmGuard(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMatchArmGuard(this);
		}
	}

	[RuleVersion(0)]
	public MatchArmGuardContext matchArmGuard() {
		MatchArmGuardContext _localctx = new MatchArmGuardContext(Context, State);
		EnterRule(_localctx, 238, RULE_matchArmGuard);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1827; Match(KW_IF);
			State = 1828; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternContext : ParserRuleContext {
		public PatternNoTopAltContext[] patternNoTopAlt() {
			return GetRuleContexts<PatternNoTopAltContext>();
		}
		public PatternNoTopAltContext patternNoTopAlt(int i) {
			return GetRuleContext<PatternNoTopAltContext>(i);
		}
		public ITerminalNode[] OR() { return GetTokens(RustParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(RustParser.OR, i);
		}
		public PatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPattern(this);
		}
	}

	[RuleVersion(0)]
	public PatternContext pattern() {
		PatternContext _localctx = new PatternContext(Context, State);
		EnterRule(_localctx, 240, RULE_pattern);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1831;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1830; Match(OR);
				}
			}

			State = 1833; patternNoTopAlt();
			State = 1838;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,242,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1834; Match(OR);
					State = 1835; patternNoTopAlt();
					}
					} 
				}
				State = 1840;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,242,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternNoTopAltContext : ParserRuleContext {
		public PatternWithoutRangeContext patternWithoutRange() {
			return GetRuleContext<PatternWithoutRangeContext>(0);
		}
		public RangePatternContext rangePattern() {
			return GetRuleContext<RangePatternContext>(0);
		}
		public PatternNoTopAltContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternNoTopAlt; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPatternNoTopAlt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPatternNoTopAlt(this);
		}
	}

	[RuleVersion(0)]
	public PatternNoTopAltContext patternNoTopAlt() {
		PatternNoTopAltContext _localctx = new PatternNoTopAltContext(Context, State);
		EnterRule(_localctx, 242, RULE_patternNoTopAlt);
		try {
			State = 1843;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,243,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1841; patternWithoutRange();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1842; rangePattern();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternWithoutRangeContext : ParserRuleContext {
		public LiteralPatternContext literalPattern() {
			return GetRuleContext<LiteralPatternContext>(0);
		}
		public IdentifierPatternContext identifierPattern() {
			return GetRuleContext<IdentifierPatternContext>(0);
		}
		public WildcardPatternContext wildcardPattern() {
			return GetRuleContext<WildcardPatternContext>(0);
		}
		public RestPatternContext restPattern() {
			return GetRuleContext<RestPatternContext>(0);
		}
		public ReferencePatternContext referencePattern() {
			return GetRuleContext<ReferencePatternContext>(0);
		}
		public StructPatternContext structPattern() {
			return GetRuleContext<StructPatternContext>(0);
		}
		public TupleStructPatternContext tupleStructPattern() {
			return GetRuleContext<TupleStructPatternContext>(0);
		}
		public TuplePatternContext tuplePattern() {
			return GetRuleContext<TuplePatternContext>(0);
		}
		public GroupedPatternContext groupedPattern() {
			return GetRuleContext<GroupedPatternContext>(0);
		}
		public SlicePatternContext slicePattern() {
			return GetRuleContext<SlicePatternContext>(0);
		}
		public PathPatternContext pathPattern() {
			return GetRuleContext<PathPatternContext>(0);
		}
		public MacroInvocationContext macroInvocation() {
			return GetRuleContext<MacroInvocationContext>(0);
		}
		public PatternWithoutRangeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternWithoutRange; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPatternWithoutRange(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPatternWithoutRange(this);
		}
	}

	[RuleVersion(0)]
	public PatternWithoutRangeContext patternWithoutRange() {
		PatternWithoutRangeContext _localctx = new PatternWithoutRangeContext(Context, State);
		EnterRule(_localctx, 244, RULE_patternWithoutRange);
		try {
			State = 1857;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,244,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1845; literalPattern();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1846; identifierPattern();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1847; wildcardPattern();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1848; restPattern();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1849; referencePattern();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1850; structPattern();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1851; tupleStructPattern();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1852; tuplePattern();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1853; groupedPattern();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1854; slicePattern();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1855; pathPattern();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1856; macroInvocation();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralPatternContext : ParserRuleContext {
		public ITerminalNode KW_TRUE() { return GetToken(RustParser.KW_TRUE, 0); }
		public ITerminalNode KW_FALSE() { return GetToken(RustParser.KW_FALSE, 0); }
		public ITerminalNode CHAR_LITERAL() { return GetToken(RustParser.CHAR_LITERAL, 0); }
		public ITerminalNode BYTE_LITERAL() { return GetToken(RustParser.BYTE_LITERAL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(RustParser.STRING_LITERAL, 0); }
		public ITerminalNode RAW_STRING_LITERAL() { return GetToken(RustParser.RAW_STRING_LITERAL, 0); }
		public ITerminalNode BYTE_STRING_LITERAL() { return GetToken(RustParser.BYTE_STRING_LITERAL, 0); }
		public ITerminalNode RAW_BYTE_STRING_LITERAL() { return GetToken(RustParser.RAW_BYTE_STRING_LITERAL, 0); }
		public ITerminalNode INTEGER_LITERAL() { return GetToken(RustParser.INTEGER_LITERAL, 0); }
		public ITerminalNode MINUS() { return GetToken(RustParser.MINUS, 0); }
		public ITerminalNode FLOAT_LITERAL() { return GetToken(RustParser.FLOAT_LITERAL, 0); }
		public LiteralPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLiteralPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLiteralPattern(this);
		}
	}

	[RuleVersion(0)]
	public LiteralPatternContext literalPattern() {
		LiteralPatternContext _localctx = new LiteralPatternContext(Context, State);
		EnterRule(_localctx, 246, RULE_literalPattern);
		int _la;
		try {
			State = 1875;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,247,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1859; Match(KW_TRUE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1860; Match(KW_FALSE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1861; Match(CHAR_LITERAL);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1862; Match(BYTE_LITERAL);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1863; Match(STRING_LITERAL);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1864; Match(RAW_STRING_LITERAL);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1865; Match(BYTE_STRING_LITERAL);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1866; Match(RAW_BYTE_STRING_LITERAL);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1868;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS) {
					{
					State = 1867; Match(MINUS);
					}
				}

				State = 1870; Match(INTEGER_LITERAL);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1872;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS) {
					{
					State = 1871; Match(MINUS);
					}
				}

				State = 1874; Match(FLOAT_LITERAL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierPatternContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode KW_REF() { return GetToken(RustParser.KW_REF, 0); }
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public ITerminalNode AT() { return GetToken(RustParser.AT, 0); }
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public IdentifierPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterIdentifierPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitIdentifierPattern(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierPatternContext identifierPattern() {
		IdentifierPatternContext _localctx = new IdentifierPatternContext(Context, State);
		EnterRule(_localctx, 248, RULE_identifierPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1878;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_REF) {
				{
				State = 1877; Match(KW_REF);
				}
			}

			State = 1881;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_MUT) {
				{
				State = 1880; Match(KW_MUT);
				}
			}

			State = 1883; identifier();
			State = 1886;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT) {
				{
				State = 1884; Match(AT);
				State = 1885; pattern();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WildcardPatternContext : ParserRuleContext {
		public ITerminalNode UNDERSCORE() { return GetToken(RustParser.UNDERSCORE, 0); }
		public WildcardPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_wildcardPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterWildcardPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitWildcardPattern(this);
		}
	}

	[RuleVersion(0)]
	public WildcardPatternContext wildcardPattern() {
		WildcardPatternContext _localctx = new WildcardPatternContext(Context, State);
		EnterRule(_localctx, 250, RULE_wildcardPattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1888; Match(UNDERSCORE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RestPatternContext : ParserRuleContext {
		public ITerminalNode DOTDOT() { return GetToken(RustParser.DOTDOT, 0); }
		public RestPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_restPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterRestPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitRestPattern(this);
		}
	}

	[RuleVersion(0)]
	public RestPatternContext restPattern() {
		RestPatternContext _localctx = new RestPatternContext(Context, State);
		EnterRule(_localctx, 252, RULE_restPattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1890; Match(DOTDOT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangePatternContext : ParserRuleContext {
		public RangePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rangePattern; } }
	 
		public RangePatternContext() { }
		public virtual void CopyFrom(RangePatternContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class InclusiveRangePatternContext : RangePatternContext {
		public RangePatternBoundContext[] rangePatternBound() {
			return GetRuleContexts<RangePatternBoundContext>();
		}
		public RangePatternBoundContext rangePatternBound(int i) {
			return GetRuleContext<RangePatternBoundContext>(i);
		}
		public ITerminalNode DOTDOTEQ() { return GetToken(RustParser.DOTDOTEQ, 0); }
		public InclusiveRangePatternContext(RangePatternContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterInclusiveRangePattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitInclusiveRangePattern(this);
		}
	}
	public partial class ObsoleteRangePatternContext : RangePatternContext {
		public RangePatternBoundContext[] rangePatternBound() {
			return GetRuleContexts<RangePatternBoundContext>();
		}
		public RangePatternBoundContext rangePatternBound(int i) {
			return GetRuleContext<RangePatternBoundContext>(i);
		}
		public ITerminalNode DOTDOTDOT() { return GetToken(RustParser.DOTDOTDOT, 0); }
		public ObsoleteRangePatternContext(RangePatternContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterObsoleteRangePattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitObsoleteRangePattern(this);
		}
	}
	public partial class HalfOpenRangePatternContext : RangePatternContext {
		public RangePatternBoundContext rangePatternBound() {
			return GetRuleContext<RangePatternBoundContext>(0);
		}
		public ITerminalNode DOTDOT() { return GetToken(RustParser.DOTDOT, 0); }
		public HalfOpenRangePatternContext(RangePatternContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterHalfOpenRangePattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitHalfOpenRangePattern(this);
		}
	}

	[RuleVersion(0)]
	public RangePatternContext rangePattern() {
		RangePatternContext _localctx = new RangePatternContext(Context, State);
		EnterRule(_localctx, 254, RULE_rangePattern);
		try {
			State = 1903;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,251,Context) ) {
			case 1:
				_localctx = new InclusiveRangePatternContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1892; rangePatternBound();
				State = 1893; Match(DOTDOTEQ);
				State = 1894; rangePatternBound();
				}
				break;
			case 2:
				_localctx = new HalfOpenRangePatternContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1896; rangePatternBound();
				State = 1897; Match(DOTDOT);
				}
				break;
			case 3:
				_localctx = new ObsoleteRangePatternContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1899; rangePatternBound();
				State = 1900; Match(DOTDOTDOT);
				State = 1901; rangePatternBound();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangePatternBoundContext : ParserRuleContext {
		public ITerminalNode CHAR_LITERAL() { return GetToken(RustParser.CHAR_LITERAL, 0); }
		public ITerminalNode BYTE_LITERAL() { return GetToken(RustParser.BYTE_LITERAL, 0); }
		public ITerminalNode INTEGER_LITERAL() { return GetToken(RustParser.INTEGER_LITERAL, 0); }
		public ITerminalNode MINUS() { return GetToken(RustParser.MINUS, 0); }
		public ITerminalNode FLOAT_LITERAL() { return GetToken(RustParser.FLOAT_LITERAL, 0); }
		public PathPatternContext pathPattern() {
			return GetRuleContext<PathPatternContext>(0);
		}
		public RangePatternBoundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rangePatternBound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterRangePatternBound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitRangePatternBound(this);
		}
	}

	[RuleVersion(0)]
	public RangePatternBoundContext rangePatternBound() {
		RangePatternBoundContext _localctx = new RangePatternBoundContext(Context, State);
		EnterRule(_localctx, 256, RULE_rangePatternBound);
		int _la;
		try {
			State = 1916;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,254,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1905; Match(CHAR_LITERAL);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1906; Match(BYTE_LITERAL);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1908;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS) {
					{
					State = 1907; Match(MINUS);
					}
				}

				State = 1910; Match(INTEGER_LITERAL);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1912;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS) {
					{
					State = 1911; Match(MINUS);
					}
				}

				State = 1914; Match(FLOAT_LITERAL);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1915; pathPattern();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferencePatternContext : ParserRuleContext {
		public PatternWithoutRangeContext patternWithoutRange() {
			return GetRuleContext<PatternWithoutRangeContext>(0);
		}
		public ITerminalNode AND() { return GetToken(RustParser.AND, 0); }
		public ITerminalNode ANDAND() { return GetToken(RustParser.ANDAND, 0); }
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public ReferencePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencePattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterReferencePattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitReferencePattern(this);
		}
	}

	[RuleVersion(0)]
	public ReferencePatternContext referencePattern() {
		ReferencePatternContext _localctx = new ReferencePatternContext(Context, State);
		EnterRule(_localctx, 258, RULE_referencePattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1918;
			_la = TokenStream.LA(1);
			if ( !(_la==AND || _la==ANDAND) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1920;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,255,Context) ) {
			case 1:
				{
				State = 1919; Match(KW_MUT);
				}
				break;
			}
			State = 1922; patternWithoutRange();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructPatternContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public ITerminalNode LCURLYBRACE() { return GetToken(RustParser.LCURLYBRACE, 0); }
		public ITerminalNode RCURLYBRACE() { return GetToken(RustParser.RCURLYBRACE, 0); }
		public StructPatternElementsContext structPatternElements() {
			return GetRuleContext<StructPatternElementsContext>(0);
		}
		public StructPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructPattern(this);
		}
	}

	[RuleVersion(0)]
	public StructPatternContext structPattern() {
		StructPatternContext _localctx = new StructPatternContext(Context, State);
		EnterRule(_localctx, 260, RULE_structPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1924; pathInExpression();
			State = 1925; Match(LCURLYBRACE);
			State = 1927;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_MUT) | (1L << KW_REF) | (1L << KW_MACRORULES) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 75)) & ~0x3f) == 0 && ((1L << (_la - 75)) & ((1L << (INTEGER_LITERAL - 75)) | (1L << (DOTDOT - 75)) | (1L << (POUND - 75)))) != 0)) {
				{
				State = 1926; structPatternElements();
				}
			}

			State = 1929; Match(RCURLYBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructPatternElementsContext : ParserRuleContext {
		public StructPatternFieldsContext structPatternFields() {
			return GetRuleContext<StructPatternFieldsContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(RustParser.COMMA, 0); }
		public StructPatternEtCeteraContext structPatternEtCetera() {
			return GetRuleContext<StructPatternEtCeteraContext>(0);
		}
		public StructPatternElementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structPatternElements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructPatternElements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructPatternElements(this);
		}
	}

	[RuleVersion(0)]
	public StructPatternElementsContext structPatternElements() {
		StructPatternElementsContext _localctx = new StructPatternElementsContext(Context, State);
		EnterRule(_localctx, 262, RULE_structPatternElements);
		int _la;
		try {
			State = 1939;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,259,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1931; structPatternFields();
				State = 1936;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1932; Match(COMMA);
					State = 1934;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DOTDOT || _la==POUND) {
						{
						State = 1933; structPatternEtCetera();
						}
					}

					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1938; structPatternEtCetera();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructPatternFieldsContext : ParserRuleContext {
		public StructPatternFieldContext[] structPatternField() {
			return GetRuleContexts<StructPatternFieldContext>();
		}
		public StructPatternFieldContext structPatternField(int i) {
			return GetRuleContext<StructPatternFieldContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public StructPatternFieldsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structPatternFields; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructPatternFields(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructPatternFields(this);
		}
	}

	[RuleVersion(0)]
	public StructPatternFieldsContext structPatternFields() {
		StructPatternFieldsContext _localctx = new StructPatternFieldsContext(Context, State);
		EnterRule(_localctx, 264, RULE_structPatternFields);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1941; structPatternField();
			State = 1946;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,260,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1942; Match(COMMA);
					State = 1943; structPatternField();
					}
					} 
				}
				State = 1948;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,260,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructPatternFieldContext : ParserRuleContext {
		public TupleIndexContext tupleIndex() {
			return GetRuleContext<TupleIndexContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public ITerminalNode KW_REF() { return GetToken(RustParser.KW_REF, 0); }
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public StructPatternFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structPatternField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructPatternField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructPatternField(this);
		}
	}

	[RuleVersion(0)]
	public StructPatternFieldContext structPatternField() {
		StructPatternFieldContext _localctx = new StructPatternFieldContext(Context, State);
		EnterRule(_localctx, 266, RULE_structPatternField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1952;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 1949; outerAttribute();
				}
				}
				State = 1954;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1970;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,264,Context) ) {
			case 1:
				{
				State = 1955; tupleIndex();
				State = 1956; Match(COLON);
				State = 1957; pattern();
				}
				break;
			case 2:
				{
				State = 1959; identifier();
				State = 1960; Match(COLON);
				State = 1961; pattern();
				}
				break;
			case 3:
				{
				State = 1964;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KW_REF) {
					{
					State = 1963; Match(KW_REF);
					}
				}

				State = 1967;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KW_MUT) {
					{
					State = 1966; Match(KW_MUT);
					}
				}

				State = 1969; identifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructPatternEtCeteraContext : ParserRuleContext {
		public ITerminalNode DOTDOT() { return GetToken(RustParser.DOTDOT, 0); }
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public StructPatternEtCeteraContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structPatternEtCetera; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterStructPatternEtCetera(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitStructPatternEtCetera(this);
		}
	}

	[RuleVersion(0)]
	public StructPatternEtCeteraContext structPatternEtCetera() {
		StructPatternEtCeteraContext _localctx = new StructPatternEtCeteraContext(Context, State);
		EnterRule(_localctx, 268, RULE_structPatternEtCetera);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1975;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 1972; outerAttribute();
				}
				}
				State = 1977;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1978; Match(DOTDOT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleStructPatternContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public TupleStructItemsContext tupleStructItems() {
			return GetRuleContext<TupleStructItemsContext>(0);
		}
		public TupleStructPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleStructPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleStructPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleStructPattern(this);
		}
	}

	[RuleVersion(0)]
	public TupleStructPatternContext tupleStructPattern() {
		TupleStructPatternContext _localctx = new TupleStructPatternContext(Context, State);
		EnterRule(_localctx, 270, RULE_tupleStructPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1980; pathInExpression();
			State = 1981; Match(LPAREN);
			State = 1983;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_MUT) | (1L << KW_REF) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (MINUS - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (LT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOTDOT - 69)) | (1L << (PATHSEP - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 1982; tupleStructItems();
				}
			}

			State = 1985; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleStructItemsContext : ParserRuleContext {
		public PatternContext[] pattern() {
			return GetRuleContexts<PatternContext>();
		}
		public PatternContext pattern(int i) {
			return GetRuleContext<PatternContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public TupleStructItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleStructItems; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleStructItems(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleStructItems(this);
		}
	}

	[RuleVersion(0)]
	public TupleStructItemsContext tupleStructItems() {
		TupleStructItemsContext _localctx = new TupleStructItemsContext(Context, State);
		EnterRule(_localctx, 272, RULE_tupleStructItems);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1987; pattern();
			State = 1992;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,267,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1988; Match(COMMA);
					State = 1989; pattern();
					}
					} 
				}
				State = 1994;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,267,Context);
			}
			State = 1996;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1995; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TuplePatternContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public TuplePatternItemsContext tuplePatternItems() {
			return GetRuleContext<TuplePatternItemsContext>(0);
		}
		public TuplePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuplePattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTuplePattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTuplePattern(this);
		}
	}

	[RuleVersion(0)]
	public TuplePatternContext tuplePattern() {
		TuplePatternContext _localctx = new TuplePatternContext(Context, State);
		EnterRule(_localctx, 274, RULE_tuplePattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1998; Match(LPAREN);
			State = 2000;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_MUT) | (1L << KW_REF) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (MINUS - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (LT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOTDOT - 69)) | (1L << (PATHSEP - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 1999; tuplePatternItems();
				}
			}

			State = 2002; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TuplePatternItemsContext : ParserRuleContext {
		public PatternContext[] pattern() {
			return GetRuleContexts<PatternContext>();
		}
		public PatternContext pattern(int i) {
			return GetRuleContext<PatternContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public RestPatternContext restPattern() {
			return GetRuleContext<RestPatternContext>(0);
		}
		public TuplePatternItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuplePatternItems; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTuplePatternItems(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTuplePatternItems(this);
		}
	}

	[RuleVersion(0)]
	public TuplePatternItemsContext tuplePatternItems() {
		TuplePatternItemsContext _localctx = new TuplePatternItemsContext(Context, State);
		EnterRule(_localctx, 276, RULE_tuplePatternItems);
		int _la;
		try {
			int _alt;
			State = 2018;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,272,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2004; pattern();
				State = 2005; Match(COMMA);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2007; restPattern();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2008; pattern();
				State = 2011;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2009; Match(COMMA);
						State = 2010; pattern();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2013;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,270,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 2016;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2015; Match(COMMA);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupedPatternContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public GroupedPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupedPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGroupedPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGroupedPattern(this);
		}
	}

	[RuleVersion(0)]
	public GroupedPatternContext groupedPattern() {
		GroupedPatternContext _localctx = new GroupedPatternContext(Context, State);
		EnterRule(_localctx, 278, RULE_groupedPattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2020; Match(LPAREN);
			State = 2021; pattern();
			State = 2022; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SlicePatternContext : ParserRuleContext {
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public SlicePatternItemsContext slicePatternItems() {
			return GetRuleContext<SlicePatternItemsContext>(0);
		}
		public SlicePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_slicePattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterSlicePattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitSlicePattern(this);
		}
	}

	[RuleVersion(0)]
	public SlicePatternContext slicePattern() {
		SlicePatternContext _localctx = new SlicePatternContext(Context, State);
		EnterRule(_localctx, 280, RULE_slicePattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2024; Match(LSQUAREBRACKET);
			State = 2026;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_FALSE) | (1L << KW_MUT) | (1L << KW_REF) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_TRUE) | (1L << KW_MACRORULES) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & ((1L << (CHAR_LITERAL - 69)) | (1L << (STRING_LITERAL - 69)) | (1L << (RAW_STRING_LITERAL - 69)) | (1L << (BYTE_LITERAL - 69)) | (1L << (BYTE_STRING_LITERAL - 69)) | (1L << (RAW_BYTE_STRING_LITERAL - 69)) | (1L << (INTEGER_LITERAL - 69)) | (1L << (FLOAT_LITERAL - 69)) | (1L << (MINUS - 69)) | (1L << (AND - 69)) | (1L << (OR - 69)) | (1L << (ANDAND - 69)) | (1L << (LT - 69)) | (1L << (UNDERSCORE - 69)) | (1L << (DOTDOT - 69)) | (1L << (PATHSEP - 69)) | (1L << (LSQUAREBRACKET - 69)) | (1L << (LPAREN - 69)))) != 0)) {
				{
				State = 2025; slicePatternItems();
				}
			}

			State = 2028; Match(RSQUAREBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SlicePatternItemsContext : ParserRuleContext {
		public PatternContext[] pattern() {
			return GetRuleContexts<PatternContext>();
		}
		public PatternContext pattern(int i) {
			return GetRuleContext<PatternContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public SlicePatternItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_slicePatternItems; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterSlicePatternItems(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitSlicePatternItems(this);
		}
	}

	[RuleVersion(0)]
	public SlicePatternItemsContext slicePatternItems() {
		SlicePatternItemsContext _localctx = new SlicePatternItemsContext(Context, State);
		EnterRule(_localctx, 282, RULE_slicePatternItems);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2030; pattern();
			State = 2035;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,274,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2031; Match(COMMA);
					State = 2032; pattern();
					}
					} 
				}
				State = 2037;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,274,Context);
			}
			State = 2039;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 2038; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathPatternContext : ParserRuleContext {
		public PathInExpressionContext pathInExpression() {
			return GetRuleContext<PathInExpressionContext>(0);
		}
		public QualifiedPathInExpressionContext qualifiedPathInExpression() {
			return GetRuleContext<QualifiedPathInExpressionContext>(0);
		}
		public PathPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPathPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPathPattern(this);
		}
	}

	[RuleVersion(0)]
	public PathPatternContext pathPattern() {
		PathPatternContext _localctx = new PathPatternContext(Context, State);
		EnterRule(_localctx, 284, RULE_pathPattern);
		try {
			State = 2043;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_CRATE:
			case KW_SELFVALUE:
			case KW_SELFTYPE:
			case KW_SUPER:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case PATHSEP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2041; pathInExpression();
				}
				break;
			case LT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2042; qualifiedPathInExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_Context : ParserRuleContext {
		public TypeNoBoundsContext typeNoBounds() {
			return GetRuleContext<TypeNoBoundsContext>(0);
		}
		public ImplTraitTypeContext implTraitType() {
			return GetRuleContext<ImplTraitTypeContext>(0);
		}
		public TraitObjectTypeContext traitObjectType() {
			return GetRuleContext<TraitObjectTypeContext>(0);
		}
		public Type_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterType_(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitType_(this);
		}
	}

	[RuleVersion(0)]
	public Type_Context type_() {
		Type_Context _localctx = new Type_Context(Context, State);
		EnterRule(_localctx, 286, RULE_type_);
		try {
			State = 2048;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,277,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2045; typeNoBounds();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2046; implTraitType();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2047; traitObjectType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNoBoundsContext : ParserRuleContext {
		public ParenthesizedTypeContext parenthesizedType() {
			return GetRuleContext<ParenthesizedTypeContext>(0);
		}
		public ImplTraitTypeOneBoundContext implTraitTypeOneBound() {
			return GetRuleContext<ImplTraitTypeOneBoundContext>(0);
		}
		public TraitObjectTypeOneBoundContext traitObjectTypeOneBound() {
			return GetRuleContext<TraitObjectTypeOneBoundContext>(0);
		}
		public TypePathContext typePath() {
			return GetRuleContext<TypePathContext>(0);
		}
		public TupleTypeContext tupleType() {
			return GetRuleContext<TupleTypeContext>(0);
		}
		public NeverTypeContext neverType() {
			return GetRuleContext<NeverTypeContext>(0);
		}
		public RawPointerTypeContext rawPointerType() {
			return GetRuleContext<RawPointerTypeContext>(0);
		}
		public ReferenceTypeContext referenceType() {
			return GetRuleContext<ReferenceTypeContext>(0);
		}
		public ArrayTypeContext arrayType() {
			return GetRuleContext<ArrayTypeContext>(0);
		}
		public SliceTypeContext sliceType() {
			return GetRuleContext<SliceTypeContext>(0);
		}
		public InferredTypeContext inferredType() {
			return GetRuleContext<InferredTypeContext>(0);
		}
		public QualifiedPathInTypeContext qualifiedPathInType() {
			return GetRuleContext<QualifiedPathInTypeContext>(0);
		}
		public BareFunctionTypeContext bareFunctionType() {
			return GetRuleContext<BareFunctionTypeContext>(0);
		}
		public MacroInvocationContext macroInvocation() {
			return GetRuleContext<MacroInvocationContext>(0);
		}
		public TypeNoBoundsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeNoBounds; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypeNoBounds(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypeNoBounds(this);
		}
	}

	[RuleVersion(0)]
	public TypeNoBoundsContext typeNoBounds() {
		TypeNoBoundsContext _localctx = new TypeNoBoundsContext(Context, State);
		EnterRule(_localctx, 288, RULE_typeNoBounds);
		try {
			State = 2064;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,278,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2050; parenthesizedType();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2051; implTraitTypeOneBound();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2052; traitObjectTypeOneBound();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2053; typePath();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2054; tupleType();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2055; neverType();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2056; rawPointerType();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2057; referenceType();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2058; arrayType();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2059; sliceType();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2060; inferredType();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2061; qualifiedPathInType();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2062; bareFunctionType();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2063; macroInvocation();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedTypeContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public ParenthesizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedType(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedTypeContext parenthesizedType() {
		ParenthesizedTypeContext _localctx = new ParenthesizedTypeContext(Context, State);
		EnterRule(_localctx, 290, RULE_parenthesizedType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2066; Match(LPAREN);
			State = 2067; type_();
			State = 2068; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NeverTypeContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(RustParser.NOT, 0); }
		public NeverTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_neverType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterNeverType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitNeverType(this);
		}
	}

	[RuleVersion(0)]
	public NeverTypeContext neverType() {
		NeverTypeContext _localctx = new NeverTypeContext(Context, State);
		EnterRule(_localctx, 292, RULE_neverType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2070; Match(NOT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleTypeContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public Type_Context[] type_() {
			return GetRuleContexts<Type_Context>();
		}
		public Type_Context type_(int i) {
			return GetRuleContext<Type_Context>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public TupleTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTupleType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTupleType(this);
		}
	}

	[RuleVersion(0)]
	public TupleTypeContext tupleType() {
		TupleTypeContext _localctx = new TupleTypeContext(Context, State);
		EnterRule(_localctx, 294, RULE_tupleType);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2072; Match(LPAREN);
			State = 2083;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IMPL) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_UNSAFE) | (1L << KW_DYN) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (STAR - 81)) | (1L << (NOT - 81)) | (1L << (AND - 81)) | (1L << (LT - 81)) | (1L << (UNDERSCORE - 81)) | (1L << (PATHSEP - 81)) | (1L << (QUESTION - 81)) | (1L << (LSQUAREBRACKET - 81)) | (1L << (LPAREN - 81)))) != 0)) {
				{
				State = 2076;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2073; type_();
						State = 2074; Match(COMMA);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2078;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,279,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 2081;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IMPL) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_UNSAFE) | (1L << KW_DYN) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (STAR - 81)) | (1L << (NOT - 81)) | (1L << (AND - 81)) | (1L << (LT - 81)) | (1L << (UNDERSCORE - 81)) | (1L << (PATHSEP - 81)) | (1L << (QUESTION - 81)) | (1L << (LSQUAREBRACKET - 81)) | (1L << (LPAREN - 81)))) != 0)) {
					{
					State = 2080; type_();
					}
				}

				}
			}

			State = 2085; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayTypeContext : ParserRuleContext {
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public ArrayTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterArrayType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitArrayType(this);
		}
	}

	[RuleVersion(0)]
	public ArrayTypeContext arrayType() {
		ArrayTypeContext _localctx = new ArrayTypeContext(Context, State);
		EnterRule(_localctx, 296, RULE_arrayType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2087; Match(LSQUAREBRACKET);
			State = 2088; type_();
			State = 2089; Match(SEMI);
			State = 2090; expression(0);
			State = 2091; Match(RSQUAREBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SliceTypeContext : ParserRuleContext {
		public ITerminalNode LSQUAREBRACKET() { return GetToken(RustParser.LSQUAREBRACKET, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode RSQUAREBRACKET() { return GetToken(RustParser.RSQUAREBRACKET, 0); }
		public SliceTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sliceType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterSliceType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitSliceType(this);
		}
	}

	[RuleVersion(0)]
	public SliceTypeContext sliceType() {
		SliceTypeContext _localctx = new SliceTypeContext(Context, State);
		EnterRule(_localctx, 298, RULE_sliceType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2093; Match(LSQUAREBRACKET);
			State = 2094; type_();
			State = 2095; Match(RSQUAREBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferenceTypeContext : ParserRuleContext {
		public ITerminalNode AND() { return GetToken(RustParser.AND, 0); }
		public TypeNoBoundsContext typeNoBounds() {
			return GetRuleContext<TypeNoBoundsContext>(0);
		}
		public LifetimeContext lifetime() {
			return GetRuleContext<LifetimeContext>(0);
		}
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public ReferenceTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referenceType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterReferenceType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitReferenceType(this);
		}
	}

	[RuleVersion(0)]
	public ReferenceTypeContext referenceType() {
		ReferenceTypeContext _localctx = new ReferenceTypeContext(Context, State);
		EnterRule(_localctx, 300, RULE_referenceType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2097; Match(AND);
			State = 2099;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 53)) & ~0x3f) == 0 && ((1L << (_la - 53)) & ((1L << (KW_STATICLIFETIME - 53)) | (1L << (KW_UNDERLINELIFETIME - 53)) | (1L << (LIFETIME_OR_LABEL - 53)))) != 0)) {
				{
				State = 2098; lifetime();
				}
			}

			State = 2102;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_MUT) {
				{
				State = 2101; Match(KW_MUT);
				}
			}

			State = 2104; typeNoBounds();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RawPointerTypeContext : ParserRuleContext {
		public ITerminalNode STAR() { return GetToken(RustParser.STAR, 0); }
		public TypeNoBoundsContext typeNoBounds() {
			return GetRuleContext<TypeNoBoundsContext>(0);
		}
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public ITerminalNode KW_CONST() { return GetToken(RustParser.KW_CONST, 0); }
		public RawPointerTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rawPointerType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterRawPointerType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitRawPointerType(this);
		}
	}

	[RuleVersion(0)]
	public RawPointerTypeContext rawPointerType() {
		RawPointerTypeContext _localctx = new RawPointerTypeContext(Context, State);
		EnterRule(_localctx, 302, RULE_rawPointerType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2106; Match(STAR);
			State = 2107;
			_la = TokenStream.LA(1);
			if ( !(_la==KW_CONST || _la==KW_MUT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2108; typeNoBounds();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BareFunctionTypeContext : ParserRuleContext {
		public FunctionTypeQualifiersContext functionTypeQualifiers() {
			return GetRuleContext<FunctionTypeQualifiersContext>(0);
		}
		public ITerminalNode KW_FN() { return GetToken(RustParser.KW_FN, 0); }
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public ForLifetimesContext forLifetimes() {
			return GetRuleContext<ForLifetimesContext>(0);
		}
		public FunctionParametersMaybeNamedVariadicContext functionParametersMaybeNamedVariadic() {
			return GetRuleContext<FunctionParametersMaybeNamedVariadicContext>(0);
		}
		public BareFunctionReturnTypeContext bareFunctionReturnType() {
			return GetRuleContext<BareFunctionReturnTypeContext>(0);
		}
		public BareFunctionTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bareFunctionType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterBareFunctionType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitBareFunctionType(this);
		}
	}

	[RuleVersion(0)]
	public BareFunctionTypeContext bareFunctionType() {
		BareFunctionTypeContext _localctx = new BareFunctionTypeContext(Context, State);
		EnterRule(_localctx, 304, RULE_bareFunctionType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2111;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_FOR) {
				{
				State = 2110; forLifetimes();
				}
			}

			State = 2113; functionTypeQualifiers();
			State = 2114; Match(KW_FN);
			State = 2115; Match(LPAREN);
			State = 2117;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IMPL) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_UNSAFE) | (1L << KW_DYN) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (STAR - 81)) | (1L << (NOT - 81)) | (1L << (AND - 81)) | (1L << (LT - 81)) | (1L << (UNDERSCORE - 81)) | (1L << (PATHSEP - 81)) | (1L << (POUND - 81)) | (1L << (QUESTION - 81)) | (1L << (LSQUAREBRACKET - 81)) | (1L << (LPAREN - 81)))) != 0)) {
				{
				State = 2116; functionParametersMaybeNamedVariadic();
				}
			}

			State = 2119; Match(RPAREN);
			State = 2121;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,286,Context) ) {
			case 1:
				{
				State = 2120; bareFunctionReturnType();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionTypeQualifiersContext : ParserRuleContext {
		public ITerminalNode KW_UNSAFE() { return GetToken(RustParser.KW_UNSAFE, 0); }
		public ITerminalNode KW_EXTERN() { return GetToken(RustParser.KW_EXTERN, 0); }
		public AbiContext abi() {
			return GetRuleContext<AbiContext>(0);
		}
		public FunctionTypeQualifiersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionTypeQualifiers; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFunctionTypeQualifiers(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFunctionTypeQualifiers(this);
		}
	}

	[RuleVersion(0)]
	public FunctionTypeQualifiersContext functionTypeQualifiers() {
		FunctionTypeQualifiersContext _localctx = new FunctionTypeQualifiersContext(Context, State);
		EnterRule(_localctx, 306, RULE_functionTypeQualifiers);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2124;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_UNSAFE) {
				{
				State = 2123; Match(KW_UNSAFE);
				}
			}

			State = 2130;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_EXTERN) {
				{
				State = 2126; Match(KW_EXTERN);
				State = 2128;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STRING_LITERAL || _la==RAW_STRING_LITERAL) {
					{
					State = 2127; abi();
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BareFunctionReturnTypeContext : ParserRuleContext {
		public ITerminalNode RARROW() { return GetToken(RustParser.RARROW, 0); }
		public TypeNoBoundsContext typeNoBounds() {
			return GetRuleContext<TypeNoBoundsContext>(0);
		}
		public BareFunctionReturnTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bareFunctionReturnType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterBareFunctionReturnType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitBareFunctionReturnType(this);
		}
	}

	[RuleVersion(0)]
	public BareFunctionReturnTypeContext bareFunctionReturnType() {
		BareFunctionReturnTypeContext _localctx = new BareFunctionReturnTypeContext(Context, State);
		EnterRule(_localctx, 308, RULE_bareFunctionReturnType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2132; Match(RARROW);
			State = 2133; typeNoBounds();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParametersMaybeNamedVariadicContext : ParserRuleContext {
		public MaybeNamedFunctionParametersContext maybeNamedFunctionParameters() {
			return GetRuleContext<MaybeNamedFunctionParametersContext>(0);
		}
		public MaybeNamedFunctionParametersVariadicContext maybeNamedFunctionParametersVariadic() {
			return GetRuleContext<MaybeNamedFunctionParametersVariadicContext>(0);
		}
		public FunctionParametersMaybeNamedVariadicContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParametersMaybeNamedVariadic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterFunctionParametersMaybeNamedVariadic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitFunctionParametersMaybeNamedVariadic(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParametersMaybeNamedVariadicContext functionParametersMaybeNamedVariadic() {
		FunctionParametersMaybeNamedVariadicContext _localctx = new FunctionParametersMaybeNamedVariadicContext(Context, State);
		EnterRule(_localctx, 310, RULE_functionParametersMaybeNamedVariadic);
		try {
			State = 2137;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,290,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2135; maybeNamedFunctionParameters();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2136; maybeNamedFunctionParametersVariadic();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaybeNamedFunctionParametersContext : ParserRuleContext {
		public MaybeNamedParamContext[] maybeNamedParam() {
			return GetRuleContexts<MaybeNamedParamContext>();
		}
		public MaybeNamedParamContext maybeNamedParam(int i) {
			return GetRuleContext<MaybeNamedParamContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public MaybeNamedFunctionParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maybeNamedFunctionParameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMaybeNamedFunctionParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMaybeNamedFunctionParameters(this);
		}
	}

	[RuleVersion(0)]
	public MaybeNamedFunctionParametersContext maybeNamedFunctionParameters() {
		MaybeNamedFunctionParametersContext _localctx = new MaybeNamedFunctionParametersContext(Context, State);
		EnterRule(_localctx, 312, RULE_maybeNamedFunctionParameters);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2139; maybeNamedParam();
			State = 2144;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,291,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2140; Match(COMMA);
					State = 2141; maybeNamedParam();
					}
					} 
				}
				State = 2146;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,291,Context);
			}
			State = 2148;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 2147; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaybeNamedParamContext : ParserRuleContext {
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode UNDERSCORE() { return GetToken(RustParser.UNDERSCORE, 0); }
		public MaybeNamedParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maybeNamedParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMaybeNamedParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMaybeNamedParam(this);
		}
	}

	[RuleVersion(0)]
	public MaybeNamedParamContext maybeNamedParam() {
		MaybeNamedParamContext _localctx = new MaybeNamedParamContext(Context, State);
		EnterRule(_localctx, 314, RULE_maybeNamedParam);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 2150; outerAttribute();
				}
				}
				State = 2155;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2161;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,295,Context) ) {
			case 1:
				{
				State = 2158;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case KW_MACRORULES:
				case NON_KEYWORD_IDENTIFIER:
				case RAW_IDENTIFIER:
					{
					State = 2156; identifier();
					}
					break;
				case UNDERSCORE:
					{
					State = 2157; Match(UNDERSCORE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2160; Match(COLON);
				}
				break;
			}
			State = 2163; type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MaybeNamedFunctionParametersVariadicContext : ParserRuleContext {
		public MaybeNamedParamContext[] maybeNamedParam() {
			return GetRuleContexts<MaybeNamedParamContext>();
		}
		public MaybeNamedParamContext maybeNamedParam(int i) {
			return GetRuleContext<MaybeNamedParamContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public ITerminalNode DOTDOTDOT() { return GetToken(RustParser.DOTDOTDOT, 0); }
		public OuterAttributeContext[] outerAttribute() {
			return GetRuleContexts<OuterAttributeContext>();
		}
		public OuterAttributeContext outerAttribute(int i) {
			return GetRuleContext<OuterAttributeContext>(i);
		}
		public MaybeNamedFunctionParametersVariadicContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maybeNamedFunctionParametersVariadic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMaybeNamedFunctionParametersVariadic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMaybeNamedFunctionParametersVariadic(this);
		}
	}

	[RuleVersion(0)]
	public MaybeNamedFunctionParametersVariadicContext maybeNamedFunctionParametersVariadic() {
		MaybeNamedFunctionParametersVariadicContext _localctx = new MaybeNamedFunctionParametersVariadicContext(Context, State);
		EnterRule(_localctx, 316, RULE_maybeNamedFunctionParametersVariadic);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2170;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,296,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2165; maybeNamedParam();
					State = 2166; Match(COMMA);
					}
					} 
				}
				State = 2172;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,296,Context);
			}
			State = 2173; maybeNamedParam();
			State = 2174; Match(COMMA);
			State = 2178;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POUND) {
				{
				{
				State = 2175; outerAttribute();
				}
				}
				State = 2180;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2181; Match(DOTDOTDOT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TraitObjectTypeContext : ParserRuleContext {
		public TypeParamBoundsContext typeParamBounds() {
			return GetRuleContext<TypeParamBoundsContext>(0);
		}
		public ITerminalNode KW_DYN() { return GetToken(RustParser.KW_DYN, 0); }
		public TraitObjectTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_traitObjectType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTraitObjectType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTraitObjectType(this);
		}
	}

	[RuleVersion(0)]
	public TraitObjectTypeContext traitObjectType() {
		TraitObjectTypeContext _localctx = new TraitObjectTypeContext(Context, State);
		EnterRule(_localctx, 318, RULE_traitObjectType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2184;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_DYN) {
				{
				State = 2183; Match(KW_DYN);
				}
			}

			State = 2186; typeParamBounds();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TraitObjectTypeOneBoundContext : ParserRuleContext {
		public TraitBoundContext traitBound() {
			return GetRuleContext<TraitBoundContext>(0);
		}
		public ITerminalNode KW_DYN() { return GetToken(RustParser.KW_DYN, 0); }
		public TraitObjectTypeOneBoundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_traitObjectTypeOneBound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTraitObjectTypeOneBound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTraitObjectTypeOneBound(this);
		}
	}

	[RuleVersion(0)]
	public TraitObjectTypeOneBoundContext traitObjectTypeOneBound() {
		TraitObjectTypeOneBoundContext _localctx = new TraitObjectTypeOneBoundContext(Context, State);
		EnterRule(_localctx, 320, RULE_traitObjectTypeOneBound);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_DYN) {
				{
				State = 2188; Match(KW_DYN);
				}
			}

			State = 2191; traitBound();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImplTraitTypeContext : ParserRuleContext {
		public ITerminalNode KW_IMPL() { return GetToken(RustParser.KW_IMPL, 0); }
		public TypeParamBoundsContext typeParamBounds() {
			return GetRuleContext<TypeParamBoundsContext>(0);
		}
		public ImplTraitTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_implTraitType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterImplTraitType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitImplTraitType(this);
		}
	}

	[RuleVersion(0)]
	public ImplTraitTypeContext implTraitType() {
		ImplTraitTypeContext _localctx = new ImplTraitTypeContext(Context, State);
		EnterRule(_localctx, 322, RULE_implTraitType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2193; Match(KW_IMPL);
			State = 2194; typeParamBounds();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImplTraitTypeOneBoundContext : ParserRuleContext {
		public ITerminalNode KW_IMPL() { return GetToken(RustParser.KW_IMPL, 0); }
		public TraitBoundContext traitBound() {
			return GetRuleContext<TraitBoundContext>(0);
		}
		public ImplTraitTypeOneBoundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_implTraitTypeOneBound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterImplTraitTypeOneBound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitImplTraitTypeOneBound(this);
		}
	}

	[RuleVersion(0)]
	public ImplTraitTypeOneBoundContext implTraitTypeOneBound() {
		ImplTraitTypeOneBoundContext _localctx = new ImplTraitTypeOneBoundContext(Context, State);
		EnterRule(_localctx, 324, RULE_implTraitTypeOneBound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2196; Match(KW_IMPL);
			State = 2197; traitBound();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InferredTypeContext : ParserRuleContext {
		public ITerminalNode UNDERSCORE() { return GetToken(RustParser.UNDERSCORE, 0); }
		public InferredTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inferredType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterInferredType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitInferredType(this);
		}
	}

	[RuleVersion(0)]
	public InferredTypeContext inferredType() {
		InferredTypeContext _localctx = new InferredTypeContext(Context, State);
		EnterRule(_localctx, 326, RULE_inferredType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2199; Match(UNDERSCORE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeParamBoundsContext : ParserRuleContext {
		public TypeParamBoundContext[] typeParamBound() {
			return GetRuleContexts<TypeParamBoundContext>();
		}
		public TypeParamBoundContext typeParamBound(int i) {
			return GetRuleContext<TypeParamBoundContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(RustParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(RustParser.PLUS, i);
		}
		public TypeParamBoundsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeParamBounds; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypeParamBounds(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypeParamBounds(this);
		}
	}

	[RuleVersion(0)]
	public TypeParamBoundsContext typeParamBounds() {
		TypeParamBoundsContext _localctx = new TypeParamBoundsContext(Context, State);
		EnterRule(_localctx, 328, RULE_typeParamBounds);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2201; typeParamBound();
			State = 2206;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,300,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2202; Match(PLUS);
					State = 2203; typeParamBound();
					}
					} 
				}
				State = 2208;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,300,Context);
			}
			State = 2210;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,301,Context) ) {
			case 1:
				{
				State = 2209; Match(PLUS);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeParamBoundContext : ParserRuleContext {
		public LifetimeContext lifetime() {
			return GetRuleContext<LifetimeContext>(0);
		}
		public TraitBoundContext traitBound() {
			return GetRuleContext<TraitBoundContext>(0);
		}
		public TypeParamBoundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeParamBound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypeParamBound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypeParamBound(this);
		}
	}

	[RuleVersion(0)]
	public TypeParamBoundContext typeParamBound() {
		TypeParamBoundContext _localctx = new TypeParamBoundContext(Context, State);
		EnterRule(_localctx, 330, RULE_typeParamBound);
		try {
			State = 2214;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_STATICLIFETIME:
			case KW_UNDERLINELIFETIME:
			case LIFETIME_OR_LABEL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2212; lifetime();
				}
				break;
			case KW_CRATE:
			case KW_FOR:
			case KW_SELFVALUE:
			case KW_SELFTYPE:
			case KW_SUPER:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case PATHSEP:
			case QUESTION:
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2213; traitBound();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TraitBoundContext : ParserRuleContext {
		public TypePathContext typePath() {
			return GetRuleContext<TypePathContext>(0);
		}
		public ITerminalNode QUESTION() { return GetToken(RustParser.QUESTION, 0); }
		public ForLifetimesContext forLifetimes() {
			return GetRuleContext<ForLifetimesContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public TraitBoundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_traitBound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTraitBound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTraitBound(this);
		}
	}

	[RuleVersion(0)]
	public TraitBoundContext traitBound() {
		TraitBoundContext _localctx = new TraitBoundContext(Context, State);
		EnterRule(_localctx, 332, RULE_traitBound);
		int _la;
		try {
			State = 2233;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_CRATE:
			case KW_FOR:
			case KW_SELFVALUE:
			case KW_SELFTYPE:
			case KW_SUPER:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
			case PATHSEP:
			case QUESTION:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2217;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==QUESTION) {
					{
					State = 2216; Match(QUESTION);
					}
				}

				State = 2220;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KW_FOR) {
					{
					State = 2219; forLifetimes();
					}
				}

				State = 2222; typePath();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2223; Match(LPAREN);
				State = 2225;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==QUESTION) {
					{
					State = 2224; Match(QUESTION);
					}
				}

				State = 2228;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KW_FOR) {
					{
					State = 2227; forLifetimes();
					}
				}

				State = 2230; typePath();
				State = 2231; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LifetimeBoundsContext : ParserRuleContext {
		public LifetimeContext[] lifetime() {
			return GetRuleContexts<LifetimeContext>();
		}
		public LifetimeContext lifetime(int i) {
			return GetRuleContext<LifetimeContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(RustParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(RustParser.PLUS, i);
		}
		public LifetimeBoundsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lifetimeBounds; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLifetimeBounds(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLifetimeBounds(this);
		}
	}

	[RuleVersion(0)]
	public LifetimeBoundsContext lifetimeBounds() {
		LifetimeBoundsContext _localctx = new LifetimeBoundsContext(Context, State);
		EnterRule(_localctx, 334, RULE_lifetimeBounds);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2240;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,308,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2235; lifetime();
					State = 2236; Match(PLUS);
					}
					} 
				}
				State = 2242;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,308,Context);
			}
			State = 2244;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 53)) & ~0x3f) == 0 && ((1L << (_la - 53)) & ((1L << (KW_STATICLIFETIME - 53)) | (1L << (KW_UNDERLINELIFETIME - 53)) | (1L << (LIFETIME_OR_LABEL - 53)))) != 0)) {
				{
				State = 2243; lifetime();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LifetimeContext : ParserRuleContext {
		public ITerminalNode LIFETIME_OR_LABEL() { return GetToken(RustParser.LIFETIME_OR_LABEL, 0); }
		public ITerminalNode KW_STATICLIFETIME() { return GetToken(RustParser.KW_STATICLIFETIME, 0); }
		public ITerminalNode KW_UNDERLINELIFETIME() { return GetToken(RustParser.KW_UNDERLINELIFETIME, 0); }
		public LifetimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lifetime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterLifetime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitLifetime(this);
		}
	}

	[RuleVersion(0)]
	public LifetimeContext lifetime() {
		LifetimeContext _localctx = new LifetimeContext(Context, State);
		EnterRule(_localctx, 336, RULE_lifetime);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2246;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 53)) & ~0x3f) == 0 && ((1L << (_la - 53)) & ((1L << (KW_STATICLIFETIME - 53)) | (1L << (KW_UNDERLINELIFETIME - 53)) | (1L << (LIFETIME_OR_LABEL - 53)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimplePathContext : ParserRuleContext {
		public SimplePathSegmentContext[] simplePathSegment() {
			return GetRuleContexts<SimplePathSegmentContext>();
		}
		public SimplePathSegmentContext simplePathSegment(int i) {
			return GetRuleContext<SimplePathSegmentContext>(i);
		}
		public ITerminalNode[] PATHSEP() { return GetTokens(RustParser.PATHSEP); }
		public ITerminalNode PATHSEP(int i) {
			return GetToken(RustParser.PATHSEP, i);
		}
		public SimplePathContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simplePath; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterSimplePath(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitSimplePath(this);
		}
	}

	[RuleVersion(0)]
	public SimplePathContext simplePath() {
		SimplePathContext _localctx = new SimplePathContext(Context, State);
		EnterRule(_localctx, 338, RULE_simplePath);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2249;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATHSEP) {
				{
				State = 2248; Match(PATHSEP);
				}
			}

			State = 2251; simplePathSegment();
			State = 2256;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,311,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2252; Match(PATHSEP);
					State = 2253; simplePathSegment();
					}
					} 
				}
				State = 2258;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,311,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimplePathSegmentContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode KW_SUPER() { return GetToken(RustParser.KW_SUPER, 0); }
		public ITerminalNode KW_SELFVALUE() { return GetToken(RustParser.KW_SELFVALUE, 0); }
		public ITerminalNode KW_CRATE() { return GetToken(RustParser.KW_CRATE, 0); }
		public ITerminalNode KW_DOLLARCRATE() { return GetToken(RustParser.KW_DOLLARCRATE, 0); }
		public SimplePathSegmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simplePathSegment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterSimplePathSegment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitSimplePathSegment(this);
		}
	}

	[RuleVersion(0)]
	public SimplePathSegmentContext simplePathSegment() {
		SimplePathSegmentContext _localctx = new SimplePathSegmentContext(Context, State);
		EnterRule(_localctx, 340, RULE_simplePathSegment);
		try {
			State = 2264;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_MACRORULES:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2259; identifier();
				}
				break;
			case KW_SUPER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2260; Match(KW_SUPER);
				}
				break;
			case KW_SELFVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2261; Match(KW_SELFVALUE);
				}
				break;
			case KW_CRATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2262; Match(KW_CRATE);
				}
				break;
			case KW_DOLLARCRATE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2263; Match(KW_DOLLARCRATE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathInExpressionContext : ParserRuleContext {
		public PathExprSegmentContext[] pathExprSegment() {
			return GetRuleContexts<PathExprSegmentContext>();
		}
		public PathExprSegmentContext pathExprSegment(int i) {
			return GetRuleContext<PathExprSegmentContext>(i);
		}
		public ITerminalNode[] PATHSEP() { return GetTokens(RustParser.PATHSEP); }
		public ITerminalNode PATHSEP(int i) {
			return GetToken(RustParser.PATHSEP, i);
		}
		public PathInExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathInExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPathInExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPathInExpression(this);
		}
	}

	[RuleVersion(0)]
	public PathInExpressionContext pathInExpression() {
		PathInExpressionContext _localctx = new PathInExpressionContext(Context, State);
		EnterRule(_localctx, 342, RULE_pathInExpression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2267;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATHSEP) {
				{
				State = 2266; Match(PATHSEP);
				}
			}

			State = 2269; pathExprSegment();
			State = 2274;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,314,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2270; Match(PATHSEP);
					State = 2271; pathExprSegment();
					}
					} 
				}
				State = 2276;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,314,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathExprSegmentContext : ParserRuleContext {
		public PathIdentSegmentContext pathIdentSegment() {
			return GetRuleContext<PathIdentSegmentContext>(0);
		}
		public ITerminalNode PATHSEP() { return GetToken(RustParser.PATHSEP, 0); }
		public GenericArgsContext genericArgs() {
			return GetRuleContext<GenericArgsContext>(0);
		}
		public PathExprSegmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathExprSegment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPathExprSegment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPathExprSegment(this);
		}
	}

	[RuleVersion(0)]
	public PathExprSegmentContext pathExprSegment() {
		PathExprSegmentContext _localctx = new PathExprSegmentContext(Context, State);
		EnterRule(_localctx, 344, RULE_pathExprSegment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2277; pathIdentSegment();
			State = 2280;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,315,Context) ) {
			case 1:
				{
				State = 2278; Match(PATHSEP);
				State = 2279; genericArgs();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathIdentSegmentContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode KW_SUPER() { return GetToken(RustParser.KW_SUPER, 0); }
		public ITerminalNode KW_SELFVALUE() { return GetToken(RustParser.KW_SELFVALUE, 0); }
		public ITerminalNode KW_SELFTYPE() { return GetToken(RustParser.KW_SELFTYPE, 0); }
		public ITerminalNode KW_CRATE() { return GetToken(RustParser.KW_CRATE, 0); }
		public ITerminalNode KW_DOLLARCRATE() { return GetToken(RustParser.KW_DOLLARCRATE, 0); }
		public PathIdentSegmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathIdentSegment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterPathIdentSegment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitPathIdentSegment(this);
		}
	}

	[RuleVersion(0)]
	public PathIdentSegmentContext pathIdentSegment() {
		PathIdentSegmentContext _localctx = new PathIdentSegmentContext(Context, State);
		EnterRule(_localctx, 346, RULE_pathIdentSegment);
		try {
			State = 2288;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KW_MACRORULES:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2282; identifier();
				}
				break;
			case KW_SUPER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2283; Match(KW_SUPER);
				}
				break;
			case KW_SELFVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2284; Match(KW_SELFVALUE);
				}
				break;
			case KW_SELFTYPE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2285; Match(KW_SELFTYPE);
				}
				break;
			case KW_CRATE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2286; Match(KW_CRATE);
				}
				break;
			case KW_DOLLARCRATE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2287; Match(KW_DOLLARCRATE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericArgsContext : ParserRuleContext {
		public ITerminalNode LT() { return GetToken(RustParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(RustParser.GT, 0); }
		public GenericArgsLifetimesContext genericArgsLifetimes() {
			return GetRuleContext<GenericArgsLifetimesContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public GenericArgsTypesContext genericArgsTypes() {
			return GetRuleContext<GenericArgsTypesContext>(0);
		}
		public GenericArgsBindingsContext genericArgsBindings() {
			return GetRuleContext<GenericArgsBindingsContext>(0);
		}
		public GenericArgContext[] genericArg() {
			return GetRuleContexts<GenericArgContext>();
		}
		public GenericArgContext genericArg(int i) {
			return GetRuleContext<GenericArgContext>(i);
		}
		public GenericArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericArgs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericArgs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericArgs(this);
		}
	}

	[RuleVersion(0)]
	public GenericArgsContext genericArgs() {
		GenericArgsContext _localctx = new GenericArgsContext(Context, State);
		EnterRule(_localctx, 348, RULE_genericArgs);
		int _la;
		try {
			int _alt;
			State = 2333;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,324,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2290; Match(LT);
				State = 2291; Match(GT);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2292; Match(LT);
				State = 2293; genericArgsLifetimes();
				State = 2296;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,317,Context) ) {
				case 1:
					{
					State = 2294; Match(COMMA);
					State = 2295; genericArgsTypes();
					}
					break;
				}
				State = 2300;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,318,Context) ) {
				case 1:
					{
					State = 2298; Match(COMMA);
					State = 2299; genericArgsBindings();
					}
					break;
				}
				State = 2303;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2302; Match(COMMA);
					}
				}

				State = 2305; Match(GT);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2307; Match(LT);
				State = 2308; genericArgsTypes();
				State = 2311;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,320,Context) ) {
				case 1:
					{
					State = 2309; Match(COMMA);
					State = 2310; genericArgsBindings();
					}
					break;
				}
				State = 2314;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2313; Match(COMMA);
					}
				}

				State = 2316; Match(GT);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2318; Match(LT);
				State = 2324;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,322,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 2319; genericArg();
						State = 2320; Match(COMMA);
						}
						} 
					}
					State = 2326;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,322,Context);
				}
				State = 2327; genericArg();
				State = 2329;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2328; Match(COMMA);
					}
				}

				State = 2331; Match(GT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericArgContext : ParserRuleContext {
		public LifetimeContext lifetime() {
			return GetRuleContext<LifetimeContext>(0);
		}
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public GenericArgsConstContext genericArgsConst() {
			return GetRuleContext<GenericArgsConstContext>(0);
		}
		public GenericArgsBindingContext genericArgsBinding() {
			return GetRuleContext<GenericArgsBindingContext>(0);
		}
		public GenericArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericArg; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericArg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericArg(this);
		}
	}

	[RuleVersion(0)]
	public GenericArgContext genericArg() {
		GenericArgContext _localctx = new GenericArgContext(Context, State);
		EnterRule(_localctx, 350, RULE_genericArg);
		try {
			State = 2339;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,325,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2335; lifetime();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2336; type_();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2337; genericArgsConst();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2338; genericArgsBinding();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericArgsConstContext : ParserRuleContext {
		public BlockExpressionContext blockExpression() {
			return GetRuleContext<BlockExpressionContext>(0);
		}
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(RustParser.MINUS, 0); }
		public SimplePathSegmentContext simplePathSegment() {
			return GetRuleContext<SimplePathSegmentContext>(0);
		}
		public GenericArgsConstContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericArgsConst; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericArgsConst(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericArgsConst(this);
		}
	}

	[RuleVersion(0)]
	public GenericArgsConstContext genericArgsConst() {
		GenericArgsConstContext _localctx = new GenericArgsConstContext(Context, State);
		EnterRule(_localctx, 352, RULE_genericArgsConst);
		int _la;
		try {
			State = 2347;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LCURLYBRACE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2341; blockExpression();
				}
				break;
			case KW_FALSE:
			case KW_TRUE:
			case CHAR_LITERAL:
			case STRING_LITERAL:
			case RAW_STRING_LITERAL:
			case BYTE_LITERAL:
			case BYTE_STRING_LITERAL:
			case RAW_BYTE_STRING_LITERAL:
			case INTEGER_LITERAL:
			case FLOAT_LITERAL:
			case MINUS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2343;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MINUS) {
					{
					State = 2342; Match(MINUS);
					}
				}

				State = 2345; literalExpression();
				}
				break;
			case KW_CRATE:
			case KW_SELFVALUE:
			case KW_SUPER:
			case KW_MACRORULES:
			case KW_DOLLARCRATE:
			case NON_KEYWORD_IDENTIFIER:
			case RAW_IDENTIFIER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2346; simplePathSegment();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericArgsLifetimesContext : ParserRuleContext {
		public LifetimeContext[] lifetime() {
			return GetRuleContexts<LifetimeContext>();
		}
		public LifetimeContext lifetime(int i) {
			return GetRuleContext<LifetimeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public GenericArgsLifetimesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericArgsLifetimes; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericArgsLifetimes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericArgsLifetimes(this);
		}
	}

	[RuleVersion(0)]
	public GenericArgsLifetimesContext genericArgsLifetimes() {
		GenericArgsLifetimesContext _localctx = new GenericArgsLifetimesContext(Context, State);
		EnterRule(_localctx, 354, RULE_genericArgsLifetimes);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2349; lifetime();
			State = 2354;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,328,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2350; Match(COMMA);
					State = 2351; lifetime();
					}
					} 
				}
				State = 2356;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,328,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericArgsTypesContext : ParserRuleContext {
		public Type_Context[] type_() {
			return GetRuleContexts<Type_Context>();
		}
		public Type_Context type_(int i) {
			return GetRuleContext<Type_Context>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public GenericArgsTypesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericArgsTypes; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericArgsTypes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericArgsTypes(this);
		}
	}

	[RuleVersion(0)]
	public GenericArgsTypesContext genericArgsTypes() {
		GenericArgsTypesContext _localctx = new GenericArgsTypesContext(Context, State);
		EnterRule(_localctx, 356, RULE_genericArgsTypes);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2357; type_();
			State = 2362;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,329,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2358; Match(COMMA);
					State = 2359; type_();
					}
					} 
				}
				State = 2364;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,329,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericArgsBindingsContext : ParserRuleContext {
		public GenericArgsBindingContext[] genericArgsBinding() {
			return GetRuleContexts<GenericArgsBindingContext>();
		}
		public GenericArgsBindingContext genericArgsBinding(int i) {
			return GetRuleContext<GenericArgsBindingContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public GenericArgsBindingsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericArgsBindings; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericArgsBindings(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericArgsBindings(this);
		}
	}

	[RuleVersion(0)]
	public GenericArgsBindingsContext genericArgsBindings() {
		GenericArgsBindingsContext _localctx = new GenericArgsBindingsContext(Context, State);
		EnterRule(_localctx, 358, RULE_genericArgsBindings);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2365; genericArgsBinding();
			State = 2370;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,330,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2366; Match(COMMA);
					State = 2367; genericArgsBinding();
					}
					} 
				}
				State = 2372;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,330,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericArgsBindingContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public GenericArgsBindingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericArgsBinding; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterGenericArgsBinding(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitGenericArgsBinding(this);
		}
	}

	[RuleVersion(0)]
	public GenericArgsBindingContext genericArgsBinding() {
		GenericArgsBindingContext _localctx = new GenericArgsBindingContext(Context, State);
		EnterRule(_localctx, 360, RULE_genericArgsBinding);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2373; identifier();
			State = 2374; Match(EQ);
			State = 2375; type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifiedPathInExpressionContext : ParserRuleContext {
		public QualifiedPathTypeContext qualifiedPathType() {
			return GetRuleContext<QualifiedPathTypeContext>(0);
		}
		public ITerminalNode[] PATHSEP() { return GetTokens(RustParser.PATHSEP); }
		public ITerminalNode PATHSEP(int i) {
			return GetToken(RustParser.PATHSEP, i);
		}
		public PathExprSegmentContext[] pathExprSegment() {
			return GetRuleContexts<PathExprSegmentContext>();
		}
		public PathExprSegmentContext pathExprSegment(int i) {
			return GetRuleContext<PathExprSegmentContext>(i);
		}
		public QualifiedPathInExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifiedPathInExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterQualifiedPathInExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitQualifiedPathInExpression(this);
		}
	}

	[RuleVersion(0)]
	public QualifiedPathInExpressionContext qualifiedPathInExpression() {
		QualifiedPathInExpressionContext _localctx = new QualifiedPathInExpressionContext(Context, State);
		EnterRule(_localctx, 362, RULE_qualifiedPathInExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2377; qualifiedPathType();
			State = 2380;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 2378; Match(PATHSEP);
					State = 2379; pathExprSegment();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2382;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,331,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifiedPathTypeContext : ParserRuleContext {
		public ITerminalNode LT() { return GetToken(RustParser.LT, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ITerminalNode GT() { return GetToken(RustParser.GT, 0); }
		public ITerminalNode KW_AS() { return GetToken(RustParser.KW_AS, 0); }
		public TypePathContext typePath() {
			return GetRuleContext<TypePathContext>(0);
		}
		public QualifiedPathTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifiedPathType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterQualifiedPathType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitQualifiedPathType(this);
		}
	}

	[RuleVersion(0)]
	public QualifiedPathTypeContext qualifiedPathType() {
		QualifiedPathTypeContext _localctx = new QualifiedPathTypeContext(Context, State);
		EnterRule(_localctx, 364, RULE_qualifiedPathType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2384; Match(LT);
			State = 2385; type_();
			State = 2388;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KW_AS) {
				{
				State = 2386; Match(KW_AS);
				State = 2387; typePath();
				}
			}

			State = 2390; Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifiedPathInTypeContext : ParserRuleContext {
		public QualifiedPathTypeContext qualifiedPathType() {
			return GetRuleContext<QualifiedPathTypeContext>(0);
		}
		public ITerminalNode[] PATHSEP() { return GetTokens(RustParser.PATHSEP); }
		public ITerminalNode PATHSEP(int i) {
			return GetToken(RustParser.PATHSEP, i);
		}
		public TypePathSegmentContext[] typePathSegment() {
			return GetRuleContexts<TypePathSegmentContext>();
		}
		public TypePathSegmentContext typePathSegment(int i) {
			return GetRuleContext<TypePathSegmentContext>(i);
		}
		public QualifiedPathInTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifiedPathInType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterQualifiedPathInType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitQualifiedPathInType(this);
		}
	}

	[RuleVersion(0)]
	public QualifiedPathInTypeContext qualifiedPathInType() {
		QualifiedPathInTypeContext _localctx = new QualifiedPathInTypeContext(Context, State);
		EnterRule(_localctx, 366, RULE_qualifiedPathInType);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2392; qualifiedPathType();
			State = 2395;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 2393; Match(PATHSEP);
					State = 2394; typePathSegment();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2397;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,333,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypePathContext : ParserRuleContext {
		public TypePathSegmentContext[] typePathSegment() {
			return GetRuleContexts<TypePathSegmentContext>();
		}
		public TypePathSegmentContext typePathSegment(int i) {
			return GetRuleContext<TypePathSegmentContext>(i);
		}
		public ITerminalNode[] PATHSEP() { return GetTokens(RustParser.PATHSEP); }
		public ITerminalNode PATHSEP(int i) {
			return GetToken(RustParser.PATHSEP, i);
		}
		public TypePathContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typePath; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypePath(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypePath(this);
		}
	}

	[RuleVersion(0)]
	public TypePathContext typePath() {
		TypePathContext _localctx = new TypePathContext(Context, State);
		EnterRule(_localctx, 368, RULE_typePath);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2400;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PATHSEP) {
				{
				State = 2399; Match(PATHSEP);
				}
			}

			State = 2402; typePathSegment();
			State = 2407;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,335,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2403; Match(PATHSEP);
					State = 2404; typePathSegment();
					}
					} 
				}
				State = 2409;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,335,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypePathSegmentContext : ParserRuleContext {
		public PathIdentSegmentContext pathIdentSegment() {
			return GetRuleContext<PathIdentSegmentContext>(0);
		}
		public ITerminalNode PATHSEP() { return GetToken(RustParser.PATHSEP, 0); }
		public GenericArgsContext genericArgs() {
			return GetRuleContext<GenericArgsContext>(0);
		}
		public TypePathFnContext typePathFn() {
			return GetRuleContext<TypePathFnContext>(0);
		}
		public TypePathSegmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typePathSegment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypePathSegment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypePathSegment(this);
		}
	}

	[RuleVersion(0)]
	public TypePathSegmentContext typePathSegment() {
		TypePathSegmentContext _localctx = new TypePathSegmentContext(Context, State);
		EnterRule(_localctx, 370, RULE_typePathSegment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2410; pathIdentSegment();
			State = 2412;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,336,Context) ) {
			case 1:
				{
				State = 2411; Match(PATHSEP);
				}
				break;
			}
			State = 2416;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,337,Context) ) {
			case 1:
				{
				State = 2414; genericArgs();
				}
				break;
			case 2:
				{
				State = 2415; typePathFn();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypePathFnContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public TypePathInputsContext typePathInputs() {
			return GetRuleContext<TypePathInputsContext>(0);
		}
		public ITerminalNode RARROW() { return GetToken(RustParser.RARROW, 0); }
		public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public TypePathFnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typePathFn; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypePathFn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypePathFn(this);
		}
	}

	[RuleVersion(0)]
	public TypePathFnContext typePathFn() {
		TypePathFnContext _localctx = new TypePathFnContext(Context, State);
		EnterRule(_localctx, 372, RULE_typePathFn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2418; Match(LPAREN);
			State = 2420;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_CRATE) | (1L << KW_EXTERN) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IMPL) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_SUPER) | (1L << KW_UNSAFE) | (1L << KW_DYN) | (1L << KW_STATICLIFETIME) | (1L << KW_MACRORULES) | (1L << KW_UNDERLINELIFETIME) | (1L << KW_DOLLARCRATE) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0) || ((((_la - 81)) & ~0x3f) == 0 && ((1L << (_la - 81)) & ((1L << (LIFETIME_OR_LABEL - 81)) | (1L << (STAR - 81)) | (1L << (NOT - 81)) | (1L << (AND - 81)) | (1L << (LT - 81)) | (1L << (UNDERSCORE - 81)) | (1L << (PATHSEP - 81)) | (1L << (QUESTION - 81)) | (1L << (LSQUAREBRACKET - 81)) | (1L << (LPAREN - 81)))) != 0)) {
				{
				State = 2419; typePathInputs();
				}
			}

			State = 2422; Match(RPAREN);
			State = 2425;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,339,Context) ) {
			case 1:
				{
				State = 2423; Match(RARROW);
				State = 2424; type_();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypePathInputsContext : ParserRuleContext {
		public Type_Context[] type_() {
			return GetRuleContexts<Type_Context>();
		}
		public Type_Context type_(int i) {
			return GetRuleContext<Type_Context>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(RustParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(RustParser.COMMA, i);
		}
		public TypePathInputsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typePathInputs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterTypePathInputs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitTypePathInputs(this);
		}
	}

	[RuleVersion(0)]
	public TypePathInputsContext typePathInputs() {
		TypePathInputsContext _localctx = new TypePathInputsContext(Context, State);
		EnterRule(_localctx, 374, RULE_typePathInputs);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2427; type_();
			State = 2432;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,340,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2428; Match(COMMA);
					State = 2429; type_();
					}
					} 
				}
				State = 2434;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,340,Context);
			}
			State = 2436;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 2435; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VisibilityContext : ParserRuleContext {
		public ITerminalNode KW_PUB() { return GetToken(RustParser.KW_PUB, 0); }
		public ITerminalNode LPAREN() { return GetToken(RustParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(RustParser.RPAREN, 0); }
		public ITerminalNode KW_CRATE() { return GetToken(RustParser.KW_CRATE, 0); }
		public ITerminalNode KW_SELFVALUE() { return GetToken(RustParser.KW_SELFVALUE, 0); }
		public ITerminalNode KW_SUPER() { return GetToken(RustParser.KW_SUPER, 0); }
		public ITerminalNode KW_IN() { return GetToken(RustParser.KW_IN, 0); }
		public SimplePathContext simplePath() {
			return GetRuleContext<SimplePathContext>(0);
		}
		public VisibilityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_visibility; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterVisibility(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitVisibility(this);
		}
	}

	[RuleVersion(0)]
	public VisibilityContext visibility() {
		VisibilityContext _localctx = new VisibilityContext(Context, State);
		EnterRule(_localctx, 376, RULE_visibility);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2438; Match(KW_PUB);
			State = 2448;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,343,Context) ) {
			case 1:
				{
				State = 2439; Match(LPAREN);
				State = 2445;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case KW_CRATE:
					{
					State = 2440; Match(KW_CRATE);
					}
					break;
				case KW_SELFVALUE:
					{
					State = 2441; Match(KW_SELFVALUE);
					}
					break;
				case KW_SUPER:
					{
					State = 2442; Match(KW_SUPER);
					}
					break;
				case KW_IN:
					{
					State = 2443; Match(KW_IN);
					State = 2444; simplePath();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2447; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public ITerminalNode NON_KEYWORD_IDENTIFIER() { return GetToken(RustParser.NON_KEYWORD_IDENTIFIER, 0); }
		public ITerminalNode RAW_IDENTIFIER() { return GetToken(RustParser.RAW_IDENTIFIER, 0); }
		public ITerminalNode KW_MACRORULES() { return GetToken(RustParser.KW_MACRORULES, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 378, RULE_identifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2450;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_MACRORULES) | (1L << NON_KEYWORD_IDENTIFIER) | (1L << RAW_IDENTIFIER))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public ITerminalNode KW_AS() { return GetToken(RustParser.KW_AS, 0); }
		public ITerminalNode KW_BREAK() { return GetToken(RustParser.KW_BREAK, 0); }
		public ITerminalNode KW_CONST() { return GetToken(RustParser.KW_CONST, 0); }
		public ITerminalNode KW_CONTINUE() { return GetToken(RustParser.KW_CONTINUE, 0); }
		public ITerminalNode KW_CRATE() { return GetToken(RustParser.KW_CRATE, 0); }
		public ITerminalNode KW_ELSE() { return GetToken(RustParser.KW_ELSE, 0); }
		public ITerminalNode KW_ENUM() { return GetToken(RustParser.KW_ENUM, 0); }
		public ITerminalNode KW_EXTERN() { return GetToken(RustParser.KW_EXTERN, 0); }
		public ITerminalNode KW_FALSE() { return GetToken(RustParser.KW_FALSE, 0); }
		public ITerminalNode KW_FN() { return GetToken(RustParser.KW_FN, 0); }
		public ITerminalNode KW_FOR() { return GetToken(RustParser.KW_FOR, 0); }
		public ITerminalNode KW_IF() { return GetToken(RustParser.KW_IF, 0); }
		public ITerminalNode KW_IMPL() { return GetToken(RustParser.KW_IMPL, 0); }
		public ITerminalNode KW_IN() { return GetToken(RustParser.KW_IN, 0); }
		public ITerminalNode KW_LET() { return GetToken(RustParser.KW_LET, 0); }
		public ITerminalNode KW_LOOP() { return GetToken(RustParser.KW_LOOP, 0); }
		public ITerminalNode KW_MATCH() { return GetToken(RustParser.KW_MATCH, 0); }
		public ITerminalNode KW_MOD() { return GetToken(RustParser.KW_MOD, 0); }
		public ITerminalNode KW_MOVE() { return GetToken(RustParser.KW_MOVE, 0); }
		public ITerminalNode KW_MUT() { return GetToken(RustParser.KW_MUT, 0); }
		public ITerminalNode KW_PUB() { return GetToken(RustParser.KW_PUB, 0); }
		public ITerminalNode KW_REF() { return GetToken(RustParser.KW_REF, 0); }
		public ITerminalNode KW_RETURN() { return GetToken(RustParser.KW_RETURN, 0); }
		public ITerminalNode KW_SELFVALUE() { return GetToken(RustParser.KW_SELFVALUE, 0); }
		public ITerminalNode KW_SELFTYPE() { return GetToken(RustParser.KW_SELFTYPE, 0); }
		public ITerminalNode KW_STATIC() { return GetToken(RustParser.KW_STATIC, 0); }
		public ITerminalNode KW_STRUCT() { return GetToken(RustParser.KW_STRUCT, 0); }
		public ITerminalNode KW_SUPER() { return GetToken(RustParser.KW_SUPER, 0); }
		public ITerminalNode KW_TRAIT() { return GetToken(RustParser.KW_TRAIT, 0); }
		public ITerminalNode KW_TRUE() { return GetToken(RustParser.KW_TRUE, 0); }
		public ITerminalNode KW_TYPE() { return GetToken(RustParser.KW_TYPE, 0); }
		public ITerminalNode KW_UNSAFE() { return GetToken(RustParser.KW_UNSAFE, 0); }
		public ITerminalNode KW_USE() { return GetToken(RustParser.KW_USE, 0); }
		public ITerminalNode KW_WHERE() { return GetToken(RustParser.KW_WHERE, 0); }
		public ITerminalNode KW_WHILE() { return GetToken(RustParser.KW_WHILE, 0); }
		public ITerminalNode KW_ASYNC() { return GetToken(RustParser.KW_ASYNC, 0); }
		public ITerminalNode KW_AWAIT() { return GetToken(RustParser.KW_AWAIT, 0); }
		public ITerminalNode KW_DYN() { return GetToken(RustParser.KW_DYN, 0); }
		public ITerminalNode KW_ABSTRACT() { return GetToken(RustParser.KW_ABSTRACT, 0); }
		public ITerminalNode KW_BECOME() { return GetToken(RustParser.KW_BECOME, 0); }
		public ITerminalNode KW_BOX() { return GetToken(RustParser.KW_BOX, 0); }
		public ITerminalNode KW_DO() { return GetToken(RustParser.KW_DO, 0); }
		public ITerminalNode KW_FINAL() { return GetToken(RustParser.KW_FINAL, 0); }
		public ITerminalNode KW_MACRO() { return GetToken(RustParser.KW_MACRO, 0); }
		public ITerminalNode KW_OVERRIDE() { return GetToken(RustParser.KW_OVERRIDE, 0); }
		public ITerminalNode KW_PRIV() { return GetToken(RustParser.KW_PRIV, 0); }
		public ITerminalNode KW_TYPEOF() { return GetToken(RustParser.KW_TYPEOF, 0); }
		public ITerminalNode KW_UNSIZED() { return GetToken(RustParser.KW_UNSIZED, 0); }
		public ITerminalNode KW_VIRTUAL() { return GetToken(RustParser.KW_VIRTUAL, 0); }
		public ITerminalNode KW_YIELD() { return GetToken(RustParser.KW_YIELD, 0); }
		public ITerminalNode KW_TRY() { return GetToken(RustParser.KW_TRY, 0); }
		public ITerminalNode KW_UNION() { return GetToken(RustParser.KW_UNION, 0); }
		public ITerminalNode KW_STATICLIFETIME() { return GetToken(RustParser.KW_STATICLIFETIME, 0); }
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitKeyword(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(Context, State);
		EnterRule(_localctx, 380, RULE_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2452;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KW_AS) | (1L << KW_BREAK) | (1L << KW_CONST) | (1L << KW_CONTINUE) | (1L << KW_CRATE) | (1L << KW_ELSE) | (1L << KW_ENUM) | (1L << KW_EXTERN) | (1L << KW_FALSE) | (1L << KW_FN) | (1L << KW_FOR) | (1L << KW_IF) | (1L << KW_IMPL) | (1L << KW_IN) | (1L << KW_LET) | (1L << KW_LOOP) | (1L << KW_MATCH) | (1L << KW_MOD) | (1L << KW_MOVE) | (1L << KW_MUT) | (1L << KW_PUB) | (1L << KW_REF) | (1L << KW_RETURN) | (1L << KW_SELFVALUE) | (1L << KW_SELFTYPE) | (1L << KW_STATIC) | (1L << KW_STRUCT) | (1L << KW_SUPER) | (1L << KW_TRAIT) | (1L << KW_TRUE) | (1L << KW_TYPE) | (1L << KW_UNSAFE) | (1L << KW_USE) | (1L << KW_WHERE) | (1L << KW_WHILE) | (1L << KW_ASYNC) | (1L << KW_AWAIT) | (1L << KW_DYN) | (1L << KW_ABSTRACT) | (1L << KW_BECOME) | (1L << KW_BOX) | (1L << KW_DO) | (1L << KW_FINAL) | (1L << KW_MACRO) | (1L << KW_OVERRIDE) | (1L << KW_PRIV) | (1L << KW_TYPEOF) | (1L << KW_UNSIZED) | (1L << KW_VIRTUAL) | (1L << KW_YIELD) | (1L << KW_TRY) | (1L << KW_UNION) | (1L << KW_STATICLIFETIME))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroIdentifierLikeTokenContext : ParserRuleContext {
		public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode KW_MACRORULES() { return GetToken(RustParser.KW_MACRORULES, 0); }
		public ITerminalNode KW_UNDERLINELIFETIME() { return GetToken(RustParser.KW_UNDERLINELIFETIME, 0); }
		public ITerminalNode KW_DOLLARCRATE() { return GetToken(RustParser.KW_DOLLARCRATE, 0); }
		public ITerminalNode LIFETIME_OR_LABEL() { return GetToken(RustParser.LIFETIME_OR_LABEL, 0); }
		public MacroIdentifierLikeTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroIdentifierLikeToken; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroIdentifierLikeToken(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroIdentifierLikeToken(this);
		}
	}

	[RuleVersion(0)]
	public MacroIdentifierLikeTokenContext macroIdentifierLikeToken() {
		MacroIdentifierLikeTokenContext _localctx = new MacroIdentifierLikeTokenContext(Context, State);
		EnterRule(_localctx, 382, RULE_macroIdentifierLikeToken);
		try {
			State = 2460;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,344,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2454; keyword();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2455; identifier();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2456; Match(KW_MACRORULES);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2457; Match(KW_UNDERLINELIFETIME);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2458; Match(KW_DOLLARCRATE);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2459; Match(LIFETIME_OR_LABEL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroLiteralTokenContext : ParserRuleContext {
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public MacroLiteralTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroLiteralToken; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroLiteralToken(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroLiteralToken(this);
		}
	}

	[RuleVersion(0)]
	public MacroLiteralTokenContext macroLiteralToken() {
		MacroLiteralTokenContext _localctx = new MacroLiteralTokenContext(Context, State);
		EnterRule(_localctx, 384, RULE_macroLiteralToken);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2462; literalExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MacroPunctuationTokenContext : ParserRuleContext {
		public ITerminalNode MINUS() { return GetToken(RustParser.MINUS, 0); }
		public ITerminalNode SLASH() { return GetToken(RustParser.SLASH, 0); }
		public ITerminalNode PERCENT() { return GetToken(RustParser.PERCENT, 0); }
		public ITerminalNode CARET() { return GetToken(RustParser.CARET, 0); }
		public ITerminalNode NOT() { return GetToken(RustParser.NOT, 0); }
		public ITerminalNode AND() { return GetToken(RustParser.AND, 0); }
		public ITerminalNode OR() { return GetToken(RustParser.OR, 0); }
		public ITerminalNode ANDAND() { return GetToken(RustParser.ANDAND, 0); }
		public ITerminalNode OROR() { return GetToken(RustParser.OROR, 0); }
		public ITerminalNode PLUSEQ() { return GetToken(RustParser.PLUSEQ, 0); }
		public ITerminalNode MINUSEQ() { return GetToken(RustParser.MINUSEQ, 0); }
		public ITerminalNode STAREQ() { return GetToken(RustParser.STAREQ, 0); }
		public ITerminalNode SLASHEQ() { return GetToken(RustParser.SLASHEQ, 0); }
		public ITerminalNode PERCENTEQ() { return GetToken(RustParser.PERCENTEQ, 0); }
		public ITerminalNode CARETEQ() { return GetToken(RustParser.CARETEQ, 0); }
		public ITerminalNode ANDEQ() { return GetToken(RustParser.ANDEQ, 0); }
		public ITerminalNode OREQ() { return GetToken(RustParser.OREQ, 0); }
		public ITerminalNode SHLEQ() { return GetToken(RustParser.SHLEQ, 0); }
		public ITerminalNode SHREQ() { return GetToken(RustParser.SHREQ, 0); }
		public ITerminalNode EQ() { return GetToken(RustParser.EQ, 0); }
		public ITerminalNode EQEQ() { return GetToken(RustParser.EQEQ, 0); }
		public ITerminalNode NE() { return GetToken(RustParser.NE, 0); }
		public ITerminalNode GT() { return GetToken(RustParser.GT, 0); }
		public ITerminalNode LT() { return GetToken(RustParser.LT, 0); }
		public ITerminalNode GE() { return GetToken(RustParser.GE, 0); }
		public ITerminalNode LE() { return GetToken(RustParser.LE, 0); }
		public ITerminalNode AT() { return GetToken(RustParser.AT, 0); }
		public ITerminalNode UNDERSCORE() { return GetToken(RustParser.UNDERSCORE, 0); }
		public ITerminalNode DOT() { return GetToken(RustParser.DOT, 0); }
		public ITerminalNode DOTDOT() { return GetToken(RustParser.DOTDOT, 0); }
		public ITerminalNode DOTDOTDOT() { return GetToken(RustParser.DOTDOTDOT, 0); }
		public ITerminalNode DOTDOTEQ() { return GetToken(RustParser.DOTDOTEQ, 0); }
		public ITerminalNode COMMA() { return GetToken(RustParser.COMMA, 0); }
		public ITerminalNode SEMI() { return GetToken(RustParser.SEMI, 0); }
		public ITerminalNode COLON() { return GetToken(RustParser.COLON, 0); }
		public ITerminalNode PATHSEP() { return GetToken(RustParser.PATHSEP, 0); }
		public ITerminalNode RARROW() { return GetToken(RustParser.RARROW, 0); }
		public ITerminalNode FATARROW() { return GetToken(RustParser.FATARROW, 0); }
		public ITerminalNode POUND() { return GetToken(RustParser.POUND, 0); }
		public MacroPunctuationTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_macroPunctuationToken; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterMacroPunctuationToken(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitMacroPunctuationToken(this);
		}
	}

	[RuleVersion(0)]
	public MacroPunctuationTokenContext macroPunctuationToken() {
		MacroPunctuationTokenContext _localctx = new MacroPunctuationTokenContext(Context, State);
		EnterRule(_localctx, 386, RULE_macroPunctuationToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2464;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 83)) & ~0x3f) == 0 && ((1L << (_la - 83)) & ((1L << (MINUS - 83)) | (1L << (SLASH - 83)) | (1L << (PERCENT - 83)) | (1L << (CARET - 83)) | (1L << (NOT - 83)) | (1L << (AND - 83)) | (1L << (OR - 83)) | (1L << (ANDAND - 83)) | (1L << (OROR - 83)) | (1L << (PLUSEQ - 83)) | (1L << (MINUSEQ - 83)) | (1L << (STAREQ - 83)) | (1L << (SLASHEQ - 83)) | (1L << (PERCENTEQ - 83)) | (1L << (CARETEQ - 83)) | (1L << (ANDEQ - 83)) | (1L << (OREQ - 83)) | (1L << (SHLEQ - 83)) | (1L << (SHREQ - 83)) | (1L << (EQ - 83)) | (1L << (EQEQ - 83)) | (1L << (NE - 83)) | (1L << (GT - 83)) | (1L << (LT - 83)) | (1L << (GE - 83)) | (1L << (LE - 83)) | (1L << (AT - 83)) | (1L << (UNDERSCORE - 83)) | (1L << (DOT - 83)) | (1L << (DOTDOT - 83)) | (1L << (DOTDOTDOT - 83)) | (1L << (DOTDOTEQ - 83)) | (1L << (COMMA - 83)) | (1L << (SEMI - 83)) | (1L << (COLON - 83)) | (1L << (PATHSEP - 83)) | (1L << (RARROW - 83)) | (1L << (FATARROW - 83)) | (1L << (POUND - 83)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShlContext : ParserRuleContext {
		public ITerminalNode[] LT() { return GetTokens(RustParser.LT); }
		public ITerminalNode LT(int i) {
			return GetToken(RustParser.LT, i);
		}
		public ShlContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shl; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterShl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitShl(this);
		}
	}

	[RuleVersion(0)]
	public ShlContext shl() {
		ShlContext _localctx = new ShlContext(Context, State);
		EnterRule(_localctx, 388, RULE_shl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2466; Match(LT);
			State = 2467;
			if (!(this.next('<'))) throw new FailedPredicateException(this, "this.next('<')");
			State = 2468; Match(LT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShrContext : ParserRuleContext {
		public ITerminalNode[] GT() { return GetTokens(RustParser.GT); }
		public ITerminalNode GT(int i) {
			return GetToken(RustParser.GT, i);
		}
		public ShrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.EnterShr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRustParserListener typedListener = listener as IRustParserListener;
			if (typedListener != null) typedListener.ExitShr(this);
		}
	}

	[RuleVersion(0)]
	public ShrContext shr() {
		ShrContext _localctx = new ShrContext(Context, State);
		EnterRule(_localctx, 390, RULE_shr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2470; Match(GT);
			State = 2471;
			if (!(this.next('>'))) throw new FailedPredicateException(this, "this.next('>')");
			State = 2472; Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 77: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 194: return shl_sempred((ShlContext)_localctx, predIndex);
		case 195: return shr_sempred((ShrContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 26);
		case 1: return Precpred(Context, 25);
		case 2: return Precpred(Context, 24);
		case 3: return Precpred(Context, 23);
		case 4: return Precpred(Context, 22);
		case 5: return Precpred(Context, 21);
		case 6: return Precpred(Context, 20);
		case 7: return Precpred(Context, 19);
		case 8: return Precpred(Context, 18);
		case 9: return Precpred(Context, 14);
		case 10: return Precpred(Context, 13);
		case 11: return Precpred(Context, 12);
		case 12: return Precpred(Context, 37);
		case 13: return Precpred(Context, 36);
		case 14: return Precpred(Context, 35);
		case 15: return Precpred(Context, 34);
		case 16: return Precpred(Context, 33);
		case 17: return Precpred(Context, 32);
		case 18: return Precpred(Context, 31);
		case 19: return Precpred(Context, 27);
		case 20: return Precpred(Context, 17);
		}
		return true;
	}
	private bool shl_sempred(ShlContext _localctx, int predIndex) {
		switch (predIndex) {
		case 21: return this.next('<');
		}
		return true;
	}
	private bool shr_sempred(ShrContext _localctx, int predIndex) {
		switch (predIndex) {
		case 22: return this.next('>');
		}
		return true;
	}

	private static int[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x84', '\x9AD', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t', 
		',', '\x4', '-', '\t', '-', '\x4', '.', '\t', '.', '\x4', '/', '\t', '/', 
		'\x4', '\x30', '\t', '\x30', '\x4', '\x31', '\t', '\x31', '\x4', '\x32', 
		'\t', '\x32', '\x4', '\x33', '\t', '\x33', '\x4', '\x34', '\t', '\x34', 
		'\x4', '\x35', '\t', '\x35', '\x4', '\x36', '\t', '\x36', '\x4', '\x37', 
		'\t', '\x37', '\x4', '\x38', '\t', '\x38', '\x4', '\x39', '\t', '\x39', 
		'\x4', ':', '\t', ':', '\x4', ';', '\t', ';', '\x4', '<', '\t', '<', '\x4', 
		'=', '\t', '=', '\x4', '>', '\t', '>', '\x4', '?', '\t', '?', '\x4', '@', 
		'\t', '@', '\x4', '\x41', '\t', '\x41', '\x4', '\x42', '\t', '\x42', '\x4', 
		'\x43', '\t', '\x43', '\x4', '\x44', '\t', '\x44', '\x4', '\x45', '\t', 
		'\x45', '\x4', '\x46', '\t', '\x46', '\x4', 'G', '\t', 'G', '\x4', 'H', 
		'\t', 'H', '\x4', 'I', '\t', 'I', '\x4', 'J', '\t', 'J', '\x4', 'K', '\t', 
		'K', '\x4', 'L', '\t', 'L', '\x4', 'M', '\t', 'M', '\x4', 'N', '\t', 'N', 
		'\x4', 'O', '\t', 'O', '\x4', 'P', '\t', 'P', '\x4', 'Q', '\t', 'Q', '\x4', 
		'R', '\t', 'R', '\x4', 'S', '\t', 'S', '\x4', 'T', '\t', 'T', '\x4', 'U', 
		'\t', 'U', '\x4', 'V', '\t', 'V', '\x4', 'W', '\t', 'W', '\x4', 'X', '\t', 
		'X', '\x4', 'Y', '\t', 'Y', '\x4', 'Z', '\t', 'Z', '\x4', '[', '\t', '[', 
		'\x4', '\\', '\t', '\\', '\x4', ']', '\t', ']', '\x4', '^', '\t', '^', 
		'\x4', '_', '\t', '_', '\x4', '`', '\t', '`', '\x4', '\x61', '\t', '\x61', 
		'\x4', '\x62', '\t', '\x62', '\x4', '\x63', '\t', '\x63', '\x4', '\x64', 
		'\t', '\x64', '\x4', '\x65', '\t', '\x65', '\x4', '\x66', '\t', '\x66', 
		'\x4', 'g', '\t', 'g', '\x4', 'h', '\t', 'h', '\x4', 'i', '\t', 'i', '\x4', 
		'j', '\t', 'j', '\x4', 'k', '\t', 'k', '\x4', 'l', '\t', 'l', '\x4', 'm', 
		'\t', 'm', '\x4', 'n', '\t', 'n', '\x4', 'o', '\t', 'o', '\x4', 'p', '\t', 
		'p', '\x4', 'q', '\t', 'q', '\x4', 'r', '\t', 'r', '\x4', 's', '\t', 's', 
		'\x4', 't', '\t', 't', '\x4', 'u', '\t', 'u', '\x4', 'v', '\t', 'v', '\x4', 
		'w', '\t', 'w', '\x4', 'x', '\t', 'x', '\x4', 'y', '\t', 'y', '\x4', 'z', 
		'\t', 'z', '\x4', '{', '\t', '{', '\x4', '|', '\t', '|', '\x4', '}', '\t', 
		'}', '\x4', '~', '\t', '~', '\x4', '\x7F', '\t', '\x7F', '\x4', '\x80', 
		'\t', '\x80', '\x4', '\x81', '\t', '\x81', '\x4', '\x82', '\t', '\x82', 
		'\x4', '\x83', '\t', '\x83', '\x4', '\x84', '\t', '\x84', '\x4', '\x85', 
		'\t', '\x85', '\x4', '\x86', '\t', '\x86', '\x4', '\x87', '\t', '\x87', 
		'\x4', '\x88', '\t', '\x88', '\x4', '\x89', '\t', '\x89', '\x4', '\x8A', 
		'\t', '\x8A', '\x4', '\x8B', '\t', '\x8B', '\x4', '\x8C', '\t', '\x8C', 
		'\x4', '\x8D', '\t', '\x8D', '\x4', '\x8E', '\t', '\x8E', '\x4', '\x8F', 
		'\t', '\x8F', '\x4', '\x90', '\t', '\x90', '\x4', '\x91', '\t', '\x91', 
		'\x4', '\x92', '\t', '\x92', '\x4', '\x93', '\t', '\x93', '\x4', '\x94', 
		'\t', '\x94', '\x4', '\x95', '\t', '\x95', '\x4', '\x96', '\t', '\x96', 
		'\x4', '\x97', '\t', '\x97', '\x4', '\x98', '\t', '\x98', '\x4', '\x99', 
		'\t', '\x99', '\x4', '\x9A', '\t', '\x9A', '\x4', '\x9B', '\t', '\x9B', 
		'\x4', '\x9C', '\t', '\x9C', '\x4', '\x9D', '\t', '\x9D', '\x4', '\x9E', 
		'\t', '\x9E', '\x4', '\x9F', '\t', '\x9F', '\x4', '\xA0', '\t', '\xA0', 
		'\x4', '\xA1', '\t', '\xA1', '\x4', '\xA2', '\t', '\xA2', '\x4', '\xA3', 
		'\t', '\xA3', '\x4', '\xA4', '\t', '\xA4', '\x4', '\xA5', '\t', '\xA5', 
		'\x4', '\xA6', '\t', '\xA6', '\x4', '\xA7', '\t', '\xA7', '\x4', '\xA8', 
		'\t', '\xA8', '\x4', '\xA9', '\t', '\xA9', '\x4', '\xAA', '\t', '\xAA', 
		'\x4', '\xAB', '\t', '\xAB', '\x4', '\xAC', '\t', '\xAC', '\x4', '\xAD', 
		'\t', '\xAD', '\x4', '\xAE', '\t', '\xAE', '\x4', '\xAF', '\t', '\xAF', 
		'\x4', '\xB0', '\t', '\xB0', '\x4', '\xB1', '\t', '\xB1', '\x4', '\xB2', 
		'\t', '\xB2', '\x4', '\xB3', '\t', '\xB3', '\x4', '\xB4', '\t', '\xB4', 
		'\x4', '\xB5', '\t', '\xB5', '\x4', '\xB6', '\t', '\xB6', '\x4', '\xB7', 
		'\t', '\xB7', '\x4', '\xB8', '\t', '\xB8', '\x4', '\xB9', '\t', '\xB9', 
		'\x4', '\xBA', '\t', '\xBA', '\x4', '\xBB', '\t', '\xBB', '\x4', '\xBC', 
		'\t', '\xBC', '\x4', '\xBD', '\t', '\xBD', '\x4', '\xBE', '\t', '\xBE', 
		'\x4', '\xBF', '\t', '\xBF', '\x4', '\xC0', '\t', '\xC0', '\x4', '\xC1', 
		'\t', '\xC1', '\x4', '\xC2', '\t', '\xC2', '\x4', '\xC3', '\t', '\xC3', 
		'\x4', '\xC4', '\t', '\xC4', '\x4', '\xC5', '\t', '\xC5', '\x3', '\x2', 
		'\a', '\x2', '\x18C', '\n', '\x2', '\f', '\x2', '\xE', '\x2', '\x18F', 
		'\v', '\x2', '\x3', '\x2', '\a', '\x2', '\x192', '\n', '\x2', '\f', '\x2', 
		'\xE', '\x2', '\x195', '\v', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x4', '\x3', 
		'\x4', '\a', '\x4', '\x19F', '\n', '\x4', '\f', '\x4', '\xE', '\x4', '\x1A2', 
		'\v', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\a', '\x4', '\x1A7', 
		'\n', '\x4', '\f', '\x4', '\xE', '\x4', '\x1AA', '\v', '\x4', '\x3', '\x4', 
		'\x3', '\x4', '\x3', '\x4', '\a', '\x4', '\x1AF', '\n', '\x4', '\f', '\x4', 
		'\xE', '\x4', '\x1B2', '\v', '\x4', '\x3', '\x4', '\x5', '\x4', '\x1B5', 
		'\n', '\x4', '\x3', '\x5', '\x6', '\x5', '\x1B8', '\n', '\x5', '\r', '\x5', 
		'\xE', '\x5', '\x1B9', '\x3', '\x5', '\x5', '\x5', '\x1BD', '\n', '\x5', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\x5', '\x6', '\x1C4', '\n', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\a', 
		'\x3', '\a', '\a', '\a', '\x1CA', '\n', '\a', '\f', '\a', '\xE', '\a', 
		'\x1CD', '\v', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', 
		'\x3', '\a', '\x3', '\a', '\x3', '\a', '\a', '\a', '\x1D6', '\n', '\a', 
		'\f', '\a', '\xE', '\a', '\x1D9', '\v', '\a', '\x3', '\a', '\x3', '\a', 
		'\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\a', 
		'\a', '\x1E2', '\n', '\a', '\f', '\a', '\xE', '\a', '\x1E5', '\v', '\a', 
		'\x3', '\a', '\x3', '\a', '\x5', '\a', '\x1E9', '\n', '\a', '\x3', '\b', 
		'\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\t', '\x3', 
		'\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', 
		'\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', 
		'\t', '\x3', '\t', '\x5', '\t', '\x1FE', '\n', '\t', '\x3', '\n', '\x3', 
		'\n', '\x3', '\n', '\a', '\n', '\x203', '\n', '\n', '\f', '\n', '\xE', 
		'\n', '\x206', '\v', '\n', '\x3', '\n', '\x5', '\n', '\x209', '\n', '\n', 
		'\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', 
		'\f', '\a', '\f', '\x211', '\n', '\f', '\f', '\f', '\xE', '\f', '\x214', 
		'\v', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\a', '\f', '\x219', 
		'\n', '\f', '\f', '\f', '\xE', '\f', '\x21C', '\v', '\f', '\x3', '\f', 
		'\x3', '\f', '\x3', '\f', '\a', '\f', '\x221', '\n', '\f', '\f', '\f', 
		'\xE', '\f', '\x224', '\v', '\f', '\x3', '\f', '\x5', '\f', '\x227', '\n', 
		'\f', '\x3', '\r', '\x6', '\r', '\x22A', '\n', '\r', '\r', '\r', '\xE', 
		'\r', '\x22B', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x5', 
		'\r', '\x232', '\n', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', 
		'\r', '\x3', '\r', '\x6', '\r', '\x239', '\n', '\r', '\r', '\r', '\xE', 
		'\r', '\x23A', '\x3', '\r', '\x3', '\r', '\x5', '\r', '\x23F', '\n', '\r', 
		'\x3', '\r', '\x3', '\r', '\x5', '\r', '\x243', '\n', '\r', '\x3', '\xE', 
		'\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x5', '\xE', '\x249', '\n', 
		'\xE', '\x3', '\xF', '\x3', '\xF', '\x3', '\x10', '\x3', '\x10', '\x3', 
		'\x10', '\x3', '\x10', '\x5', '\x10', '\x251', '\n', '\x10', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x12', '\x3', '\x12', '\x3', '\x13', '\a', '\x13', 
		'\x258', '\n', '\x13', '\f', '\x13', '\xE', '\x13', '\x25B', '\v', '\x13', 
		'\x3', '\x13', '\x3', '\x13', '\x5', '\x13', '\x25F', '\n', '\x13', '\x3', 
		'\x14', '\x5', '\x14', '\x262', '\n', '\x14', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x5', '\x14', '\x271', '\n', '\x14', '\x3', '\x15', '\x3', 
		'\x15', '\x5', '\x15', '\x275', '\n', '\x15', '\x3', '\x16', '\x5', '\x16', 
		'\x278', '\n', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x16', '\a', '\x16', '\x27F', '\n', '\x16', '\f', '\x16', 
		'\xE', '\x16', '\x282', '\v', '\x16', '\x3', '\x16', '\a', '\x16', '\x285', 
		'\n', '\x16', '\f', '\x16', '\xE', '\x16', '\x288', '\v', '\x16', '\x3', 
		'\x16', '\x5', '\x16', '\x28B', '\n', '\x16', '\x3', '\x17', '\x3', '\x17', 
		'\x3', '\x17', '\x3', '\x17', '\x5', '\x17', '\x291', '\n', '\x17', '\x3', 
		'\x17', '\x3', '\x17', '\x3', '\x18', '\x3', '\x18', '\x5', '\x18', '\x297', 
		'\n', '\x18', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x5', '\x19', 
		'\x29C', '\n', '\x19', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', 
		'\x1A', '\x3', '\x1B', '\x5', '\x1B', '\x2A3', '\n', '\x1B', '\x3', '\x1B', 
		'\x5', '\x1B', '\x2A6', '\n', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', 
		'\x1B', '\x3', '\x1B', '\x3', '\x1B', '\a', '\x1B', '\x2AD', '\n', '\x1B', 
		'\f', '\x1B', '\xE', '\x1B', '\x2B0', '\v', '\x1B', '\x3', '\x1B', '\x5', 
		'\x1B', '\x2B3', '\n', '\x1B', '\x5', '\x1B', '\x2B5', '\n', '\x1B', '\x3', 
		'\x1B', '\x5', '\x1B', '\x2B8', '\n', '\x1B', '\x3', '\x1B', '\x3', '\x1B', 
		'\x3', '\x1B', '\x3', '\x1B', '\x5', '\x1B', '\x2BE', '\n', '\x1B', '\x5', 
		'\x1B', '\x2C0', '\n', '\x1B', '\x5', '\x1B', '\x2C2', '\n', '\x1B', '\x3', 
		'\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x5', '\x1C', '\x2C8', 
		'\n', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x5', '\x1C', '\x2CC', '\n', 
		'\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x5', '\x1C', '\x2D0', '\n', '\x1C', 
		'\x3', '\x1C', '\x5', '\x1C', '\x2D3', '\n', '\x1C', '\x3', '\x1C', '\x3', 
		'\x1C', '\x5', '\x1C', '\x2D7', '\n', '\x1C', '\x3', '\x1D', '\x5', '\x1D', 
		'\x2DA', '\n', '\x1D', '\x3', '\x1D', '\x5', '\x1D', '\x2DD', '\n', '\x1D', 
		'\x3', '\x1D', '\x5', '\x1D', '\x2E0', '\n', '\x1D', '\x3', '\x1D', '\x3', 
		'\x1D', '\x5', '\x1D', '\x2E4', '\n', '\x1D', '\x5', '\x1D', '\x2E6', 
		'\n', '\x1D', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1F', '\x3', '\x1F', 
		'\x5', '\x1F', '\x2EC', '\n', '\x1F', '\x3', '\x1F', '\x3', '\x1F', '\x3', 
		'\x1F', '\x5', '\x1F', '\x2F1', '\n', '\x1F', '\x3', '\x1F', '\x3', '\x1F', 
		'\x3', '\x1F', '\a', '\x1F', '\x2F6', '\n', '\x1F', '\f', '\x1F', '\xE', 
		'\x1F', '\x2F9', '\v', '\x1F', '\x3', '\x1F', '\x5', '\x1F', '\x2FC', 
		'\n', '\x1F', '\x5', '\x1F', '\x2FE', '\n', '\x1F', '\x3', ' ', '\a', 
		' ', '\x301', '\n', ' ', '\f', ' ', '\xE', ' ', '\x304', '\v', ' ', '\x3', 
		' ', '\x3', ' ', '\x5', ' ', '\x308', '\n', ' ', '\x3', '!', '\x3', '!', 
		'\x5', '!', '\x30C', '\n', '!', '\x5', '!', '\x30E', '\n', '!', '\x3', 
		'!', '\x5', '!', '\x311', '\n', '!', '\x3', '!', '\x3', '!', '\x3', '\"', 
		'\x5', '\"', '\x316', '\n', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', 
		'\x3', '\"', '\x3', '#', '\a', '#', '\x31D', '\n', '#', '\f', '#', '\xE', 
		'#', '\x320', '\v', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x5', '#', 
		'\x325', '\n', '#', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x5', 
		'$', '\x32B', '\n', '$', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '&', 
		'\x3', '&', '\x3', '&', '\x5', '&', '\x333', '\n', '&', '\x3', '&', '\x5', 
		'&', '\x336', '\n', '&', '\x3', '&', '\x3', '&', '\x5', '&', '\x33A', 
		'\n', '&', '\x3', '&', '\x3', '&', '\x3', '\'', '\x3', '\'', '\x5', '\'', 
		'\x340', '\n', '\'', '\x3', '(', '\x3', '(', '\x3', '(', '\x5', '(', '\x345', 
		'\n', '(', '\x3', '(', '\x5', '(', '\x348', '\n', '(', '\x3', '(', '\x3', 
		'(', '\x5', '(', '\x34C', '\n', '(', '\x3', '(', '\x3', '(', '\x5', '(', 
		'\x350', '\n', '(', '\x3', ')', '\x3', ')', '\x3', ')', '\x5', ')', '\x355', 
		'\n', ')', '\x3', ')', '\x3', ')', '\x5', ')', '\x359', '\n', ')', '\x3', 
		')', '\x3', ')', '\x5', ')', '\x35D', '\n', ')', '\x3', ')', '\x3', ')', 
		'\x3', '*', '\x3', '*', '\x3', '*', '\a', '*', '\x364', '\n', '*', '\f', 
		'*', '\xE', '*', '\x367', '\v', '*', '\x3', '*', '\x5', '*', '\x36A', 
		'\n', '*', '\x3', '+', '\a', '+', '\x36D', '\n', '+', '\f', '+', '\xE', 
		'+', '\x370', '\v', '+', '\x3', '+', '\x5', '+', '\x373', '\n', '+', '\x3', 
		'+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', ',', '\x3', ',', '\x3', 
		',', '\a', ',', '\x37C', '\n', ',', '\f', ',', '\xE', ',', '\x37F', '\v', 
		',', '\x3', ',', '\x5', ',', '\x382', '\n', ',', '\x3', '-', '\a', '-', 
		'\x385', '\n', '-', '\f', '-', '\xE', '-', '\x388', '\v', '-', '\x3', 
		'-', '\x5', '-', '\x38B', '\n', '-', '\x3', '-', '\x3', '-', '\x3', '.', 
		'\x3', '.', '\x3', '.', '\x5', '.', '\x392', '\n', '.', '\x3', '.', '\x5', 
		'.', '\x395', '\n', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x399', 
		'\n', '.', '\x3', '.', '\x3', '.', '\x3', '/', '\x3', '/', '\x3', '/', 
		'\a', '/', '\x3A0', '\n', '/', '\f', '/', '\xE', '/', '\x3A3', '\v', '/', 
		'\x3', '/', '\x5', '/', '\x3A6', '\n', '/', '\x3', '\x30', '\a', '\x30', 
		'\x3A9', '\n', '\x30', '\f', '\x30', '\xE', '\x30', '\x3AC', '\v', '\x30', 
		'\x3', '\x30', '\x5', '\x30', '\x3AF', '\n', '\x30', '\x3', '\x30', '\x3', 
		'\x30', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', '\x3B5', '\n', '\x30', 
		'\x3', '\x31', '\x3', '\x31', '\x5', '\x31', '\x3B9', '\n', '\x31', '\x3', 
		'\x31', '\x3', '\x31', '\x3', '\x32', '\x3', '\x32', '\x5', '\x32', '\x3BF', 
		'\n', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x33', '\x3', '\x33', 
		'\x3', '\x33', '\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x5', '\x34', 
		'\x3C9', '\n', '\x34', '\x3', '\x34', '\x5', '\x34', '\x3CC', '\n', '\x34', 
		'\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x3', '\x35', 
		'\x3', '\x35', '\x3', '\x35', '\x5', '\x35', '\x3D5', '\n', '\x35', '\x3', 
		'\x35', '\x3', '\x35', '\x3', '\x35', '\x3', '\x35', '\x5', '\x35', '\x3DB', 
		'\n', '\x35', '\x3', '\x35', '\x3', '\x35', '\x3', '\x36', '\x3', '\x36', 
		'\x5', '\x36', '\x3E1', '\n', '\x36', '\x3', '\x36', '\x3', '\x36', '\x3', 
		'\x36', '\x3', '\x36', '\x3', '\x36', '\x5', '\x36', '\x3E8', '\n', '\x36', 
		'\x3', '\x36', '\x3', '\x36', '\x3', '\x37', '\x5', '\x37', '\x3ED', '\n', 
		'\x37', '\x3', '\x37', '\x3', '\x37', '\x3', '\x37', '\x5', '\x37', '\x3F2', 
		'\n', '\x37', '\x3', '\x37', '\x3', '\x37', '\x5', '\x37', '\x3F6', '\n', 
		'\x37', '\x5', '\x37', '\x3F8', '\n', '\x37', '\x3', '\x37', '\x5', '\x37', 
		'\x3FB', '\n', '\x37', '\x3', '\x37', '\x3', '\x37', '\a', '\x37', '\x3FF', 
		'\n', '\x37', '\f', '\x37', '\xE', '\x37', '\x402', '\v', '\x37', '\x3', 
		'\x37', '\a', '\x37', '\x405', '\n', '\x37', '\f', '\x37', '\xE', '\x37', 
		'\x408', '\v', '\x37', '\x3', '\x37', '\x3', '\x37', '\x3', '\x38', '\x3', 
		'\x38', '\x5', '\x38', '\x40E', '\n', '\x38', '\x3', '\x39', '\x3', '\x39', 
		'\x5', '\x39', '\x412', '\n', '\x39', '\x3', '\x39', '\x3', '\x39', '\x5', 
		'\x39', '\x416', '\n', '\x39', '\x3', '\x39', '\x3', '\x39', '\a', '\x39', 
		'\x41A', '\n', '\x39', '\f', '\x39', '\xE', '\x39', '\x41D', '\v', '\x39', 
		'\x3', '\x39', '\a', '\x39', '\x420', '\n', '\x39', '\f', '\x39', '\xE', 
		'\x39', '\x423', '\v', '\x39', '\x3', '\x39', '\x3', '\x39', '\x3', ':', 
		'\x5', ':', '\x428', '\n', ':', '\x3', ':', '\x3', ':', '\x5', ':', '\x42C', 
		'\n', ':', '\x3', ':', '\x5', ':', '\x42F', '\n', ':', '\x3', ':', '\x3', 
		':', '\x3', ':', '\x3', ':', '\x5', ':', '\x435', '\n', ':', '\x3', ':', 
		'\x3', ':', '\a', ':', '\x439', '\n', ':', '\f', ':', '\xE', ':', '\x43C', 
		'\v', ':', '\x3', ':', '\a', ':', '\x43F', '\n', ':', '\f', ':', '\xE', 
		':', '\x442', '\v', ':', '\x3', ':', '\x3', ':', '\x3', ';', '\x5', ';', 
		'\x447', '\n', ';', '\x3', ';', '\x3', ';', '\x5', ';', '\x44B', '\n', 
		';', '\x3', ';', '\x3', ';', '\a', ';', '\x44F', '\n', ';', '\f', ';', 
		'\xE', ';', '\x452', '\v', ';', '\x3', ';', '\a', ';', '\x455', '\n', 
		';', '\f', ';', '\xE', ';', '\x458', '\v', ';', '\x3', ';', '\x3', ';', 
		'\x3', '<', '\a', '<', '\x45D', '\n', '<', '\f', '<', '\xE', '<', '\x460', 
		'\v', '<', '\x3', '<', '\x3', '<', '\x5', '<', '\x464', '\n', '<', '\x3', 
		'<', '\x3', '<', '\x5', '<', '\x468', '\n', '<', '\x5', '<', '\x46A', 
		'\n', '<', '\x3', '=', '\x3', '=', '\x3', '=', '\x3', '=', '\a', '=', 
		'\x470', '\n', '=', '\f', '=', '\xE', '=', '\x473', '\v', '=', '\x3', 
		'=', '\x3', '=', '\x5', '=', '\x477', '\n', '=', '\x5', '=', '\x479', 
		'\n', '=', '\x3', '=', '\x3', '=', '\x3', '>', '\a', '>', '\x47E', '\n', 
		'>', '\f', '>', '\xE', '>', '\x481', '\v', '>', '\x3', '>', '\x3', '>', 
		'\x3', '>', '\x5', '>', '\x486', '\n', '>', '\x3', '?', '\x5', '?', '\x489', 
		'\n', '?', '\x3', '?', '\x3', '?', '\x3', '?', '\x5', '?', '\x48E', '\n', 
		'?', '\x3', '@', '\x5', '@', '\x491', '\n', '@', '\x3', '@', '\x3', '@', 
		'\x3', '@', '\x5', '@', '\x496', '\n', '@', '\x5', '@', '\x498', '\n', 
		'@', '\x3', '@', '\x3', '@', '\x5', '@', '\x49C', '\n', '@', '\x3', '\x41', 
		'\x3', '\x41', '\x3', '\x41', '\x3', '\x41', '\x3', '\x41', '\x3', '\x42', 
		'\x3', '\x42', '\x3', '\x42', '\x3', '\x42', '\a', '\x42', '\x4A7', '\n', 
		'\x42', '\f', '\x42', '\xE', '\x42', '\x4AA', '\v', '\x42', '\x3', '\x42', 
		'\x5', '\x42', '\x4AD', '\n', '\x42', '\x3', '\x43', '\x3', '\x43', '\x5', 
		'\x43', '\x4B1', '\n', '\x43', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', 
		'\x3', '\x44', '\x3', '\x45', '\x5', '\x45', '\x4B8', '\n', '\x45', '\x3', 
		'\x45', '\x3', '\x45', '\x3', '\x45', '\x5', '\x45', '\x4BD', '\n', '\x45', 
		'\x3', '\x46', '\x3', '\x46', '\x3', '\x46', '\x3', 'G', '\a', 'G', '\x4C3', 
		'\n', 'G', '\f', 'G', '\xE', 'G', '\x4C6', '\v', 'G', '\x3', 'G', '\x3', 
		'G', '\x5', 'G', '\x4CA', '\n', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'G', 
		'\x5', 'G', '\x4CF', '\n', 'G', '\x5', 'G', '\x4D1', '\n', 'G', '\x3', 
		'H', '\x3', 'H', '\x3', 'H', '\x3', 'H', '\x3', 'H', '\x3', 'H', '\x3', 
		'I', '\x3', 'I', '\x3', 'I', '\x3', 'I', '\x3', 'I', '\x3', 'J', '\x3', 
		'J', '\x5', 'J', '\x4E0', '\n', 'J', '\x3', 'K', '\x3', 'K', '\x3', 'K', 
		'\x5', 'K', '\x4E5', '\n', 'K', '\x3', 'L', '\x3', 'L', '\x3', 'L', '\x3', 
		'L', '\x3', 'L', '\x5', 'L', '\x4EC', '\n', 'L', '\x3', 'M', '\a', 'M', 
		'\x4EF', '\n', 'M', '\f', 'M', '\xE', 'M', '\x4F2', '\v', 'M', '\x3', 
		'M', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x5', 'M', '\x4F8', '\n', 'M', 
		'\x3', 'M', '\x3', 'M', '\x5', 'M', '\x4FC', '\n', 'M', '\x3', 'M', '\x3', 
		'M', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x5', 
		'N', '\x505', '\n', 'N', '\x5', 'N', '\x507', '\n', 'N', '\x3', 'O', '\x3', 
		'O', '\x6', 'O', '\x50B', '\n', 'O', '\r', 'O', '\xE', 'O', '\x50C', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x5', 
		'O', '\x515', '\n', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', 
		'\x3', 'O', '\x3', 'O', '\x3', 'O', '\x5', 'O', '\x51E', '\n', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x5', 'O', '\x524', '\n', 'O', 
		'\x3', 'O', '\x5', 'O', '\x527', '\n', 'O', '\x3', 'O', '\x3', 'O', '\x5', 
		'O', '\x52B', '\n', 'O', '\x3', 'O', '\x5', 'O', '\x52E', '\n', 'O', '\x3', 
		'O', '\x3', 'O', '\x5', 'O', '\x532', '\n', 'O', '\x3', 'O', '\x3', 'O', 
		'\a', 'O', '\x536', '\n', 'O', '\f', 'O', '\xE', 'O', '\x539', '\v', 'O', 
		'\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\a', 'O', 
		'\x540', '\n', 'O', '\f', 'O', '\xE', 'O', '\x543', '\v', 'O', '\x3', 
		'O', '\x5', 'O', '\x546', '\n', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', 
		'\a', 'O', '\x54B', '\n', 'O', '\f', 'O', '\xE', 'O', '\x54E', '\v', 'O', 
		'\x3', 'O', '\x5', 'O', '\x551', '\n', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x5', 'O', '\x559', '\n', 'O', 
		'\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', 
		'\x3', 'O', '\x3', 'O', '\x3', 'O', '\x5', 'O', '\x564', '\n', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x5', 
		'O', '\x58A', '\n', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', 
		'\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', 
		'\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x5', 'O', '\x59A', '\n', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x5', 'O', '\x5AA', '\n', 'O', '\a', 'O', 
		'\x5AC', '\n', 'O', '\f', 'O', '\xE', 'O', '\x5AF', '\v', 'O', '\x3', 
		'P', '\x3', 'P', '\x3', 'Q', '\x3', 'Q', '\x3', 'R', '\x6', 'R', '\x5B6', 
		'\n', 'R', '\r', 'R', '\xE', 'R', '\x5B7', '\x3', 'R', '\x3', 'R', '\x3', 
		'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 
		'R', '\x5', 'R', '\x5C3', '\n', 'R', '\x3', 'S', '\x3', 'S', '\x3', 'T', 
		'\x3', 'T', '\x5', 'T', '\x5C9', '\n', 'T', '\x3', 'U', '\x3', 'U', '\a', 
		'U', '\x5CD', '\n', 'U', '\f', 'U', '\xE', 'U', '\x5D0', '\v', 'U', '\x3', 
		'U', '\x5', 'U', '\x5D3', '\n', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'V', 
		'\x6', 'V', '\x5D8', '\n', 'V', '\r', 'V', '\xE', 'V', '\x5D9', '\x3', 
		'V', '\x5', 'V', '\x5DD', '\n', 'V', '\x3', 'V', '\x5', 'V', '\x5E0', 
		'\n', 'V', '\x3', 'W', '\x3', 'W', '\x5', 'W', '\x5E4', '\n', 'W', '\x3', 
		'W', '\x3', 'W', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'Y', '\x3', 
		'Y', '\x3', 'Y', '\a', 'Y', '\x5EE', '\n', 'Y', '\f', 'Y', '\xE', 'Y', 
		'\x5F1', '\v', 'Y', '\x3', 'Y', '\x5', 'Y', '\x5F4', '\n', 'Y', '\x3', 
		'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x5', 'Y', '\x5FA', '\n', 'Y', 
		'\x3', 'Z', '\x3', 'Z', '\x3', 'Z', '\x6', 'Z', '\x5FF', '\n', 'Z', '\r', 
		'Z', '\xE', 'Z', '\x600', '\x3', 'Z', '\x5', 'Z', '\x604', '\n', 'Z', 
		'\x3', '[', '\x3', '[', '\x3', '\\', '\x3', '\\', '\x3', '\\', '\x5', 
		'\\', '\x60B', '\n', '\\', '\x3', ']', '\x3', ']', '\x3', ']', '\a', ']', 
		'\x610', '\n', ']', '\f', ']', '\xE', ']', '\x613', '\v', ']', '\x3', 
		']', '\x3', ']', '\x5', ']', '\x617', '\n', ']', '\x3', ']', '\x3', ']', 
		'\x3', '^', '\x3', '^', '\x3', '^', '\a', '^', '\x61E', '\n', '^', '\f', 
		'^', '\xE', '^', '\x621', '\v', '^', '\x3', '^', '\x3', '^', '\x3', '^', 
		'\x5', '^', '\x626', '\n', '^', '\x5', '^', '\x628', '\n', '^', '\x3', 
		'_', '\a', '_', '\x62B', '\n', '_', '\f', '_', '\xE', '_', '\x62E', '\v', 
		'_', '\x3', '_', '\x3', '_', '\x3', '_', '\x5', '_', '\x633', '\n', '_', 
		'\x3', '_', '\x3', '_', '\x3', '_', '\x5', '_', '\x638', '\n', '_', '\x3', 
		'`', '\x3', '`', '\x3', '`', '\x3', '\x61', '\x3', '\x61', '\x3', '\x61', 
		'\a', '\x61', '\x640', '\n', '\x61', '\f', '\x61', '\xE', '\x61', '\x643', 
		'\v', '\x61', '\x3', '\x61', '\x3', '\x61', '\x3', '\x61', '\a', '\x61', 
		'\x648', '\n', '\x61', '\f', '\x61', '\xE', '\x61', '\x64B', '\v', '\x61', 
		'\x3', '\x61', '\x5', '\x61', '\x64E', '\n', '\x61', '\x5', '\x61', '\x650', 
		'\n', '\x61', '\x3', '\x61', '\x3', '\x61', '\x3', '\x62', '\x3', '\x62', 
		'\x3', '\x63', '\x3', '\x63', '\x3', '\x63', '\x5', '\x63', '\x659', '\n', 
		'\x63', '\x3', '\x64', '\x3', '\x64', '\x3', '\x64', '\x5', '\x64', '\x65E', 
		'\n', '\x64', '\x3', '\x64', '\x3', '\x64', '\x3', '\x65', '\x3', '\x65', 
		'\x3', '\x65', '\a', '\x65', '\x665', '\n', '\x65', '\f', '\x65', '\xE', 
		'\x65', '\x668', '\v', '\x65', '\x3', '\x65', '\x5', '\x65', '\x66B', 
		'\n', '\x65', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x5', '\x66', 
		'\x670', '\n', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x5', 
		'\x66', '\x675', '\n', '\x66', '\x3', 'g', '\x3', 'g', '\x3', 'g', '\x3', 
		'g', '\x3', 'g', '\a', 'g', '\x67C', '\n', 'g', '\f', 'g', '\xE', 'g', 
		'\x67F', '\v', 'g', '\x3', 'g', '\x5', 'g', '\x682', '\n', 'g', '\x5', 
		'g', '\x684', '\n', 'g', '\x3', 'g', '\x3', 'g', '\x3', 'h', '\x3', 'h', 
		'\x3', 'i', '\x3', 'i', '\x3', 'i', '\a', 'i', '\x68D', '\n', 'i', '\f', 
		'i', '\xE', 'i', '\x690', '\v', 'i', '\x3', 'i', '\x5', 'i', '\x693', 
		'\n', 'i', '\x3', 'j', '\x5', 'j', '\x696', '\n', 'j', '\x3', 'j', '\x3', 
		'j', '\x3', 'j', '\x5', 'j', '\x69B', '\n', 'j', '\x3', 'j', '\x5', 'j', 
		'\x69E', '\n', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 'j', '\x3', 
		'j', '\x5', 'j', '\x6A5', '\n', 'j', '\x3', 'k', '\x3', 'k', '\x3', 'k', 
		'\a', 'k', '\x6AA', '\n', 'k', '\f', 'k', '\xE', 'k', '\x6AD', '\v', 'k', 
		'\x3', 'k', '\x5', 'k', '\x6B0', '\n', 'k', '\x3', 'l', '\a', 'l', '\x6B3', 
		'\n', 'l', '\f', 'l', '\xE', 'l', '\x6B6', '\v', 'l', '\x3', 'l', '\x3', 
		'l', '\x3', 'l', '\x5', 'l', '\x6BB', '\n', 'l', '\x3', 'm', '\x5', 'm', 
		'\x6BE', '\n', 'm', '\x3', 'm', '\x3', 'm', '\x3', 'm', '\x3', 'm', '\x5', 
		'm', '\x6C4', '\n', 'm', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x3', 'o', 
		'\x3', 'o', '\x3', 'o', '\x3', 'o', '\x3', 'p', '\x3', 'p', '\x3', 'p', 
		'\x3', 'p', '\x3', 'p', '\x3', 'p', '\x3', 'p', '\x3', 'q', '\x3', 'q', 
		'\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'r', '\x3', 'r', 
		'\x3', 'r', '\x3', 's', '\x3', 's', '\x3', 's', '\x3', 's', '\x3', 's', 
		'\x3', 's', '\x3', 's', '\x5', 's', '\x6E4', '\n', 's', '\x5', 's', '\x6E6', 
		'\n', 's', '\x3', 't', '\x3', 't', '\x3', 't', '\x3', 't', '\x3', 't', 
		'\x3', 't', '\x3', 't', '\x3', 't', '\x3', 't', '\x3', 't', '\x5', 't', 
		'\x6F2', '\n', 't', '\x5', 't', '\x6F4', '\n', 't', '\x3', 'u', '\x3', 
		'u', '\x3', 'u', '\x3', 'u', '\a', 'u', '\x6FA', '\n', 'u', '\f', 'u', 
		'\xE', 'u', '\x6FD', '\v', 'u', '\x3', 'u', '\x5', 'u', '\x700', '\n', 
		'u', '\x3', 'u', '\x3', 'u', '\x3', 'v', '\x3', 'v', '\x3', 'v', '\x3', 
		'v', '\a', 'v', '\x708', '\n', 'v', '\f', 'v', '\xE', 'v', '\x70B', '\v', 
		'v', '\x3', 'v', '\x3', 'v', '\x3', 'v', '\x3', 'v', '\x5', 'v', '\x711', 
		'\n', 'v', '\x3', 'w', '\x3', 'w', '\x3', 'w', '\x3', 'w', '\x3', 'w', 
		'\x5', 'w', '\x718', '\n', 'w', '\x5', 'w', '\x71A', '\n', 'w', '\x3', 
		'x', '\a', 'x', '\x71D', '\n', 'x', '\f', 'x', '\xE', 'x', '\x720', '\v', 
		'x', '\x3', 'x', '\x3', 'x', '\x5', 'x', '\x724', '\n', 'x', '\x3', 'y', 
		'\x3', 'y', '\x3', 'y', '\x3', 'z', '\x5', 'z', '\x72A', '\n', 'z', '\x3', 
		'z', '\x3', 'z', '\x3', 'z', '\a', 'z', '\x72F', '\n', 'z', '\f', 'z', 
		'\xE', 'z', '\x732', '\v', 'z', '\x3', '{', '\x3', '{', '\x5', '{', '\x736', 
		'\n', '{', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', 
		'\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', 
		'\x3', '|', '\x5', '|', '\x744', '\n', '|', '\x3', '}', '\x3', '}', '\x3', 
		'}', '\x3', '}', '\x3', '}', '\x3', '}', '\x3', '}', '\x3', '}', '\x3', 
		'}', '\x5', '}', '\x74F', '\n', '}', '\x3', '}', '\x3', '}', '\x5', '}', 
		'\x753', '\n', '}', '\x3', '}', '\x5', '}', '\x756', '\n', '}', '\x3', 
		'~', '\x5', '~', '\x759', '\n', '~', '\x3', '~', '\x5', '~', '\x75C', 
		'\n', '~', '\x3', '~', '\x3', '~', '\x3', '~', '\x5', '~', '\x761', '\n', 
		'~', '\x3', '\x7F', '\x3', '\x7F', '\x3', '\x80', '\x3', '\x80', '\x3', 
		'\x81', '\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x3', 
		'\x81', '\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x3', 
		'\x81', '\x5', '\x81', '\x772', '\n', '\x81', '\x3', '\x82', '\x3', '\x82', 
		'\x3', '\x82', '\x5', '\x82', '\x777', '\n', '\x82', '\x3', '\x82', '\x3', 
		'\x82', '\x5', '\x82', '\x77B', '\n', '\x82', '\x3', '\x82', '\x3', '\x82', 
		'\x5', '\x82', '\x77F', '\n', '\x82', '\x3', '\x83', '\x3', '\x83', '\x5', 
		'\x83', '\x783', '\n', '\x83', '\x3', '\x83', '\x3', '\x83', '\x3', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x5', '\x84', '\x78A', '\n', '\x84', '\x3', 
		'\x84', '\x3', '\x84', '\x3', '\x85', '\x3', '\x85', '\x3', '\x85', '\x5', 
		'\x85', '\x791', '\n', '\x85', '\x5', '\x85', '\x793', '\n', '\x85', '\x3', 
		'\x85', '\x5', '\x85', '\x796', '\n', '\x85', '\x3', '\x86', '\x3', '\x86', 
		'\x3', '\x86', '\a', '\x86', '\x79B', '\n', '\x86', '\f', '\x86', '\xE', 
		'\x86', '\x79E', '\v', '\x86', '\x3', '\x87', '\a', '\x87', '\x7A1', '\n', 
		'\x87', '\f', '\x87', '\xE', '\x87', '\x7A4', '\v', '\x87', '\x3', '\x87', 
		'\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', 
		'\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x5', '\x87', '\x7AF', '\n', 
		'\x87', '\x3', '\x87', '\x5', '\x87', '\x7B2', '\n', '\x87', '\x3', '\x87', 
		'\x5', '\x87', '\x7B5', '\n', '\x87', '\x3', '\x88', '\a', '\x88', '\x7B8', 
		'\n', '\x88', '\f', '\x88', '\xE', '\x88', '\x7BB', '\v', '\x88', '\x3', 
		'\x88', '\x3', '\x88', '\x3', '\x89', '\x3', '\x89', '\x3', '\x89', '\x5', 
		'\x89', '\x7C2', '\n', '\x89', '\x3', '\x89', '\x3', '\x89', '\x3', '\x8A', 
		'\x3', '\x8A', '\x3', '\x8A', '\a', '\x8A', '\x7C9', '\n', '\x8A', '\f', 
		'\x8A', '\xE', '\x8A', '\x7CC', '\v', '\x8A', '\x3', '\x8A', '\x5', '\x8A', 
		'\x7CF', '\n', '\x8A', '\x3', '\x8B', '\x3', '\x8B', '\x5', '\x8B', '\x7D3', 
		'\n', '\x8B', '\x3', '\x8B', '\x3', '\x8B', '\x3', '\x8C', '\x3', '\x8C', 
		'\x3', '\x8C', '\x3', '\x8C', '\x3', '\x8C', '\x3', '\x8C', '\x3', '\x8C', 
		'\x6', '\x8C', '\x7DE', '\n', '\x8C', '\r', '\x8C', '\xE', '\x8C', '\x7DF', 
		'\x3', '\x8C', '\x5', '\x8C', '\x7E3', '\n', '\x8C', '\x5', '\x8C', '\x7E5', 
		'\n', '\x8C', '\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8D', 
		'\x3', '\x8E', '\x3', '\x8E', '\x5', '\x8E', '\x7ED', '\n', '\x8E', '\x3', 
		'\x8E', '\x3', '\x8E', '\x3', '\x8F', '\x3', '\x8F', '\x3', '\x8F', '\a', 
		'\x8F', '\x7F4', '\n', '\x8F', '\f', '\x8F', '\xE', '\x8F', '\x7F7', '\v', 
		'\x8F', '\x3', '\x8F', '\x5', '\x8F', '\x7FA', '\n', '\x8F', '\x3', '\x90', 
		'\x3', '\x90', '\x5', '\x90', '\x7FE', '\n', '\x90', '\x3', '\x91', '\x3', 
		'\x91', '\x3', '\x91', '\x5', '\x91', '\x803', '\n', '\x91', '\x3', '\x92', 
		'\x3', '\x92', '\x3', '\x92', '\x3', '\x92', '\x3', '\x92', '\x3', '\x92', 
		'\x3', '\x92', '\x3', '\x92', '\x3', '\x92', '\x3', '\x92', '\x3', '\x92', 
		'\x3', '\x92', '\x3', '\x92', '\x3', '\x92', '\x5', '\x92', '\x813', '\n', 
		'\x92', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', '\x3', 
		'\x94', '\x3', '\x94', '\x3', '\x95', '\x3', '\x95', '\x3', '\x95', '\x3', 
		'\x95', '\x6', '\x95', '\x81F', '\n', '\x95', '\r', '\x95', '\xE', '\x95', 
		'\x820', '\x3', '\x95', '\x5', '\x95', '\x824', '\n', '\x95', '\x5', '\x95', 
		'\x826', '\n', '\x95', '\x3', '\x95', '\x3', '\x95', '\x3', '\x96', '\x3', 
		'\x96', '\x3', '\x96', '\x3', '\x96', '\x3', '\x96', '\x3', '\x96', '\x3', 
		'\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x98', '\x3', 
		'\x98', '\x5', '\x98', '\x836', '\n', '\x98', '\x3', '\x98', '\x5', '\x98', 
		'\x839', '\n', '\x98', '\x3', '\x98', '\x3', '\x98', '\x3', '\x99', '\x3', 
		'\x99', '\x3', '\x99', '\x3', '\x99', '\x3', '\x9A', '\x5', '\x9A', '\x842', 
		'\n', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9A', 
		'\x5', '\x9A', '\x848', '\n', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x5', 
		'\x9A', '\x84C', '\n', '\x9A', '\x3', '\x9B', '\x5', '\x9B', '\x84F', 
		'\n', '\x9B', '\x3', '\x9B', '\x3', '\x9B', '\x5', '\x9B', '\x853', '\n', 
		'\x9B', '\x5', '\x9B', '\x855', '\n', '\x9B', '\x3', '\x9C', '\x3', '\x9C', 
		'\x3', '\x9C', '\x3', '\x9D', '\x3', '\x9D', '\x5', '\x9D', '\x85C', '\n', 
		'\x9D', '\x3', '\x9E', '\x3', '\x9E', '\x3', '\x9E', '\a', '\x9E', '\x861', 
		'\n', '\x9E', '\f', '\x9E', '\xE', '\x9E', '\x864', '\v', '\x9E', '\x3', 
		'\x9E', '\x5', '\x9E', '\x867', '\n', '\x9E', '\x3', '\x9F', '\a', '\x9F', 
		'\x86A', '\n', '\x9F', '\f', '\x9F', '\xE', '\x9F', '\x86D', '\v', '\x9F', 
		'\x3', '\x9F', '\x3', '\x9F', '\x5', '\x9F', '\x871', '\n', '\x9F', '\x3', 
		'\x9F', '\x5', '\x9F', '\x874', '\n', '\x9F', '\x3', '\x9F', '\x3', '\x9F', 
		'\x3', '\xA0', '\x3', '\xA0', '\x3', '\xA0', '\a', '\xA0', '\x87B', '\n', 
		'\xA0', '\f', '\xA0', '\xE', '\xA0', '\x87E', '\v', '\xA0', '\x3', '\xA0', 
		'\x3', '\xA0', '\x3', '\xA0', '\a', '\xA0', '\x883', '\n', '\xA0', '\f', 
		'\xA0', '\xE', '\xA0', '\x886', '\v', '\xA0', '\x3', '\xA0', '\x3', '\xA0', 
		'\x3', '\xA1', '\x5', '\xA1', '\x88B', '\n', '\xA1', '\x3', '\xA1', '\x3', 
		'\xA1', '\x3', '\xA2', '\x5', '\xA2', '\x890', '\n', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA3', '\x3', '\xA3', '\x3', '\xA3', '\x3', '\xA4', 
		'\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA6', 
		'\x3', '\xA6', '\x3', '\xA6', '\a', '\xA6', '\x89F', '\n', '\xA6', '\f', 
		'\xA6', '\xE', '\xA6', '\x8A2', '\v', '\xA6', '\x3', '\xA6', '\x5', '\xA6', 
		'\x8A5', '\n', '\xA6', '\x3', '\xA7', '\x3', '\xA7', '\x5', '\xA7', '\x8A9', 
		'\n', '\xA7', '\x3', '\xA8', '\x5', '\xA8', '\x8AC', '\n', '\xA8', '\x3', 
		'\xA8', '\x5', '\xA8', '\x8AF', '\n', '\xA8', '\x3', '\xA8', '\x3', '\xA8', 
		'\x3', '\xA8', '\x5', '\xA8', '\x8B4', '\n', '\xA8', '\x3', '\xA8', '\x5', 
		'\xA8', '\x8B7', '\n', '\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', 
		'\x5', '\xA8', '\x8BC', '\n', '\xA8', '\x3', '\xA9', '\x3', '\xA9', '\x3', 
		'\xA9', '\a', '\xA9', '\x8C1', '\n', '\xA9', '\f', '\xA9', '\xE', '\xA9', 
		'\x8C4', '\v', '\xA9', '\x3', '\xA9', '\x5', '\xA9', '\x8C7', '\n', '\xA9', 
		'\x3', '\xAA', '\x3', '\xAA', '\x3', '\xAB', '\x5', '\xAB', '\x8CC', '\n', 
		'\xAB', '\x3', '\xAB', '\x3', '\xAB', '\x3', '\xAB', '\a', '\xAB', '\x8D1', 
		'\n', '\xAB', '\f', '\xAB', '\xE', '\xAB', '\x8D4', '\v', '\xAB', '\x3', 
		'\xAC', '\x3', '\xAC', '\x3', '\xAC', '\x3', '\xAC', '\x3', '\xAC', '\x5', 
		'\xAC', '\x8DB', '\n', '\xAC', '\x3', '\xAD', '\x5', '\xAD', '\x8DE', 
		'\n', '\xAD', '\x3', '\xAD', '\x3', '\xAD', '\x3', '\xAD', '\a', '\xAD', 
		'\x8E3', '\n', '\xAD', '\f', '\xAD', '\xE', '\xAD', '\x8E6', '\v', '\xAD', 
		'\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x5', '\xAE', '\x8EB', '\n', 
		'\xAE', '\x3', '\xAF', '\x3', '\xAF', '\x3', '\xAF', '\x3', '\xAF', '\x3', 
		'\xAF', '\x3', '\xAF', '\x5', '\xAF', '\x8F3', '\n', '\xAF', '\x3', '\xB0', 
		'\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', 
		'\x5', '\xB0', '\x8FB', '\n', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x5', 
		'\xB0', '\x8FF', '\n', '\xB0', '\x3', '\xB0', '\x5', '\xB0', '\x902', 
		'\n', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', 
		'\x3', '\xB0', '\x3', '\xB0', '\x5', '\xB0', '\x90A', '\n', '\xB0', '\x3', 
		'\xB0', '\x5', '\xB0', '\x90D', '\n', '\xB0', '\x3', '\xB0', '\x3', '\xB0', 
		'\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\a', '\xB0', 
		'\x915', '\n', '\xB0', '\f', '\xB0', '\xE', '\xB0', '\x918', '\v', '\xB0', 
		'\x3', '\xB0', '\x3', '\xB0', '\x5', '\xB0', '\x91C', '\n', '\xB0', '\x3', 
		'\xB0', '\x3', '\xB0', '\x5', '\xB0', '\x920', '\n', '\xB0', '\x3', '\xB1', 
		'\x3', '\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x5', '\xB1', '\x926', '\n', 
		'\xB1', '\x3', '\xB2', '\x3', '\xB2', '\x5', '\xB2', '\x92A', '\n', '\xB2', 
		'\x3', '\xB2', '\x3', '\xB2', '\x5', '\xB2', '\x92E', '\n', '\xB2', '\x3', 
		'\xB3', '\x3', '\xB3', '\x3', '\xB3', '\a', '\xB3', '\x933', '\n', '\xB3', 
		'\f', '\xB3', '\xE', '\xB3', '\x936', '\v', '\xB3', '\x3', '\xB4', '\x3', 
		'\xB4', '\x3', '\xB4', '\a', '\xB4', '\x93B', '\n', '\xB4', '\f', '\xB4', 
		'\xE', '\xB4', '\x93E', '\v', '\xB4', '\x3', '\xB5', '\x3', '\xB5', '\x3', 
		'\xB5', '\a', '\xB5', '\x943', '\n', '\xB5', '\f', '\xB5', '\xE', '\xB5', 
		'\x946', '\v', '\xB5', '\x3', '\xB6', '\x3', '\xB6', '\x3', '\xB6', '\x3', 
		'\xB6', '\x3', '\xB7', '\x3', '\xB7', '\x3', '\xB7', '\x6', '\xB7', '\x94F', 
		'\n', '\xB7', '\r', '\xB7', '\xE', '\xB7', '\x950', '\x3', '\xB8', '\x3', 
		'\xB8', '\x3', '\xB8', '\x3', '\xB8', '\x5', '\xB8', '\x957', '\n', '\xB8', 
		'\x3', '\xB8', '\x3', '\xB8', '\x3', '\xB9', '\x3', '\xB9', '\x3', '\xB9', 
		'\x6', '\xB9', '\x95E', '\n', '\xB9', '\r', '\xB9', '\xE', '\xB9', '\x95F', 
		'\x3', '\xBA', '\x5', '\xBA', '\x963', '\n', '\xBA', '\x3', '\xBA', '\x3', 
		'\xBA', '\x3', '\xBA', '\a', '\xBA', '\x968', '\n', '\xBA', '\f', '\xBA', 
		'\xE', '\xBA', '\x96B', '\v', '\xBA', '\x3', '\xBB', '\x3', '\xBB', '\x5', 
		'\xBB', '\x96F', '\n', '\xBB', '\x3', '\xBB', '\x3', '\xBB', '\x5', '\xBB', 
		'\x973', '\n', '\xBB', '\x3', '\xBC', '\x3', '\xBC', '\x5', '\xBC', '\x977', 
		'\n', '\xBC', '\x3', '\xBC', '\x3', '\xBC', '\x3', '\xBC', '\x5', '\xBC', 
		'\x97C', '\n', '\xBC', '\x3', '\xBD', '\x3', '\xBD', '\x3', '\xBD', '\a', 
		'\xBD', '\x981', '\n', '\xBD', '\f', '\xBD', '\xE', '\xBD', '\x984', '\v', 
		'\xBD', '\x3', '\xBD', '\x5', '\xBD', '\x987', '\n', '\xBD', '\x3', '\xBE', 
		'\x3', '\xBE', '\x3', '\xBE', '\x3', '\xBE', '\x3', '\xBE', '\x3', '\xBE', 
		'\x3', '\xBE', '\x5', '\xBE', '\x990', '\n', '\xBE', '\x3', '\xBE', '\x5', 
		'\xBE', '\x993', '\n', '\xBE', '\x3', '\xBF', '\x3', '\xBF', '\x3', '\xC0', 
		'\x3', '\xC0', '\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', 
		'\x3', '\xC1', '\x3', '\xC1', '\x5', '\xC1', '\x99F', '\n', '\xC1', '\x3', 
		'\xC2', '\x3', '\xC2', '\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC4', '\x3', 
		'\xC4', '\x3', '\xC4', '\x3', '\xC4', '\x3', '\xC5', '\x3', '\xC5', '\x3', 
		'\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x2', '\x3', '\x9C', '\xC6', '\x2', 
		'\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', '\x14', '\x16', 
		'\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '(', '*', ',', '.', 
		'\x30', '\x32', '\x34', '\x36', '\x38', ':', '<', '>', '@', '\x42', '\x44', 
		'\x46', 'H', 'J', 'L', 'N', 'P', 'R', 'T', 'V', 'X', 'Z', '\\', '^', '`', 
		'\x62', '\x64', '\x66', 'h', 'j', 'l', 'n', 'p', 'r', 't', 'v', 'x', 'z', 
		'|', '~', '\x80', '\x82', '\x84', '\x86', '\x88', '\x8A', '\x8C', '\x8E', 
		'\x90', '\x92', '\x94', '\x96', '\x98', '\x9A', '\x9C', '\x9E', '\xA0', 
		'\xA2', '\xA4', '\xA6', '\xA8', '\xAA', '\xAC', '\xAE', '\xB0', '\xB2', 
		'\xB4', '\xB6', '\xB8', '\xBA', '\xBC', '\xBE', '\xC0', '\xC2', '\xC4', 
		'\xC6', '\xC8', '\xCA', '\xCC', '\xCE', '\xD0', '\xD2', '\xD4', '\xD6', 
		'\xD8', '\xDA', '\xDC', '\xDE', '\xE0', '\xE2', '\xE4', '\xE6', '\xE8', 
		'\xEA', '\xEC', '\xEE', '\xF0', '\xF2', '\xF4', '\xF6', '\xF8', '\xFA', 
		'\xFC', '\xFE', '\x100', '\x102', '\x104', '\x106', '\x108', '\x10A', 
		'\x10C', '\x10E', '\x110', '\x112', '\x114', '\x116', '\x118', '\x11A', 
		'\x11C', '\x11E', '\x120', '\x122', '\x124', '\x126', '\x128', '\x12A', 
		'\x12C', '\x12E', '\x130', '\x132', '\x134', '\x136', '\x138', '\x13A', 
		'\x13C', '\x13E', '\x140', '\x142', '\x144', '\x146', '\x148', '\x14A', 
		'\x14C', '\x14E', '\x150', '\x152', '\x154', '\x156', '\x158', '\x15A', 
		'\x15C', '\x15E', '\x160', '\x162', '\x164', '\x166', '\x168', '\x16A', 
		'\x16C', '\x16E', '\x170', '\x172', '\x174', '\x176', '\x178', '\x17A', 
		'\x17C', '\x17E', '\x180', '\x182', '\x184', '\x186', '\x188', '\x2', 
		'\x10', '\x5', '\x2', 'T', 'T', 'V', 'V', '~', '~', '\x3', '\x2', 'H', 
		'I', '\x4', '\x2', '[', '[', ']', ']', '\x4', '\x2', 'U', 'U', 'Z', 'Z', 
		'\x3', '\x2', 'V', 'X', '\x3', '\x2', 'T', 'U', '\x3', '\x2', 'j', 'o', 
		'\x3', '\x2', '_', 'h', '\x6', '\x2', '\v', '\v', ' ', ' ', 'G', 'M', 
		'R', 'R', '\x4', '\x2', '\x5', '\x5', '\x16', '\x16', '\x5', '\x2', '\x37', 
		'\x37', '\x39', '\x39', 'S', 'S', '\x4', '\x2', '\x38', '\x38', ';', '<', 
		'\x3', '\x2', '\x3', '\x37', '\x4', '\x2', 'U', 'U', 'W', '|', '\x2', 
		'\xACA', '\x2', '\x18D', '\x3', '\x2', '\x2', '\x2', '\x4', '\x198', '\x3', 
		'\x2', '\x2', '\x2', '\x6', '\x1B4', '\x3', '\x2', '\x2', '\x2', '\b', 
		'\x1BC', '\x3', '\x2', '\x2', '\x2', '\n', '\x1C3', '\x3', '\x2', '\x2', 
		'\x2', '\f', '\x1E8', '\x3', '\x2', '\x2', '\x2', '\xE', '\x1EA', '\x3', 
		'\x2', '\x2', '\x2', '\x10', '\x1FD', '\x3', '\x2', '\x2', '\x2', '\x12', 
		'\x1FF', '\x3', '\x2', '\x2', '\x2', '\x14', '\x20A', '\x3', '\x2', '\x2', 
		'\x2', '\x16', '\x226', '\x3', '\x2', '\x2', '\x2', '\x18', '\x242', '\x3', 
		'\x2', '\x2', '\x2', '\x1A', '\x248', '\x3', '\x2', '\x2', '\x2', '\x1C', 
		'\x24A', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x250', '\x3', '\x2', '\x2', 
		'\x2', ' ', '\x252', '\x3', '\x2', '\x2', '\x2', '\"', '\x254', '\x3', 
		'\x2', '\x2', '\x2', '$', '\x259', '\x3', '\x2', '\x2', '\x2', '&', '\x261', 
		'\x3', '\x2', '\x2', '\x2', '(', '\x274', '\x3', '\x2', '\x2', '\x2', 
		'*', '\x277', '\x3', '\x2', '\x2', '\x2', ',', '\x28C', '\x3', '\x2', 
		'\x2', '\x2', '.', '\x296', '\x3', '\x2', '\x2', '\x2', '\x30', '\x298', 
		'\x3', '\x2', '\x2', '\x2', '\x32', '\x29D', '\x3', '\x2', '\x2', '\x2', 
		'\x34', '\x2C1', '\x3', '\x2', '\x2', '\x2', '\x36', '\x2C3', '\x3', '\x2', 
		'\x2', '\x2', '\x38', '\x2D9', '\x3', '\x2', '\x2', '\x2', ':', '\x2E7', 
		'\x3', '\x2', '\x2', '\x2', '<', '\x2FD', '\x3', '\x2', '\x2', '\x2', 
		'>', '\x302', '\x3', '\x2', '\x2', '\x2', '@', '\x30D', '\x3', '\x2', 
		'\x2', '\x2', '\x42', '\x315', '\x3', '\x2', '\x2', '\x2', '\x44', '\x31E', 
		'\x3', '\x2', '\x2', '\x2', '\x46', '\x326', '\x3', '\x2', '\x2', '\x2', 
		'H', '\x32C', '\x3', '\x2', '\x2', '\x2', 'J', '\x32F', '\x3', '\x2', 
		'\x2', '\x2', 'L', '\x33F', '\x3', '\x2', '\x2', '\x2', 'N', '\x341', 
		'\x3', '\x2', '\x2', '\x2', 'P', '\x351', '\x3', '\x2', '\x2', '\x2', 
		'R', '\x360', '\x3', '\x2', '\x2', '\x2', 'T', '\x36E', '\x3', '\x2', 
		'\x2', '\x2', 'V', '\x378', '\x3', '\x2', '\x2', '\x2', 'X', '\x386', 
		'\x3', '\x2', '\x2', '\x2', 'Z', '\x38E', '\x3', '\x2', '\x2', '\x2', 
		'\\', '\x39C', '\x3', '\x2', '\x2', '\x2', '^', '\x3AA', '\x3', '\x2', 
		'\x2', '\x2', '`', '\x3B6', '\x3', '\x2', '\x2', '\x2', '\x62', '\x3BC', 
		'\x3', '\x2', '\x2', '\x2', '\x64', '\x3C2', '\x3', '\x2', '\x2', '\x2', 
		'\x66', '\x3C5', '\x3', '\x2', '\x2', '\x2', 'h', '\x3D1', '\x3', '\x2', 
		'\x2', '\x2', 'j', '\x3DE', '\x3', '\x2', '\x2', '\x2', 'l', '\x3EC', 
		'\x3', '\x2', '\x2', '\x2', 'n', '\x40D', '\x3', '\x2', '\x2', '\x2', 
		'p', '\x40F', '\x3', '\x2', '\x2', '\x2', 'r', '\x427', '\x3', '\x2', 
		'\x2', '\x2', 't', '\x446', '\x3', '\x2', '\x2', '\x2', 'v', '\x45E', 
		'\x3', '\x2', '\x2', '\x2', 'x', '\x46B', '\x3', '\x2', '\x2', '\x2', 
		'z', '\x47F', '\x3', '\x2', '\x2', '\x2', '|', '\x488', '\x3', '\x2', 
		'\x2', '\x2', '~', '\x490', '\x3', '\x2', '\x2', '\x2', '\x80', '\x49D', 
		'\x3', '\x2', '\x2', '\x2', '\x82', '\x4A2', '\x3', '\x2', '\x2', '\x2', 
		'\x84', '\x4B0', '\x3', '\x2', '\x2', '\x2', '\x86', '\x4B2', '\x3', '\x2', 
		'\x2', '\x2', '\x88', '\x4B7', '\x3', '\x2', '\x2', '\x2', '\x8A', '\x4BE', 
		'\x3', '\x2', '\x2', '\x2', '\x8C', '\x4C4', '\x3', '\x2', '\x2', '\x2', 
		'\x8E', '\x4D2', '\x3', '\x2', '\x2', '\x2', '\x90', '\x4D8', '\x3', '\x2', 
		'\x2', '\x2', '\x92', '\x4DD', '\x3', '\x2', '\x2', '\x2', '\x94', '\x4E4', 
		'\x3', '\x2', '\x2', '\x2', '\x96', '\x4EB', '\x3', '\x2', '\x2', '\x2', 
		'\x98', '\x4F0', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x506', '\x3', '\x2', 
		'\x2', '\x2', '\x9C', '\x558', '\x3', '\x2', '\x2', '\x2', '\x9E', '\x5B0', 
		'\x3', '\x2', '\x2', '\x2', '\xA0', '\x5B2', '\x3', '\x2', '\x2', '\x2', 
		'\xA2', '\x5C2', '\x3', '\x2', '\x2', '\x2', '\xA4', '\x5C4', '\x3', '\x2', 
		'\x2', '\x2', '\xA6', '\x5C8', '\x3', '\x2', '\x2', '\x2', '\xA8', '\x5CA', 
		'\x3', '\x2', '\x2', '\x2', '\xAA', '\x5DF', '\x3', '\x2', '\x2', '\x2', 
		'\xAC', '\x5E1', '\x3', '\x2', '\x2', '\x2', '\xAE', '\x5E7', '\x3', '\x2', 
		'\x2', '\x2', '\xB0', '\x5F9', '\x3', '\x2', '\x2', '\x2', '\xB2', '\x5FE', 
		'\x3', '\x2', '\x2', '\x2', '\xB4', '\x605', '\x3', '\x2', '\x2', '\x2', 
		'\xB6', '\x60A', '\x3', '\x2', '\x2', '\x2', '\xB8', '\x60C', '\x3', '\x2', 
		'\x2', '\x2', '\xBA', '\x61A', '\x3', '\x2', '\x2', '\x2', '\xBC', '\x62C', 
		'\x3', '\x2', '\x2', '\x2', '\xBE', '\x639', '\x3', '\x2', '\x2', '\x2', 
		'\xC0', '\x63C', '\x3', '\x2', '\x2', '\x2', '\xC2', '\x653', '\x3', '\x2', 
		'\x2', '\x2', '\xC4', '\x658', '\x3', '\x2', '\x2', '\x2', '\xC6', '\x65A', 
		'\x3', '\x2', '\x2', '\x2', '\xC8', '\x661', '\x3', '\x2', '\x2', '\x2', 
		'\xCA', '\x674', '\x3', '\x2', '\x2', '\x2', '\xCC', '\x676', '\x3', '\x2', 
		'\x2', '\x2', '\xCE', '\x687', '\x3', '\x2', '\x2', '\x2', '\xD0', '\x689', 
		'\x3', '\x2', '\x2', '\x2', '\xD2', '\x695', '\x3', '\x2', '\x2', '\x2', 
		'\xD4', '\x6A6', '\x3', '\x2', '\x2', '\x2', '\xD6', '\x6B4', '\x3', '\x2', 
		'\x2', '\x2', '\xD8', '\x6BD', '\x3', '\x2', '\x2', '\x2', '\xDA', '\x6C5', 
		'\x3', '\x2', '\x2', '\x2', '\xDC', '\x6C8', '\x3', '\x2', '\x2', '\x2', 
		'\xDE', '\x6CC', '\x3', '\x2', '\x2', '\x2', '\xE0', '\x6D3', '\x3', '\x2', 
		'\x2', '\x2', '\xE2', '\x6D9', '\x3', '\x2', '\x2', '\x2', '\xE4', '\x6DC', 
		'\x3', '\x2', '\x2', '\x2', '\xE6', '\x6E7', '\x3', '\x2', '\x2', '\x2', 
		'\xE8', '\x6F5', '\x3', '\x2', '\x2', '\x2', '\xEA', '\x709', '\x3', '\x2', 
		'\x2', '\x2', '\xEC', '\x719', '\x3', '\x2', '\x2', '\x2', '\xEE', '\x71E', 
		'\x3', '\x2', '\x2', '\x2', '\xF0', '\x725', '\x3', '\x2', '\x2', '\x2', 
		'\xF2', '\x729', '\x3', '\x2', '\x2', '\x2', '\xF4', '\x735', '\x3', '\x2', 
		'\x2', '\x2', '\xF6', '\x743', '\x3', '\x2', '\x2', '\x2', '\xF8', '\x755', 
		'\x3', '\x2', '\x2', '\x2', '\xFA', '\x758', '\x3', '\x2', '\x2', '\x2', 
		'\xFC', '\x762', '\x3', '\x2', '\x2', '\x2', '\xFE', '\x764', '\x3', '\x2', 
		'\x2', '\x2', '\x100', '\x771', '\x3', '\x2', '\x2', '\x2', '\x102', '\x77E', 
		'\x3', '\x2', '\x2', '\x2', '\x104', '\x780', '\x3', '\x2', '\x2', '\x2', 
		'\x106', '\x786', '\x3', '\x2', '\x2', '\x2', '\x108', '\x795', '\x3', 
		'\x2', '\x2', '\x2', '\x10A', '\x797', '\x3', '\x2', '\x2', '\x2', '\x10C', 
		'\x7A2', '\x3', '\x2', '\x2', '\x2', '\x10E', '\x7B9', '\x3', '\x2', '\x2', 
		'\x2', '\x110', '\x7BE', '\x3', '\x2', '\x2', '\x2', '\x112', '\x7C5', 
		'\x3', '\x2', '\x2', '\x2', '\x114', '\x7D0', '\x3', '\x2', '\x2', '\x2', 
		'\x116', '\x7E4', '\x3', '\x2', '\x2', '\x2', '\x118', '\x7E6', '\x3', 
		'\x2', '\x2', '\x2', '\x11A', '\x7EA', '\x3', '\x2', '\x2', '\x2', '\x11C', 
		'\x7F0', '\x3', '\x2', '\x2', '\x2', '\x11E', '\x7FD', '\x3', '\x2', '\x2', 
		'\x2', '\x120', '\x802', '\x3', '\x2', '\x2', '\x2', '\x122', '\x812', 
		'\x3', '\x2', '\x2', '\x2', '\x124', '\x814', '\x3', '\x2', '\x2', '\x2', 
		'\x126', '\x818', '\x3', '\x2', '\x2', '\x2', '\x128', '\x81A', '\x3', 
		'\x2', '\x2', '\x2', '\x12A', '\x829', '\x3', '\x2', '\x2', '\x2', '\x12C', 
		'\x82F', '\x3', '\x2', '\x2', '\x2', '\x12E', '\x833', '\x3', '\x2', '\x2', 
		'\x2', '\x130', '\x83C', '\x3', '\x2', '\x2', '\x2', '\x132', '\x841', 
		'\x3', '\x2', '\x2', '\x2', '\x134', '\x84E', '\x3', '\x2', '\x2', '\x2', 
		'\x136', '\x856', '\x3', '\x2', '\x2', '\x2', '\x138', '\x85B', '\x3', 
		'\x2', '\x2', '\x2', '\x13A', '\x85D', '\x3', '\x2', '\x2', '\x2', '\x13C', 
		'\x86B', '\x3', '\x2', '\x2', '\x2', '\x13E', '\x87C', '\x3', '\x2', '\x2', 
		'\x2', '\x140', '\x88A', '\x3', '\x2', '\x2', '\x2', '\x142', '\x88F', 
		'\x3', '\x2', '\x2', '\x2', '\x144', '\x893', '\x3', '\x2', '\x2', '\x2', 
		'\x146', '\x896', '\x3', '\x2', '\x2', '\x2', '\x148', '\x899', '\x3', 
		'\x2', '\x2', '\x2', '\x14A', '\x89B', '\x3', '\x2', '\x2', '\x2', '\x14C', 
		'\x8A8', '\x3', '\x2', '\x2', '\x2', '\x14E', '\x8BB', '\x3', '\x2', '\x2', 
		'\x2', '\x150', '\x8C2', '\x3', '\x2', '\x2', '\x2', '\x152', '\x8C8', 
		'\x3', '\x2', '\x2', '\x2', '\x154', '\x8CB', '\x3', '\x2', '\x2', '\x2', 
		'\x156', '\x8DA', '\x3', '\x2', '\x2', '\x2', '\x158', '\x8DD', '\x3', 
		'\x2', '\x2', '\x2', '\x15A', '\x8E7', '\x3', '\x2', '\x2', '\x2', '\x15C', 
		'\x8F2', '\x3', '\x2', '\x2', '\x2', '\x15E', '\x91F', '\x3', '\x2', '\x2', 
		'\x2', '\x160', '\x925', '\x3', '\x2', '\x2', '\x2', '\x162', '\x92D', 
		'\x3', '\x2', '\x2', '\x2', '\x164', '\x92F', '\x3', '\x2', '\x2', '\x2', 
		'\x166', '\x937', '\x3', '\x2', '\x2', '\x2', '\x168', '\x93F', '\x3', 
		'\x2', '\x2', '\x2', '\x16A', '\x947', '\x3', '\x2', '\x2', '\x2', '\x16C', 
		'\x94B', '\x3', '\x2', '\x2', '\x2', '\x16E', '\x952', '\x3', '\x2', '\x2', 
		'\x2', '\x170', '\x95A', '\x3', '\x2', '\x2', '\x2', '\x172', '\x962', 
		'\x3', '\x2', '\x2', '\x2', '\x174', '\x96C', '\x3', '\x2', '\x2', '\x2', 
		'\x176', '\x974', '\x3', '\x2', '\x2', '\x2', '\x178', '\x97D', '\x3', 
		'\x2', '\x2', '\x2', '\x17A', '\x988', '\x3', '\x2', '\x2', '\x2', '\x17C', 
		'\x994', '\x3', '\x2', '\x2', '\x2', '\x17E', '\x996', '\x3', '\x2', '\x2', 
		'\x2', '\x180', '\x99E', '\x3', '\x2', '\x2', '\x2', '\x182', '\x9A0', 
		'\x3', '\x2', '\x2', '\x2', '\x184', '\x9A2', '\x3', '\x2', '\x2', '\x2', 
		'\x186', '\x9A4', '\x3', '\x2', '\x2', '\x2', '\x188', '\x9A8', '\x3', 
		'\x2', '\x2', '\x2', '\x18A', '\x18C', '\x5', '\x8E', 'H', '\x2', '\x18B', 
		'\x18A', '\x3', '\x2', '\x2', '\x2', '\x18C', '\x18F', '\x3', '\x2', '\x2', 
		'\x2', '\x18D', '\x18B', '\x3', '\x2', '\x2', '\x2', '\x18D', '\x18E', 
		'\x3', '\x2', '\x2', '\x2', '\x18E', '\x193', '\x3', '\x2', '\x2', '\x2', 
		'\x18F', '\x18D', '\x3', '\x2', '\x2', '\x2', '\x190', '\x192', '\x5', 
		'$', '\x13', '\x2', '\x191', '\x190', '\x3', '\x2', '\x2', '\x2', '\x192', 
		'\x195', '\x3', '\x2', '\x2', '\x2', '\x193', '\x191', '\x3', '\x2', '\x2', 
		'\x2', '\x193', '\x194', '\x3', '\x2', '\x2', '\x2', '\x194', '\x196', 
		'\x3', '\x2', '\x2', '\x2', '\x195', '\x193', '\x3', '\x2', '\x2', '\x2', 
		'\x196', '\x197', '\a', '\x2', '\x2', '\x3', '\x197', '\x3', '\x3', '\x2', 
		'\x2', '\x2', '\x198', '\x199', '\x5', '\x154', '\xAB', '\x2', '\x199', 
		'\x19A', '\a', 'Z', '\x2', '\x2', '\x19A', '\x19B', '\x5', '\x6', '\x4', 
		'\x2', '\x19B', '\x5', '\x3', '\x2', '\x2', '\x2', '\x19C', '\x1A0', '\a', 
		'\x83', '\x2', '\x2', '\x19D', '\x19F', '\x5', '\b', '\x5', '\x2', '\x19E', 
		'\x19D', '\x3', '\x2', '\x2', '\x2', '\x19F', '\x1A2', '\x3', '\x2', '\x2', 
		'\x2', '\x1A0', '\x19E', '\x3', '\x2', '\x2', '\x2', '\x1A0', '\x1A1', 
		'\x3', '\x2', '\x2', '\x2', '\x1A1', '\x1A3', '\x3', '\x2', '\x2', '\x2', 
		'\x1A2', '\x1A0', '\x3', '\x2', '\x2', '\x2', '\x1A3', '\x1B5', '\a', 
		'\x84', '\x2', '\x2', '\x1A4', '\x1A8', '\a', '\x81', '\x2', '\x2', '\x1A5', 
		'\x1A7', '\x5', '\b', '\x5', '\x2', '\x1A6', '\x1A5', '\x3', '\x2', '\x2', 
		'\x2', '\x1A7', '\x1AA', '\x3', '\x2', '\x2', '\x2', '\x1A8', '\x1A6', 
		'\x3', '\x2', '\x2', '\x2', '\x1A8', '\x1A9', '\x3', '\x2', '\x2', '\x2', 
		'\x1A9', '\x1AB', '\x3', '\x2', '\x2', '\x2', '\x1AA', '\x1A8', '\x3', 
		'\x2', '\x2', '\x2', '\x1AB', '\x1B5', '\a', '\x82', '\x2', '\x2', '\x1AC', 
		'\x1B0', '\a', '\x7F', '\x2', '\x2', '\x1AD', '\x1AF', '\x5', '\b', '\x5', 
		'\x2', '\x1AE', '\x1AD', '\x3', '\x2', '\x2', '\x2', '\x1AF', '\x1B2', 
		'\x3', '\x2', '\x2', '\x2', '\x1B0', '\x1AE', '\x3', '\x2', '\x2', '\x2', 
		'\x1B0', '\x1B1', '\x3', '\x2', '\x2', '\x2', '\x1B1', '\x1B3', '\x3', 
		'\x2', '\x2', '\x2', '\x1B2', '\x1B0', '\x3', '\x2', '\x2', '\x2', '\x1B3', 
		'\x1B5', '\a', '\x80', '\x2', '\x2', '\x1B4', '\x19C', '\x3', '\x2', '\x2', 
		'\x2', '\x1B4', '\x1A4', '\x3', '\x2', '\x2', '\x2', '\x1B4', '\x1AC', 
		'\x3', '\x2', '\x2', '\x2', '\x1B5', '\a', '\x3', '\x2', '\x2', '\x2', 
		'\x1B6', '\x1B8', '\x5', '\n', '\x6', '\x2', '\x1B7', '\x1B6', '\x3', 
		'\x2', '\x2', '\x2', '\x1B8', '\x1B9', '\x3', '\x2', '\x2', '\x2', '\x1B9', 
		'\x1B7', '\x3', '\x2', '\x2', '\x2', '\x1B9', '\x1BA', '\x3', '\x2', '\x2', 
		'\x2', '\x1BA', '\x1BD', '\x3', '\x2', '\x2', '\x2', '\x1BB', '\x1BD', 
		'\x5', '\x6', '\x4', '\x2', '\x1BC', '\x1B7', '\x3', '\x2', '\x2', '\x2', 
		'\x1BC', '\x1BB', '\x3', '\x2', '\x2', '\x2', '\x1BD', '\t', '\x3', '\x2', 
		'\x2', '\x2', '\x1BE', '\x1C4', '\x5', '\x180', '\xC1', '\x2', '\x1BF', 
		'\x1C4', '\x5', '\x182', '\xC2', '\x2', '\x1C0', '\x1C4', '\x5', '\x184', 
		'\xC3', '\x2', '\x1C1', '\x1C4', '\x5', ' ', '\x11', '\x2', '\x1C2', '\x1C4', 
		'\a', '}', '\x2', '\x2', '\x1C3', '\x1BE', '\x3', '\x2', '\x2', '\x2', 
		'\x1C3', '\x1BF', '\x3', '\x2', '\x2', '\x2', '\x1C3', '\x1C0', '\x3', 
		'\x2', '\x2', '\x2', '\x1C3', '\x1C1', '\x3', '\x2', '\x2', '\x2', '\x1C3', 
		'\x1C2', '\x3', '\x2', '\x2', '\x2', '\x1C4', '\v', '\x3', '\x2', '\x2', 
		'\x2', '\x1C5', '\x1C6', '\x5', '\x154', '\xAB', '\x2', '\x1C6', '\x1C7', 
		'\a', 'Z', '\x2', '\x2', '\x1C7', '\x1CB', '\a', '\x83', '\x2', '\x2', 
		'\x1C8', '\x1CA', '\x5', '\b', '\x5', '\x2', '\x1C9', '\x1C8', '\x3', 
		'\x2', '\x2', '\x2', '\x1CA', '\x1CD', '\x3', '\x2', '\x2', '\x2', '\x1CB', 
		'\x1C9', '\x3', '\x2', '\x2', '\x2', '\x1CB', '\x1CC', '\x3', '\x2', '\x2', 
		'\x2', '\x1CC', '\x1CE', '\x3', '\x2', '\x2', '\x2', '\x1CD', '\x1CB', 
		'\x3', '\x2', '\x2', '\x2', '\x1CE', '\x1CF', '\a', '\x84', '\x2', '\x2', 
		'\x1CF', '\x1D0', '\a', 'w', '\x2', '\x2', '\x1D0', '\x1E9', '\x3', '\x2', 
		'\x2', '\x2', '\x1D1', '\x1D2', '\x5', '\x154', '\xAB', '\x2', '\x1D2', 
		'\x1D3', '\a', 'Z', '\x2', '\x2', '\x1D3', '\x1D7', '\a', '\x81', '\x2', 
		'\x2', '\x1D4', '\x1D6', '\x5', '\b', '\x5', '\x2', '\x1D5', '\x1D4', 
		'\x3', '\x2', '\x2', '\x2', '\x1D6', '\x1D9', '\x3', '\x2', '\x2', '\x2', 
		'\x1D7', '\x1D5', '\x3', '\x2', '\x2', '\x2', '\x1D7', '\x1D8', '\x3', 
		'\x2', '\x2', '\x2', '\x1D8', '\x1DA', '\x3', '\x2', '\x2', '\x2', '\x1D9', 
		'\x1D7', '\x3', '\x2', '\x2', '\x2', '\x1DA', '\x1DB', '\a', '\x82', '\x2', 
		'\x2', '\x1DB', '\x1DC', '\a', 'w', '\x2', '\x2', '\x1DC', '\x1E9', '\x3', 
		'\x2', '\x2', '\x2', '\x1DD', '\x1DE', '\x5', '\x154', '\xAB', '\x2', 
		'\x1DE', '\x1DF', '\a', 'Z', '\x2', '\x2', '\x1DF', '\x1E3', '\a', '\x7F', 
		'\x2', '\x2', '\x1E0', '\x1E2', '\x5', '\b', '\x5', '\x2', '\x1E1', '\x1E0', 
		'\x3', '\x2', '\x2', '\x2', '\x1E2', '\x1E5', '\x3', '\x2', '\x2', '\x2', 
		'\x1E3', '\x1E1', '\x3', '\x2', '\x2', '\x2', '\x1E3', '\x1E4', '\x3', 
		'\x2', '\x2', '\x2', '\x1E4', '\x1E6', '\x3', '\x2', '\x2', '\x2', '\x1E5', 
		'\x1E3', '\x3', '\x2', '\x2', '\x2', '\x1E6', '\x1E7', '\a', '\x80', '\x2', 
		'\x2', '\x1E7', '\x1E9', '\x3', '\x2', '\x2', '\x2', '\x1E8', '\x1C5', 
		'\x3', '\x2', '\x2', '\x2', '\x1E8', '\x1D1', '\x3', '\x2', '\x2', '\x2', 
		'\x1E8', '\x1DD', '\x3', '\x2', '\x2', '\x2', '\x1E9', '\r', '\x3', '\x2', 
		'\x2', '\x2', '\x1EA', '\x1EB', '\a', '\x38', '\x2', '\x2', '\x1EB', '\x1EC', 
		'\a', 'Z', '\x2', '\x2', '\x1EC', '\x1ED', '\x5', '\x17C', '\xBF', '\x2', 
		'\x1ED', '\x1EE', '\x5', '\x10', '\t', '\x2', '\x1EE', '\xF', '\x3', '\x2', 
		'\x2', '\x2', '\x1EF', '\x1F0', '\a', '\x83', '\x2', '\x2', '\x1F0', '\x1F1', 
		'\x5', '\x12', '\n', '\x2', '\x1F1', '\x1F2', '\a', '\x84', '\x2', '\x2', 
		'\x1F2', '\x1F3', '\a', 'w', '\x2', '\x2', '\x1F3', '\x1FE', '\x3', '\x2', 
		'\x2', '\x2', '\x1F4', '\x1F5', '\a', '\x81', '\x2', '\x2', '\x1F5', '\x1F6', 
		'\x5', '\x12', '\n', '\x2', '\x1F6', '\x1F7', '\a', '\x82', '\x2', '\x2', 
		'\x1F7', '\x1F8', '\a', 'w', '\x2', '\x2', '\x1F8', '\x1FE', '\x3', '\x2', 
		'\x2', '\x2', '\x1F9', '\x1FA', '\a', '\x7F', '\x2', '\x2', '\x1FA', '\x1FB', 
		'\x5', '\x12', '\n', '\x2', '\x1FB', '\x1FC', '\a', '\x80', '\x2', '\x2', 
		'\x1FC', '\x1FE', '\x3', '\x2', '\x2', '\x2', '\x1FD', '\x1EF', '\x3', 
		'\x2', '\x2', '\x2', '\x1FD', '\x1F4', '\x3', '\x2', '\x2', '\x2', '\x1FD', 
		'\x1F9', '\x3', '\x2', '\x2', '\x2', '\x1FE', '\x11', '\x3', '\x2', '\x2', 
		'\x2', '\x1FF', '\x204', '\x5', '\x14', '\v', '\x2', '\x200', '\x201', 
		'\a', 'w', '\x2', '\x2', '\x201', '\x203', '\x5', '\x14', '\v', '\x2', 
		'\x202', '\x200', '\x3', '\x2', '\x2', '\x2', '\x203', '\x206', '\x3', 
		'\x2', '\x2', '\x2', '\x204', '\x202', '\x3', '\x2', '\x2', '\x2', '\x204', 
		'\x205', '\x3', '\x2', '\x2', '\x2', '\x205', '\x208', '\x3', '\x2', '\x2', 
		'\x2', '\x206', '\x204', '\x3', '\x2', '\x2', '\x2', '\x207', '\x209', 
		'\a', 'w', '\x2', '\x2', '\x208', '\x207', '\x3', '\x2', '\x2', '\x2', 
		'\x208', '\x209', '\x3', '\x2', '\x2', '\x2', '\x209', '\x13', '\x3', 
		'\x2', '\x2', '\x2', '\x20A', '\x20B', '\x5', '\x16', '\f', '\x2', '\x20B', 
		'\x20C', '\a', '{', '\x2', '\x2', '\x20C', '\x20D', '\x5', '\"', '\x12', 
		'\x2', '\x20D', '\x15', '\x3', '\x2', '\x2', '\x2', '\x20E', '\x212', 
		'\a', '\x83', '\x2', '\x2', '\x20F', '\x211', '\x5', '\x18', '\r', '\x2', 
		'\x210', '\x20F', '\x3', '\x2', '\x2', '\x2', '\x211', '\x214', '\x3', 
		'\x2', '\x2', '\x2', '\x212', '\x210', '\x3', '\x2', '\x2', '\x2', '\x212', 
		'\x213', '\x3', '\x2', '\x2', '\x2', '\x213', '\x215', '\x3', '\x2', '\x2', 
		'\x2', '\x214', '\x212', '\x3', '\x2', '\x2', '\x2', '\x215', '\x227', 
		'\a', '\x84', '\x2', '\x2', '\x216', '\x21A', '\a', '\x81', '\x2', '\x2', 
		'\x217', '\x219', '\x5', '\x18', '\r', '\x2', '\x218', '\x217', '\x3', 
		'\x2', '\x2', '\x2', '\x219', '\x21C', '\x3', '\x2', '\x2', '\x2', '\x21A', 
		'\x218', '\x3', '\x2', '\x2', '\x2', '\x21A', '\x21B', '\x3', '\x2', '\x2', 
		'\x2', '\x21B', '\x21D', '\x3', '\x2', '\x2', '\x2', '\x21C', '\x21A', 
		'\x3', '\x2', '\x2', '\x2', '\x21D', '\x227', '\a', '\x82', '\x2', '\x2', 
		'\x21E', '\x222', '\a', '\x7F', '\x2', '\x2', '\x21F', '\x221', '\x5', 
		'\x18', '\r', '\x2', '\x220', '\x21F', '\x3', '\x2', '\x2', '\x2', '\x221', 
		'\x224', '\x3', '\x2', '\x2', '\x2', '\x222', '\x220', '\x3', '\x2', '\x2', 
		'\x2', '\x222', '\x223', '\x3', '\x2', '\x2', '\x2', '\x223', '\x225', 
		'\x3', '\x2', '\x2', '\x2', '\x224', '\x222', '\x3', '\x2', '\x2', '\x2', 
		'\x225', '\x227', '\a', '\x80', '\x2', '\x2', '\x226', '\x20E', '\x3', 
		'\x2', '\x2', '\x2', '\x226', '\x216', '\x3', '\x2', '\x2', '\x2', '\x226', 
		'\x21E', '\x3', '\x2', '\x2', '\x2', '\x227', '\x17', '\x3', '\x2', '\x2', 
		'\x2', '\x228', '\x22A', '\x5', '\x1A', '\xE', '\x2', '\x229', '\x228', 
		'\x3', '\x2', '\x2', '\x2', '\x22A', '\x22B', '\x3', '\x2', '\x2', '\x2', 
		'\x22B', '\x229', '\x3', '\x2', '\x2', '\x2', '\x22B', '\x22C', '\x3', 
		'\x2', '\x2', '\x2', '\x22C', '\x243', '\x3', '\x2', '\x2', '\x2', '\x22D', 
		'\x243', '\x5', '\x16', '\f', '\x2', '\x22E', '\x231', '\a', '}', '\x2', 
		'\x2', '\x22F', '\x232', '\x5', '\x17C', '\xBF', '\x2', '\x230', '\x232', 
		'\a', '\x1A', '\x2', '\x2', '\x231', '\x22F', '\x3', '\x2', '\x2', '\x2', 
		'\x231', '\x230', '\x3', '\x2', '\x2', '\x2', '\x232', '\x233', '\x3', 
		'\x2', '\x2', '\x2', '\x233', '\x234', '\a', 'x', '\x2', '\x2', '\x234', 
		'\x243', '\x5', '\x1C', '\xF', '\x2', '\x235', '\x236', '\a', '}', '\x2', 
		'\x2', '\x236', '\x238', '\a', '\x83', '\x2', '\x2', '\x237', '\x239', 
		'\x5', '\x18', '\r', '\x2', '\x238', '\x237', '\x3', '\x2', '\x2', '\x2', 
		'\x239', '\x23A', '\x3', '\x2', '\x2', '\x2', '\x23A', '\x238', '\x3', 
		'\x2', '\x2', '\x2', '\x23A', '\x23B', '\x3', '\x2', '\x2', '\x2', '\x23B', 
		'\x23C', '\x3', '\x2', '\x2', '\x2', '\x23C', '\x23E', '\a', '\x84', '\x2', 
		'\x2', '\x23D', '\x23F', '\x5', '\x1E', '\x10', '\x2', '\x23E', '\x23D', 
		'\x3', '\x2', '\x2', '\x2', '\x23E', '\x23F', '\x3', '\x2', '\x2', '\x2', 
		'\x23F', '\x240', '\x3', '\x2', '\x2', '\x2', '\x240', '\x241', '\x5', 
		' ', '\x11', '\x2', '\x241', '\x243', '\x3', '\x2', '\x2', '\x2', '\x242', 
		'\x229', '\x3', '\x2', '\x2', '\x2', '\x242', '\x22D', '\x3', '\x2', '\x2', 
		'\x2', '\x242', '\x22E', '\x3', '\x2', '\x2', '\x2', '\x242', '\x235', 
		'\x3', '\x2', '\x2', '\x2', '\x243', '\x19', '\x3', '\x2', '\x2', '\x2', 
		'\x244', '\x249', '\x5', '\x180', '\xC1', '\x2', '\x245', '\x249', '\x5', 
		'\x182', '\xC2', '\x2', '\x246', '\x249', '\x5', '\x184', '\xC3', '\x2', 
		'\x247', '\x249', '\x5', ' ', '\x11', '\x2', '\x248', '\x244', '\x3', 
		'\x2', '\x2', '\x2', '\x248', '\x245', '\x3', '\x2', '\x2', '\x2', '\x248', 
		'\x246', '\x3', '\x2', '\x2', '\x2', '\x248', '\x247', '\x3', '\x2', '\x2', 
		'\x2', '\x249', '\x1B', '\x3', '\x2', '\x2', '\x2', '\x24A', '\x24B', 
		'\x5', '\x17C', '\xBF', '\x2', '\x24B', '\x1D', '\x3', '\x2', '\x2', '\x2', 
		'\x24C', '\x251', '\x5', '\x180', '\xC1', '\x2', '\x24D', '\x251', '\x5', 
		'\x182', '\xC2', '\x2', '\x24E', '\x251', '\x5', '\x184', '\xC3', '\x2', 
		'\x24F', '\x251', '\a', '}', '\x2', '\x2', '\x250', '\x24C', '\x3', '\x2', 
		'\x2', '\x2', '\x250', '\x24D', '\x3', '\x2', '\x2', '\x2', '\x250', '\x24E', 
		'\x3', '\x2', '\x2', '\x2', '\x250', '\x24F', '\x3', '\x2', '\x2', '\x2', 
		'\x251', '\x1F', '\x3', '\x2', '\x2', '\x2', '\x252', '\x253', '\t', '\x2', 
		'\x2', '\x2', '\x253', '!', '\x3', '\x2', '\x2', '\x2', '\x254', '\x255', 
		'\x5', '\x6', '\x4', '\x2', '\x255', '#', '\x3', '\x2', '\x2', '\x2', 
		'\x256', '\x258', '\x5', '\x90', 'I', '\x2', '\x257', '\x256', '\x3', 
		'\x2', '\x2', '\x2', '\x258', '\x25B', '\x3', '\x2', '\x2', '\x2', '\x259', 
		'\x257', '\x3', '\x2', '\x2', '\x2', '\x259', '\x25A', '\x3', '\x2', '\x2', 
		'\x2', '\x25A', '\x25E', '\x3', '\x2', '\x2', '\x2', '\x25B', '\x259', 
		'\x3', '\x2', '\x2', '\x2', '\x25C', '\x25F', '\x5', '&', '\x14', '\x2', 
		'\x25D', '\x25F', '\x5', '(', '\x15', '\x2', '\x25E', '\x25C', '\x3', 
		'\x2', '\x2', '\x2', '\x25E', '\x25D', '\x3', '\x2', '\x2', '\x2', '\x25F', 
		'%', '\x3', '\x2', '\x2', '\x2', '\x260', '\x262', '\x5', '\x17A', '\xBE', 
		'\x2', '\x261', '\x260', '\x3', '\x2', '\x2', '\x2', '\x261', '\x262', 
		'\x3', '\x2', '\x2', '\x2', '\x262', '\x270', '\x3', '\x2', '\x2', '\x2', 
		'\x263', '\x271', '\x5', '*', '\x16', '\x2', '\x264', '\x271', '\x5', 
		',', '\x17', '\x2', '\x265', '\x271', '\x5', '\x32', '\x1A', '\x2', '\x266', 
		'\x271', '\x5', '\x36', '\x1C', '\x2', '\x267', '\x271', '\x5', 'J', '&', 
		'\x2', '\x268', '\x271', '\x5', 'L', '\'', '\x2', '\x269', '\x271', '\x5', 
		'Z', '.', '\x2', '\x26A', '\x271', '\x5', '\x66', '\x34', '\x2', '\x26B', 
		'\x271', '\x5', 'h', '\x35', '\x2', '\x26C', '\x271', '\x5', 'j', '\x36', 
		'\x2', '\x26D', '\x271', '\x5', 'l', '\x37', '\x2', '\x26E', '\x271', 
		'\x5', 'n', '\x38', '\x2', '\x26F', '\x271', '\x5', 't', ';', '\x2', '\x270', 
		'\x263', '\x3', '\x2', '\x2', '\x2', '\x270', '\x264', '\x3', '\x2', '\x2', 
		'\x2', '\x270', '\x265', '\x3', '\x2', '\x2', '\x2', '\x270', '\x266', 
		'\x3', '\x2', '\x2', '\x2', '\x270', '\x267', '\x3', '\x2', '\x2', '\x2', 
		'\x270', '\x268', '\x3', '\x2', '\x2', '\x2', '\x270', '\x269', '\x3', 
		'\x2', '\x2', '\x2', '\x270', '\x26A', '\x3', '\x2', '\x2', '\x2', '\x270', 
		'\x26B', '\x3', '\x2', '\x2', '\x2', '\x270', '\x26C', '\x3', '\x2', '\x2', 
		'\x2', '\x270', '\x26D', '\x3', '\x2', '\x2', '\x2', '\x270', '\x26E', 
		'\x3', '\x2', '\x2', '\x2', '\x270', '\x26F', '\x3', '\x2', '\x2', '\x2', 
		'\x271', '\'', '\x3', '\x2', '\x2', '\x2', '\x272', '\x275', '\x5', '\f', 
		'\a', '\x2', '\x273', '\x275', '\x5', '\xE', '\b', '\x2', '\x274', '\x272', 
		'\x3', '\x2', '\x2', '\x2', '\x274', '\x273', '\x3', '\x2', '\x2', '\x2', 
		'\x275', ')', '\x3', '\x2', '\x2', '\x2', '\x276', '\x278', '\a', '\"', 
		'\x2', '\x2', '\x277', '\x276', '\x3', '\x2', '\x2', '\x2', '\x277', '\x278', 
		'\x3', '\x2', '\x2', '\x2', '\x278', '\x279', '\x3', '\x2', '\x2', '\x2', 
		'\x279', '\x27A', '\a', '\x14', '\x2', '\x2', '\x27A', '\x28A', '\x5', 
		'\x17C', '\xBF', '\x2', '\x27B', '\x28B', '\a', 'w', '\x2', '\x2', '\x27C', 
		'\x280', '\a', '\x7F', '\x2', '\x2', '\x27D', '\x27F', '\x5', '\x8E', 
		'H', '\x2', '\x27E', '\x27D', '\x3', '\x2', '\x2', '\x2', '\x27F', '\x282', 
		'\x3', '\x2', '\x2', '\x2', '\x280', '\x27E', '\x3', '\x2', '\x2', '\x2', 
		'\x280', '\x281', '\x3', '\x2', '\x2', '\x2', '\x281', '\x286', '\x3', 
		'\x2', '\x2', '\x2', '\x282', '\x280', '\x3', '\x2', '\x2', '\x2', '\x283', 
		'\x285', '\x5', '$', '\x13', '\x2', '\x284', '\x283', '\x3', '\x2', '\x2', 
		'\x2', '\x285', '\x288', '\x3', '\x2', '\x2', '\x2', '\x286', '\x284', 
		'\x3', '\x2', '\x2', '\x2', '\x286', '\x287', '\x3', '\x2', '\x2', '\x2', 
		'\x287', '\x289', '\x3', '\x2', '\x2', '\x2', '\x288', '\x286', '\x3', 
		'\x2', '\x2', '\x2', '\x289', '\x28B', '\a', '\x80', '\x2', '\x2', '\x28A', 
		'\x27B', '\x3', '\x2', '\x2', '\x2', '\x28A', '\x27C', '\x3', '\x2', '\x2', 
		'\x2', '\x28B', '+', '\x3', '\x2', '\x2', '\x2', '\x28C', '\x28D', '\a', 
		'\n', '\x2', '\x2', '\x28D', '\x28E', '\a', '\a', '\x2', '\x2', '\x28E', 
		'\x290', '\x5', '.', '\x18', '\x2', '\x28F', '\x291', '\x5', '\x30', '\x19', 
		'\x2', '\x290', '\x28F', '\x3', '\x2', '\x2', '\x2', '\x290', '\x291', 
		'\x3', '\x2', '\x2', '\x2', '\x291', '\x292', '\x3', '\x2', '\x2', '\x2', 
		'\x292', '\x293', '\a', 'w', '\x2', '\x2', '\x293', '-', '\x3', '\x2', 
		'\x2', '\x2', '\x294', '\x297', '\x5', '\x17C', '\xBF', '\x2', '\x295', 
		'\x297', '\a', '\x1A', '\x2', '\x2', '\x296', '\x294', '\x3', '\x2', '\x2', 
		'\x2', '\x296', '\x295', '\x3', '\x2', '\x2', '\x2', '\x297', '/', '\x3', 
		'\x2', '\x2', '\x2', '\x298', '\x29B', '\a', '\x3', '\x2', '\x2', '\x299', 
		'\x29C', '\x5', '\x17C', '\xBF', '\x2', '\x29A', '\x29C', '\a', 'q', '\x2', 
		'\x2', '\x29B', '\x299', '\x3', '\x2', '\x2', '\x2', '\x29B', '\x29A', 
		'\x3', '\x2', '\x2', '\x2', '\x29C', '\x31', '\x3', '\x2', '\x2', '\x2', 
		'\x29D', '\x29E', '\a', '#', '\x2', '\x2', '\x29E', '\x29F', '\x5', '\x34', 
		'\x1B', '\x2', '\x29F', '\x2A0', '\a', 'w', '\x2', '\x2', '\x2A0', '\x33', 
		'\x3', '\x2', '\x2', '\x2', '\x2A1', '\x2A3', '\x5', '\x154', '\xAB', 
		'\x2', '\x2A2', '\x2A1', '\x3', '\x2', '\x2', '\x2', '\x2A2', '\x2A3', 
		'\x3', '\x2', '\x2', '\x2', '\x2A3', '\x2A4', '\x3', '\x2', '\x2', '\x2', 
		'\x2A4', '\x2A6', '\a', 'y', '\x2', '\x2', '\x2A5', '\x2A2', '\x3', '\x2', 
		'\x2', '\x2', '\x2A5', '\x2A6', '\x3', '\x2', '\x2', '\x2', '\x2A6', '\x2B7', 
		'\x3', '\x2', '\x2', '\x2', '\x2A7', '\x2B8', '\a', 'V', '\x2', '\x2', 
		'\x2A8', '\x2B4', '\a', '\x7F', '\x2', '\x2', '\x2A9', '\x2AE', '\x5', 
		'\x34', '\x1B', '\x2', '\x2AA', '\x2AB', '\a', 'v', '\x2', '\x2', '\x2AB', 
		'\x2AD', '\x5', '\x34', '\x1B', '\x2', '\x2AC', '\x2AA', '\x3', '\x2', 
		'\x2', '\x2', '\x2AD', '\x2B0', '\x3', '\x2', '\x2', '\x2', '\x2AE', '\x2AC', 
		'\x3', '\x2', '\x2', '\x2', '\x2AE', '\x2AF', '\x3', '\x2', '\x2', '\x2', 
		'\x2AF', '\x2B2', '\x3', '\x2', '\x2', '\x2', '\x2B0', '\x2AE', '\x3', 
		'\x2', '\x2', '\x2', '\x2B1', '\x2B3', '\a', 'v', '\x2', '\x2', '\x2B2', 
		'\x2B1', '\x3', '\x2', '\x2', '\x2', '\x2B2', '\x2B3', '\x3', '\x2', '\x2', 
		'\x2', '\x2B3', '\x2B5', '\x3', '\x2', '\x2', '\x2', '\x2B4', '\x2A9', 
		'\x3', '\x2', '\x2', '\x2', '\x2B4', '\x2B5', '\x3', '\x2', '\x2', '\x2', 
		'\x2B5', '\x2B6', '\x3', '\x2', '\x2', '\x2', '\x2B6', '\x2B8', '\a', 
		'\x80', '\x2', '\x2', '\x2B7', '\x2A7', '\x3', '\x2', '\x2', '\x2', '\x2B7', 
		'\x2A8', '\x3', '\x2', '\x2', '\x2', '\x2B8', '\x2C2', '\x3', '\x2', '\x2', 
		'\x2', '\x2B9', '\x2BF', '\x5', '\x154', '\xAB', '\x2', '\x2BA', '\x2BD', 
		'\a', '\x3', '\x2', '\x2', '\x2BB', '\x2BE', '\x5', '\x17C', '\xBF', '\x2', 
		'\x2BC', '\x2BE', '\a', 'q', '\x2', '\x2', '\x2BD', '\x2BB', '\x3', '\x2', 
		'\x2', '\x2', '\x2BD', '\x2BC', '\x3', '\x2', '\x2', '\x2', '\x2BE', '\x2C0', 
		'\x3', '\x2', '\x2', '\x2', '\x2BF', '\x2BA', '\x3', '\x2', '\x2', '\x2', 
		'\x2BF', '\x2C0', '\x3', '\x2', '\x2', '\x2', '\x2C0', '\x2C2', '\x3', 
		'\x2', '\x2', '\x2', '\x2C1', '\x2A5', '\x3', '\x2', '\x2', '\x2', '\x2C1', 
		'\x2B9', '\x3', '\x2', '\x2', '\x2', '\x2C2', '\x35', '\x3', '\x2', '\x2', 
		'\x2', '\x2C3', '\x2C4', '\x5', '\x38', '\x1D', '\x2', '\x2C4', '\x2C5', 
		'\a', '\f', '\x2', '\x2', '\x2C5', '\x2C7', '\x5', '\x17C', '\xBF', '\x2', 
		'\x2C6', '\x2C8', '\x5', 'x', '=', '\x2', '\x2C7', '\x2C6', '\x3', '\x2', 
		'\x2', '\x2', '\x2C7', '\x2C8', '\x3', '\x2', '\x2', '\x2', '\x2C8', '\x2C9', 
		'\x3', '\x2', '\x2', '\x2', '\x2C9', '\x2CB', '\a', '\x83', '\x2', '\x2', 
		'\x2CA', '\x2CC', '\x5', '<', '\x1F', '\x2', '\x2CB', '\x2CA', '\x3', 
		'\x2', '\x2', '\x2', '\x2CB', '\x2CC', '\x3', '\x2', '\x2', '\x2', '\x2CC', 
		'\x2CD', '\x3', '\x2', '\x2', '\x2', '\x2CD', '\x2CF', '\a', '\x84', '\x2', 
		'\x2', '\x2CE', '\x2D0', '\x5', 'H', '%', '\x2', '\x2CF', '\x2CE', '\x3', 
		'\x2', '\x2', '\x2', '\x2CF', '\x2D0', '\x3', '\x2', '\x2', '\x2', '\x2D0', 
		'\x2D2', '\x3', '\x2', '\x2', '\x2', '\x2D1', '\x2D3', '\x5', '\x82', 
		'\x42', '\x2', '\x2D2', '\x2D1', '\x3', '\x2', '\x2', '\x2', '\x2D2', 
		'\x2D3', '\x3', '\x2', '\x2', '\x2', '\x2D3', '\x2D6', '\x3', '\x2', '\x2', 
		'\x2', '\x2D4', '\x2D7', '\x5', '\xA8', 'U', '\x2', '\x2D5', '\x2D7', 
		'\a', 'w', '\x2', '\x2', '\x2D6', '\x2D4', '\x3', '\x2', '\x2', '\x2', 
		'\x2D6', '\x2D5', '\x3', '\x2', '\x2', '\x2', '\x2D7', '\x37', '\x3', 
		'\x2', '\x2', '\x2', '\x2D8', '\x2DA', '\a', '\x5', '\x2', '\x2', '\x2D9', 
		'\x2D8', '\x3', '\x2', '\x2', '\x2', '\x2D9', '\x2DA', '\x3', '\x2', '\x2', 
		'\x2', '\x2DA', '\x2DC', '\x3', '\x2', '\x2', '\x2', '\x2DB', '\x2DD', 
		'\a', '&', '\x2', '\x2', '\x2DC', '\x2DB', '\x3', '\x2', '\x2', '\x2', 
		'\x2DC', '\x2DD', '\x3', '\x2', '\x2', '\x2', '\x2DD', '\x2DF', '\x3', 
		'\x2', '\x2', '\x2', '\x2DE', '\x2E0', '\a', '\"', '\x2', '\x2', '\x2DF', 
		'\x2DE', '\x3', '\x2', '\x2', '\x2', '\x2DF', '\x2E0', '\x3', '\x2', '\x2', 
		'\x2', '\x2E0', '\x2E5', '\x3', '\x2', '\x2', '\x2', '\x2E1', '\x2E3', 
		'\a', '\n', '\x2', '\x2', '\x2E2', '\x2E4', '\x5', ':', '\x1E', '\x2', 
		'\x2E3', '\x2E2', '\x3', '\x2', '\x2', '\x2', '\x2E3', '\x2E4', '\x3', 
		'\x2', '\x2', '\x2', '\x2E4', '\x2E6', '\x3', '\x2', '\x2', '\x2', '\x2E5', 
		'\x2E1', '\x3', '\x2', '\x2', '\x2', '\x2E5', '\x2E6', '\x3', '\x2', '\x2', 
		'\x2', '\x2E6', '\x39', '\x3', '\x2', '\x2', '\x2', '\x2E7', '\x2E8', 
		'\t', '\x3', '\x2', '\x2', '\x2E8', ';', '\x3', '\x2', '\x2', '\x2', '\x2E9', 
		'\x2EB', '\x5', '>', ' ', '\x2', '\x2EA', '\x2EC', '\a', 'v', '\x2', '\x2', 
		'\x2EB', '\x2EA', '\x3', '\x2', '\x2', '\x2', '\x2EB', '\x2EC', '\x3', 
		'\x2', '\x2', '\x2', '\x2EC', '\x2FE', '\x3', '\x2', '\x2', '\x2', '\x2ED', 
		'\x2EE', '\x5', '>', ' ', '\x2', '\x2EE', '\x2EF', '\a', 'v', '\x2', '\x2', 
		'\x2EF', '\x2F1', '\x3', '\x2', '\x2', '\x2', '\x2F0', '\x2ED', '\x3', 
		'\x2', '\x2', '\x2', '\x2F0', '\x2F1', '\x3', '\x2', '\x2', '\x2', '\x2F1', 
		'\x2F2', '\x3', '\x2', '\x2', '\x2', '\x2F2', '\x2F7', '\x5', '\x44', 
		'#', '\x2', '\x2F3', '\x2F4', '\a', 'v', '\x2', '\x2', '\x2F4', '\x2F6', 
		'\x5', '\x44', '#', '\x2', '\x2F5', '\x2F3', '\x3', '\x2', '\x2', '\x2', 
		'\x2F6', '\x2F9', '\x3', '\x2', '\x2', '\x2', '\x2F7', '\x2F5', '\x3', 
		'\x2', '\x2', '\x2', '\x2F7', '\x2F8', '\x3', '\x2', '\x2', '\x2', '\x2F8', 
		'\x2FB', '\x3', '\x2', '\x2', '\x2', '\x2F9', '\x2F7', '\x3', '\x2', '\x2', 
		'\x2', '\x2FA', '\x2FC', '\a', 'v', '\x2', '\x2', '\x2FB', '\x2FA', '\x3', 
		'\x2', '\x2', '\x2', '\x2FB', '\x2FC', '\x3', '\x2', '\x2', '\x2', '\x2FC', 
		'\x2FE', '\x3', '\x2', '\x2', '\x2', '\x2FD', '\x2E9', '\x3', '\x2', '\x2', 
		'\x2', '\x2FD', '\x2F0', '\x3', '\x2', '\x2', '\x2', '\x2FE', '=', '\x3', 
		'\x2', '\x2', '\x2', '\x2FF', '\x301', '\x5', '\x90', 'I', '\x2', '\x300', 
		'\x2FF', '\x3', '\x2', '\x2', '\x2', '\x301', '\x304', '\x3', '\x2', '\x2', 
		'\x2', '\x302', '\x300', '\x3', '\x2', '\x2', '\x2', '\x302', '\x303', 
		'\x3', '\x2', '\x2', '\x2', '\x303', '\x307', '\x3', '\x2', '\x2', '\x2', 
		'\x304', '\x302', '\x3', '\x2', '\x2', '\x2', '\x305', '\x308', '\x5', 
		'@', '!', '\x2', '\x306', '\x308', '\x5', '\x42', '\"', '\x2', '\x307', 
		'\x305', '\x3', '\x2', '\x2', '\x2', '\x307', '\x306', '\x3', '\x2', '\x2', 
		'\x2', '\x308', '?', '\x3', '\x2', '\x2', '\x2', '\x309', '\x30B', '\a', 
		'[', '\x2', '\x2', '\x30A', '\x30C', '\x5', '\x152', '\xAA', '\x2', '\x30B', 
		'\x30A', '\x3', '\x2', '\x2', '\x2', '\x30B', '\x30C', '\x3', '\x2', '\x2', 
		'\x2', '\x30C', '\x30E', '\x3', '\x2', '\x2', '\x2', '\x30D', '\x309', 
		'\x3', '\x2', '\x2', '\x2', '\x30D', '\x30E', '\x3', '\x2', '\x2', '\x2', 
		'\x30E', '\x310', '\x3', '\x2', '\x2', '\x2', '\x30F', '\x311', '\a', 
		'\x16', '\x2', '\x2', '\x310', '\x30F', '\x3', '\x2', '\x2', '\x2', '\x310', 
		'\x311', '\x3', '\x2', '\x2', '\x2', '\x311', '\x312', '\x3', '\x2', '\x2', 
		'\x2', '\x312', '\x313', '\a', '\x1A', '\x2', '\x2', '\x313', '\x41', 
		'\x3', '\x2', '\x2', '\x2', '\x314', '\x316', '\a', '\x16', '\x2', '\x2', 
		'\x315', '\x314', '\x3', '\x2', '\x2', '\x2', '\x315', '\x316', '\x3', 
		'\x2', '\x2', '\x2', '\x316', '\x317', '\x3', '\x2', '\x2', '\x2', '\x317', 
		'\x318', '\a', '\x1A', '\x2', '\x2', '\x318', '\x319', '\a', 'x', '\x2', 
		'\x2', '\x319', '\x31A', '\x5', '\x120', '\x91', '\x2', '\x31A', '\x43', 
		'\x3', '\x2', '\x2', '\x2', '\x31B', '\x31D', '\x5', '\x90', 'I', '\x2', 
		'\x31C', '\x31B', '\x3', '\x2', '\x2', '\x2', '\x31D', '\x320', '\x3', 
		'\x2', '\x2', '\x2', '\x31E', '\x31C', '\x3', '\x2', '\x2', '\x2', '\x31E', 
		'\x31F', '\x3', '\x2', '\x2', '\x2', '\x31F', '\x324', '\x3', '\x2', '\x2', 
		'\x2', '\x320', '\x31E', '\x3', '\x2', '\x2', '\x2', '\x321', '\x325', 
		'\x5', '\x46', '$', '\x2', '\x322', '\x325', '\a', 't', '\x2', '\x2', 
		'\x323', '\x325', '\x5', '\x120', '\x91', '\x2', '\x324', '\x321', '\x3', 
		'\x2', '\x2', '\x2', '\x324', '\x322', '\x3', '\x2', '\x2', '\x2', '\x324', 
		'\x323', '\x3', '\x2', '\x2', '\x2', '\x325', '\x45', '\x3', '\x2', '\x2', 
		'\x2', '\x326', '\x327', '\x5', '\xF2', 'z', '\x2', '\x327', '\x32A', 
		'\a', 'x', '\x2', '\x2', '\x328', '\x32B', '\x5', '\x120', '\x91', '\x2', 
		'\x329', '\x32B', '\a', 't', '\x2', '\x2', '\x32A', '\x328', '\x3', '\x2', 
		'\x2', '\x2', '\x32A', '\x329', '\x3', '\x2', '\x2', '\x2', '\x32B', 'G', 
		'\x3', '\x2', '\x2', '\x2', '\x32C', '\x32D', '\a', 'z', '\x2', '\x2', 
		'\x32D', '\x32E', '\x5', '\x120', '\x91', '\x2', '\x32E', 'I', '\x3', 
		'\x2', '\x2', '\x2', '\x32F', '\x330', '\a', '!', '\x2', '\x2', '\x330', 
		'\x332', '\x5', '\x17C', '\xBF', '\x2', '\x331', '\x333', '\x5', 'x', 
		'=', '\x2', '\x332', '\x331', '\x3', '\x2', '\x2', '\x2', '\x332', '\x333', 
		'\x3', '\x2', '\x2', '\x2', '\x333', '\x335', '\x3', '\x2', '\x2', '\x2', 
		'\x334', '\x336', '\x5', '\x82', '\x42', '\x2', '\x335', '\x334', '\x3', 
		'\x2', '\x2', '\x2', '\x335', '\x336', '\x3', '\x2', '\x2', '\x2', '\x336', 
		'\x339', '\x3', '\x2', '\x2', '\x2', '\x337', '\x338', '\a', 'i', '\x2', 
		'\x2', '\x338', '\x33A', '\x5', '\x120', '\x91', '\x2', '\x339', '\x337', 
		'\x3', '\x2', '\x2', '\x2', '\x339', '\x33A', '\x3', '\x2', '\x2', '\x2', 
		'\x33A', '\x33B', '\x3', '\x2', '\x2', '\x2', '\x33B', '\x33C', '\a', 
		'w', '\x2', '\x2', '\x33C', 'K', '\x3', '\x2', '\x2', '\x2', '\x33D', 
		'\x340', '\x5', 'N', '(', '\x2', '\x33E', '\x340', '\x5', 'P', ')', '\x2', 
		'\x33F', '\x33D', '\x3', '\x2', '\x2', '\x2', '\x33F', '\x33E', '\x3', 
		'\x2', '\x2', '\x2', '\x340', 'M', '\x3', '\x2', '\x2', '\x2', '\x341', 
		'\x342', '\a', '\x1D', '\x2', '\x2', '\x342', '\x344', '\x5', '\x17C', 
		'\xBF', '\x2', '\x343', '\x345', '\x5', 'x', '=', '\x2', '\x344', '\x343', 
		'\x3', '\x2', '\x2', '\x2', '\x344', '\x345', '\x3', '\x2', '\x2', '\x2', 
		'\x345', '\x347', '\x3', '\x2', '\x2', '\x2', '\x346', '\x348', '\x5', 
		'\x82', '\x42', '\x2', '\x347', '\x346', '\x3', '\x2', '\x2', '\x2', '\x347', 
		'\x348', '\x3', '\x2', '\x2', '\x2', '\x348', '\x34F', '\x3', '\x2', '\x2', 
		'\x2', '\x349', '\x34B', '\a', '\x7F', '\x2', '\x2', '\x34A', '\x34C', 
		'\x5', 'R', '*', '\x2', '\x34B', '\x34A', '\x3', '\x2', '\x2', '\x2', 
		'\x34B', '\x34C', '\x3', '\x2', '\x2', '\x2', '\x34C', '\x34D', '\x3', 
		'\x2', '\x2', '\x2', '\x34D', '\x350', '\a', '\x80', '\x2', '\x2', '\x34E', 
		'\x350', '\a', 'w', '\x2', '\x2', '\x34F', '\x349', '\x3', '\x2', '\x2', 
		'\x2', '\x34F', '\x34E', '\x3', '\x2', '\x2', '\x2', '\x350', 'O', '\x3', 
		'\x2', '\x2', '\x2', '\x351', '\x352', '\a', '\x1D', '\x2', '\x2', '\x352', 
		'\x354', '\x5', '\x17C', '\xBF', '\x2', '\x353', '\x355', '\x5', 'x', 
		'=', '\x2', '\x354', '\x353', '\x3', '\x2', '\x2', '\x2', '\x354', '\x355', 
		'\x3', '\x2', '\x2', '\x2', '\x355', '\x356', '\x3', '\x2', '\x2', '\x2', 
		'\x356', '\x358', '\a', '\x83', '\x2', '\x2', '\x357', '\x359', '\x5', 
		'V', ',', '\x2', '\x358', '\x357', '\x3', '\x2', '\x2', '\x2', '\x358', 
		'\x359', '\x3', '\x2', '\x2', '\x2', '\x359', '\x35A', '\x3', '\x2', '\x2', 
		'\x2', '\x35A', '\x35C', '\a', '\x84', '\x2', '\x2', '\x35B', '\x35D', 
		'\x5', '\x82', '\x42', '\x2', '\x35C', '\x35B', '\x3', '\x2', '\x2', '\x2', 
		'\x35C', '\x35D', '\x3', '\x2', '\x2', '\x2', '\x35D', '\x35E', '\x3', 
		'\x2', '\x2', '\x2', '\x35E', '\x35F', '\a', 'w', '\x2', '\x2', '\x35F', 
		'Q', '\x3', '\x2', '\x2', '\x2', '\x360', '\x365', '\x5', 'T', '+', '\x2', 
		'\x361', '\x362', '\a', 'v', '\x2', '\x2', '\x362', '\x364', '\x5', 'T', 
		'+', '\x2', '\x363', '\x361', '\x3', '\x2', '\x2', '\x2', '\x364', '\x367', 
		'\x3', '\x2', '\x2', '\x2', '\x365', '\x363', '\x3', '\x2', '\x2', '\x2', 
		'\x365', '\x366', '\x3', '\x2', '\x2', '\x2', '\x366', '\x369', '\x3', 
		'\x2', '\x2', '\x2', '\x367', '\x365', '\x3', '\x2', '\x2', '\x2', '\x368', 
		'\x36A', '\a', 'v', '\x2', '\x2', '\x369', '\x368', '\x3', '\x2', '\x2', 
		'\x2', '\x369', '\x36A', '\x3', '\x2', '\x2', '\x2', '\x36A', 'S', '\x3', 
		'\x2', '\x2', '\x2', '\x36B', '\x36D', '\x5', '\x90', 'I', '\x2', '\x36C', 
		'\x36B', '\x3', '\x2', '\x2', '\x2', '\x36D', '\x370', '\x3', '\x2', '\x2', 
		'\x2', '\x36E', '\x36C', '\x3', '\x2', '\x2', '\x2', '\x36E', '\x36F', 
		'\x3', '\x2', '\x2', '\x2', '\x36F', '\x372', '\x3', '\x2', '\x2', '\x2', 
		'\x370', '\x36E', '\x3', '\x2', '\x2', '\x2', '\x371', '\x373', '\x5', 
		'\x17A', '\xBE', '\x2', '\x372', '\x371', '\x3', '\x2', '\x2', '\x2', 
		'\x372', '\x373', '\x3', '\x2', '\x2', '\x2', '\x373', '\x374', '\x3', 
		'\x2', '\x2', '\x2', '\x374', '\x375', '\x5', '\x17C', '\xBF', '\x2', 
		'\x375', '\x376', '\a', 'x', '\x2', '\x2', '\x376', '\x377', '\x5', '\x120', 
		'\x91', '\x2', '\x377', 'U', '\x3', '\x2', '\x2', '\x2', '\x378', '\x37D', 
		'\x5', 'X', '-', '\x2', '\x379', '\x37A', '\a', 'v', '\x2', '\x2', '\x37A', 
		'\x37C', '\x5', 'X', '-', '\x2', '\x37B', '\x379', '\x3', '\x2', '\x2', 
		'\x2', '\x37C', '\x37F', '\x3', '\x2', '\x2', '\x2', '\x37D', '\x37B', 
		'\x3', '\x2', '\x2', '\x2', '\x37D', '\x37E', '\x3', '\x2', '\x2', '\x2', 
		'\x37E', '\x381', '\x3', '\x2', '\x2', '\x2', '\x37F', '\x37D', '\x3', 
		'\x2', '\x2', '\x2', '\x380', '\x382', '\a', 'v', '\x2', '\x2', '\x381', 
		'\x380', '\x3', '\x2', '\x2', '\x2', '\x381', '\x382', '\x3', '\x2', '\x2', 
		'\x2', '\x382', 'W', '\x3', '\x2', '\x2', '\x2', '\x383', '\x385', '\x5', 
		'\x90', 'I', '\x2', '\x384', '\x383', '\x3', '\x2', '\x2', '\x2', '\x385', 
		'\x388', '\x3', '\x2', '\x2', '\x2', '\x386', '\x384', '\x3', '\x2', '\x2', 
		'\x2', '\x386', '\x387', '\x3', '\x2', '\x2', '\x2', '\x387', '\x38A', 
		'\x3', '\x2', '\x2', '\x2', '\x388', '\x386', '\x3', '\x2', '\x2', '\x2', 
		'\x389', '\x38B', '\x5', '\x17A', '\xBE', '\x2', '\x38A', '\x389', '\x3', 
		'\x2', '\x2', '\x2', '\x38A', '\x38B', '\x3', '\x2', '\x2', '\x2', '\x38B', 
		'\x38C', '\x3', '\x2', '\x2', '\x2', '\x38C', '\x38D', '\x5', '\x120', 
		'\x91', '\x2', '\x38D', 'Y', '\x3', '\x2', '\x2', '\x2', '\x38E', '\x38F', 
		'\a', '\t', '\x2', '\x2', '\x38F', '\x391', '\x5', '\x17C', '\xBF', '\x2', 
		'\x390', '\x392', '\x5', 'x', '=', '\x2', '\x391', '\x390', '\x3', '\x2', 
		'\x2', '\x2', '\x391', '\x392', '\x3', '\x2', '\x2', '\x2', '\x392', '\x394', 
		'\x3', '\x2', '\x2', '\x2', '\x393', '\x395', '\x5', '\x82', '\x42', '\x2', 
		'\x394', '\x393', '\x3', '\x2', '\x2', '\x2', '\x394', '\x395', '\x3', 
		'\x2', '\x2', '\x2', '\x395', '\x396', '\x3', '\x2', '\x2', '\x2', '\x396', 
		'\x398', '\a', '\x7F', '\x2', '\x2', '\x397', '\x399', '\x5', '\\', '/', 
		'\x2', '\x398', '\x397', '\x3', '\x2', '\x2', '\x2', '\x398', '\x399', 
		'\x3', '\x2', '\x2', '\x2', '\x399', '\x39A', '\x3', '\x2', '\x2', '\x2', 
		'\x39A', '\x39B', '\a', '\x80', '\x2', '\x2', '\x39B', '[', '\x3', '\x2', 
		'\x2', '\x2', '\x39C', '\x3A1', '\x5', '^', '\x30', '\x2', '\x39D', '\x39E', 
		'\a', 'v', '\x2', '\x2', '\x39E', '\x3A0', '\x5', '^', '\x30', '\x2', 
		'\x39F', '\x39D', '\x3', '\x2', '\x2', '\x2', '\x3A0', '\x3A3', '\x3', 
		'\x2', '\x2', '\x2', '\x3A1', '\x39F', '\x3', '\x2', '\x2', '\x2', '\x3A1', 
		'\x3A2', '\x3', '\x2', '\x2', '\x2', '\x3A2', '\x3A5', '\x3', '\x2', '\x2', 
		'\x2', '\x3A3', '\x3A1', '\x3', '\x2', '\x2', '\x2', '\x3A4', '\x3A6', 
		'\a', 'v', '\x2', '\x2', '\x3A5', '\x3A4', '\x3', '\x2', '\x2', '\x2', 
		'\x3A5', '\x3A6', '\x3', '\x2', '\x2', '\x2', '\x3A6', ']', '\x3', '\x2', 
		'\x2', '\x2', '\x3A7', '\x3A9', '\x5', '\x90', 'I', '\x2', '\x3A8', '\x3A7', 
		'\x3', '\x2', '\x2', '\x2', '\x3A9', '\x3AC', '\x3', '\x2', '\x2', '\x2', 
		'\x3AA', '\x3A8', '\x3', '\x2', '\x2', '\x2', '\x3AA', '\x3AB', '\x3', 
		'\x2', '\x2', '\x2', '\x3AB', '\x3AE', '\x3', '\x2', '\x2', '\x2', '\x3AC', 
		'\x3AA', '\x3', '\x2', '\x2', '\x2', '\x3AD', '\x3AF', '\x5', '\x17A', 
		'\xBE', '\x2', '\x3AE', '\x3AD', '\x3', '\x2', '\x2', '\x2', '\x3AE', 
		'\x3AF', '\x3', '\x2', '\x2', '\x2', '\x3AF', '\x3B0', '\x3', '\x2', '\x2', 
		'\x2', '\x3B0', '\x3B4', '\x5', '\x17C', '\xBF', '\x2', '\x3B1', '\x3B5', 
		'\x5', '`', '\x31', '\x2', '\x3B2', '\x3B5', '\x5', '\x62', '\x32', '\x2', 
		'\x3B3', '\x3B5', '\x5', '\x64', '\x33', '\x2', '\x3B4', '\x3B1', '\x3', 
		'\x2', '\x2', '\x2', '\x3B4', '\x3B2', '\x3', '\x2', '\x2', '\x2', '\x3B4', 
		'\x3B3', '\x3', '\x2', '\x2', '\x2', '\x3B4', '\x3B5', '\x3', '\x2', '\x2', 
		'\x2', '\x3B5', '_', '\x3', '\x2', '\x2', '\x2', '\x3B6', '\x3B8', '\a', 
		'\x83', '\x2', '\x2', '\x3B7', '\x3B9', '\x5', 'V', ',', '\x2', '\x3B8', 
		'\x3B7', '\x3', '\x2', '\x2', '\x2', '\x3B8', '\x3B9', '\x3', '\x2', '\x2', 
		'\x2', '\x3B9', '\x3BA', '\x3', '\x2', '\x2', '\x2', '\x3BA', '\x3BB', 
		'\a', '\x84', '\x2', '\x2', '\x3BB', '\x61', '\x3', '\x2', '\x2', '\x2', 
		'\x3BC', '\x3BE', '\a', '\x7F', '\x2', '\x2', '\x3BD', '\x3BF', '\x5', 
		'R', '*', '\x2', '\x3BE', '\x3BD', '\x3', '\x2', '\x2', '\x2', '\x3BE', 
		'\x3BF', '\x3', '\x2', '\x2', '\x2', '\x3BF', '\x3C0', '\x3', '\x2', '\x2', 
		'\x2', '\x3C0', '\x3C1', '\a', '\x80', '\x2', '\x2', '\x3C1', '\x63', 
		'\x3', '\x2', '\x2', '\x2', '\x3C2', '\x3C3', '\a', 'i', '\x2', '\x2', 
		'\x3C3', '\x3C4', '\x5', '\x9C', 'O', '\x2', '\x3C4', '\x65', '\x3', '\x2', 
		'\x2', '\x2', '\x3C5', '\x3C6', '\a', '\x36', '\x2', '\x2', '\x3C6', '\x3C8', 
		'\x5', '\x17C', '\xBF', '\x2', '\x3C7', '\x3C9', '\x5', 'x', '=', '\x2', 
		'\x3C8', '\x3C7', '\x3', '\x2', '\x2', '\x2', '\x3C8', '\x3C9', '\x3', 
		'\x2', '\x2', '\x2', '\x3C9', '\x3CB', '\x3', '\x2', '\x2', '\x2', '\x3CA', 
		'\x3CC', '\x5', '\x82', '\x42', '\x2', '\x3CB', '\x3CA', '\x3', '\x2', 
		'\x2', '\x2', '\x3CB', '\x3CC', '\x3', '\x2', '\x2', '\x2', '\x3CC', '\x3CD', 
		'\x3', '\x2', '\x2', '\x2', '\x3CD', '\x3CE', '\a', '\x7F', '\x2', '\x2', 
		'\x3CE', '\x3CF', '\x5', 'R', '*', '\x2', '\x3CF', '\x3D0', '\a', '\x80', 
		'\x2', '\x2', '\x3D0', 'g', '\x3', '\x2', '\x2', '\x2', '\x3D1', '\x3D4', 
		'\a', '\x5', '\x2', '\x2', '\x3D2', '\x3D5', '\x5', '\x17C', '\xBF', '\x2', 
		'\x3D3', '\x3D5', '\a', 'q', '\x2', '\x2', '\x3D4', '\x3D2', '\x3', '\x2', 
		'\x2', '\x2', '\x3D4', '\x3D3', '\x3', '\x2', '\x2', '\x2', '\x3D5', '\x3D6', 
		'\x3', '\x2', '\x2', '\x2', '\x3D6', '\x3D7', '\a', 'x', '\x2', '\x2', 
		'\x3D7', '\x3DA', '\x5', '\x120', '\x91', '\x2', '\x3D8', '\x3D9', '\a', 
		'i', '\x2', '\x2', '\x3D9', '\x3DB', '\x5', '\x9C', 'O', '\x2', '\x3DA', 
		'\x3D8', '\x3', '\x2', '\x2', '\x2', '\x3DA', '\x3DB', '\x3', '\x2', '\x2', 
		'\x2', '\x3DB', '\x3DC', '\x3', '\x2', '\x2', '\x2', '\x3DC', '\x3DD', 
		'\a', 'w', '\x2', '\x2', '\x3DD', 'i', '\x3', '\x2', '\x2', '\x2', '\x3DE', 
		'\x3E0', '\a', '\x1C', '\x2', '\x2', '\x3DF', '\x3E1', '\a', '\x16', '\x2', 
		'\x2', '\x3E0', '\x3DF', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3E1', 
		'\x3', '\x2', '\x2', '\x2', '\x3E1', '\x3E2', '\x3', '\x2', '\x2', '\x2', 
		'\x3E2', '\x3E3', '\x5', '\x17C', '\xBF', '\x2', '\x3E3', '\x3E4', '\a', 
		'x', '\x2', '\x2', '\x3E4', '\x3E7', '\x5', '\x120', '\x91', '\x2', '\x3E5', 
		'\x3E6', '\a', 'i', '\x2', '\x2', '\x3E6', '\x3E8', '\x5', '\x9C', 'O', 
		'\x2', '\x3E7', '\x3E5', '\x3', '\x2', '\x2', '\x2', '\x3E7', '\x3E8', 
		'\x3', '\x2', '\x2', '\x2', '\x3E8', '\x3E9', '\x3', '\x2', '\x2', '\x2', 
		'\x3E9', '\x3EA', '\a', 'w', '\x2', '\x2', '\x3EA', 'k', '\x3', '\x2', 
		'\x2', '\x2', '\x3EB', '\x3ED', '\a', '\"', '\x2', '\x2', '\x3EC', '\x3EB', 
		'\x3', '\x2', '\x2', '\x2', '\x3EC', '\x3ED', '\x3', '\x2', '\x2', '\x2', 
		'\x3ED', '\x3EE', '\x3', '\x2', '\x2', '\x2', '\x3EE', '\x3EF', '\a', 
		'\x1F', '\x2', '\x2', '\x3EF', '\x3F1', '\x5', '\x17C', '\xBF', '\x2', 
		'\x3F0', '\x3F2', '\x5', 'x', '=', '\x2', '\x3F1', '\x3F0', '\x3', '\x2', 
		'\x2', '\x2', '\x3F1', '\x3F2', '\x3', '\x2', '\x2', '\x2', '\x3F2', '\x3F7', 
		'\x3', '\x2', '\x2', '\x2', '\x3F3', '\x3F5', '\a', 'x', '\x2', '\x2', 
		'\x3F4', '\x3F6', '\x5', '\x14A', '\xA6', '\x2', '\x3F5', '\x3F4', '\x3', 
		'\x2', '\x2', '\x2', '\x3F5', '\x3F6', '\x3', '\x2', '\x2', '\x2', '\x3F6', 
		'\x3F8', '\x3', '\x2', '\x2', '\x2', '\x3F7', '\x3F3', '\x3', '\x2', '\x2', 
		'\x2', '\x3F7', '\x3F8', '\x3', '\x2', '\x2', '\x2', '\x3F8', '\x3FA', 
		'\x3', '\x2', '\x2', '\x2', '\x3F9', '\x3FB', '\x5', '\x82', '\x42', '\x2', 
		'\x3FA', '\x3F9', '\x3', '\x2', '\x2', '\x2', '\x3FA', '\x3FB', '\x3', 
		'\x2', '\x2', '\x2', '\x3FB', '\x3FC', '\x3', '\x2', '\x2', '\x2', '\x3FC', 
		'\x400', '\a', '\x7F', '\x2', '\x2', '\x3FD', '\x3FF', '\x5', '\x8E', 
		'H', '\x2', '\x3FE', '\x3FD', '\x3', '\x2', '\x2', '\x2', '\x3FF', '\x402', 
		'\x3', '\x2', '\x2', '\x2', '\x400', '\x3FE', '\x3', '\x2', '\x2', '\x2', 
		'\x400', '\x401', '\x3', '\x2', '\x2', '\x2', '\x401', '\x406', '\x3', 
		'\x2', '\x2', '\x2', '\x402', '\x400', '\x3', '\x2', '\x2', '\x2', '\x403', 
		'\x405', '\x5', '\x8C', 'G', '\x2', '\x404', '\x403', '\x3', '\x2', '\x2', 
		'\x2', '\x405', '\x408', '\x3', '\x2', '\x2', '\x2', '\x406', '\x404', 
		'\x3', '\x2', '\x2', '\x2', '\x406', '\x407', '\x3', '\x2', '\x2', '\x2', 
		'\x407', '\x409', '\x3', '\x2', '\x2', '\x2', '\x408', '\x406', '\x3', 
		'\x2', '\x2', '\x2', '\x409', '\x40A', '\a', '\x80', '\x2', '\x2', '\x40A', 
		'm', '\x3', '\x2', '\x2', '\x2', '\x40B', '\x40E', '\x5', 'p', '\x39', 
		'\x2', '\x40C', '\x40E', '\x5', 'r', ':', '\x2', '\x40D', '\x40B', '\x3', 
		'\x2', '\x2', '\x2', '\x40D', '\x40C', '\x3', '\x2', '\x2', '\x2', '\x40E', 
		'o', '\x3', '\x2', '\x2', '\x2', '\x40F', '\x411', '\a', '\xF', '\x2', 
		'\x2', '\x410', '\x412', '\x5', 'x', '=', '\x2', '\x411', '\x410', '\x3', 
		'\x2', '\x2', '\x2', '\x411', '\x412', '\x3', '\x2', '\x2', '\x2', '\x412', 
		'\x413', '\x3', '\x2', '\x2', '\x2', '\x413', '\x415', '\x5', '\x120', 
		'\x91', '\x2', '\x414', '\x416', '\x5', '\x82', '\x42', '\x2', '\x415', 
		'\x414', '\x3', '\x2', '\x2', '\x2', '\x415', '\x416', '\x3', '\x2', '\x2', 
		'\x2', '\x416', '\x417', '\x3', '\x2', '\x2', '\x2', '\x417', '\x41B', 
		'\a', '\x7F', '\x2', '\x2', '\x418', '\x41A', '\x5', '\x8E', 'H', '\x2', 
		'\x419', '\x418', '\x3', '\x2', '\x2', '\x2', '\x41A', '\x41D', '\x3', 
		'\x2', '\x2', '\x2', '\x41B', '\x419', '\x3', '\x2', '\x2', '\x2', '\x41B', 
		'\x41C', '\x3', '\x2', '\x2', '\x2', '\x41C', '\x421', '\x3', '\x2', '\x2', 
		'\x2', '\x41D', '\x41B', '\x3', '\x2', '\x2', '\x2', '\x41E', '\x420', 
		'\x5', '\x8C', 'G', '\x2', '\x41F', '\x41E', '\x3', '\x2', '\x2', '\x2', 
		'\x420', '\x423', '\x3', '\x2', '\x2', '\x2', '\x421', '\x41F', '\x3', 
		'\x2', '\x2', '\x2', '\x421', '\x422', '\x3', '\x2', '\x2', '\x2', '\x422', 
		'\x424', '\x3', '\x2', '\x2', '\x2', '\x423', '\x421', '\x3', '\x2', '\x2', 
		'\x2', '\x424', '\x425', '\a', '\x80', '\x2', '\x2', '\x425', 'q', '\x3', 
		'\x2', '\x2', '\x2', '\x426', '\x428', '\a', '\"', '\x2', '\x2', '\x427', 
		'\x426', '\x3', '\x2', '\x2', '\x2', '\x427', '\x428', '\x3', '\x2', '\x2', 
		'\x2', '\x428', '\x429', '\x3', '\x2', '\x2', '\x2', '\x429', '\x42B', 
		'\a', '\xF', '\x2', '\x2', '\x42A', '\x42C', '\x5', 'x', '=', '\x2', '\x42B', 
		'\x42A', '\x3', '\x2', '\x2', '\x2', '\x42B', '\x42C', '\x3', '\x2', '\x2', 
		'\x2', '\x42C', '\x42E', '\x3', '\x2', '\x2', '\x2', '\x42D', '\x42F', 
		'\a', 'Z', '\x2', '\x2', '\x42E', '\x42D', '\x3', '\x2', '\x2', '\x2', 
		'\x42E', '\x42F', '\x3', '\x2', '\x2', '\x2', '\x42F', '\x430', '\x3', 
		'\x2', '\x2', '\x2', '\x430', '\x431', '\x5', '\x172', '\xBA', '\x2', 
		'\x431', '\x432', '\a', '\r', '\x2', '\x2', '\x432', '\x434', '\x5', '\x120', 
		'\x91', '\x2', '\x433', '\x435', '\x5', '\x82', '\x42', '\x2', '\x434', 
		'\x433', '\x3', '\x2', '\x2', '\x2', '\x434', '\x435', '\x3', '\x2', '\x2', 
		'\x2', '\x435', '\x436', '\x3', '\x2', '\x2', '\x2', '\x436', '\x43A', 
		'\a', '\x7F', '\x2', '\x2', '\x437', '\x439', '\x5', '\x8E', 'H', '\x2', 
		'\x438', '\x437', '\x3', '\x2', '\x2', '\x2', '\x439', '\x43C', '\x3', 
		'\x2', '\x2', '\x2', '\x43A', '\x438', '\x3', '\x2', '\x2', '\x2', '\x43A', 
		'\x43B', '\x3', '\x2', '\x2', '\x2', '\x43B', '\x440', '\x3', '\x2', '\x2', 
		'\x2', '\x43C', '\x43A', '\x3', '\x2', '\x2', '\x2', '\x43D', '\x43F', 
		'\x5', '\x8C', 'G', '\x2', '\x43E', '\x43D', '\x3', '\x2', '\x2', '\x2', 
		'\x43F', '\x442', '\x3', '\x2', '\x2', '\x2', '\x440', '\x43E', '\x3', 
		'\x2', '\x2', '\x2', '\x440', '\x441', '\x3', '\x2', '\x2', '\x2', '\x441', 
		'\x443', '\x3', '\x2', '\x2', '\x2', '\x442', '\x440', '\x3', '\x2', '\x2', 
		'\x2', '\x443', '\x444', '\a', '\x80', '\x2', '\x2', '\x444', 's', '\x3', 
		'\x2', '\x2', '\x2', '\x445', '\x447', '\a', '\"', '\x2', '\x2', '\x446', 
		'\x445', '\x3', '\x2', '\x2', '\x2', '\x446', '\x447', '\x3', '\x2', '\x2', 
		'\x2', '\x447', '\x448', '\x3', '\x2', '\x2', '\x2', '\x448', '\x44A', 
		'\a', '\n', '\x2', '\x2', '\x449', '\x44B', '\x5', ':', '\x1E', '\x2', 
		'\x44A', '\x449', '\x3', '\x2', '\x2', '\x2', '\x44A', '\x44B', '\x3', 
		'\x2', '\x2', '\x2', '\x44B', '\x44C', '\x3', '\x2', '\x2', '\x2', '\x44C', 
		'\x450', '\a', '\x7F', '\x2', '\x2', '\x44D', '\x44F', '\x5', '\x8E', 
		'H', '\x2', '\x44E', '\x44D', '\x3', '\x2', '\x2', '\x2', '\x44F', '\x452', 
		'\x3', '\x2', '\x2', '\x2', '\x450', '\x44E', '\x3', '\x2', '\x2', '\x2', 
		'\x450', '\x451', '\x3', '\x2', '\x2', '\x2', '\x451', '\x456', '\x3', 
		'\x2', '\x2', '\x2', '\x452', '\x450', '\x3', '\x2', '\x2', '\x2', '\x453', 
		'\x455', '\x5', 'v', '<', '\x2', '\x454', '\x453', '\x3', '\x2', '\x2', 
		'\x2', '\x455', '\x458', '\x3', '\x2', '\x2', '\x2', '\x456', '\x454', 
		'\x3', '\x2', '\x2', '\x2', '\x456', '\x457', '\x3', '\x2', '\x2', '\x2', 
		'\x457', '\x459', '\x3', '\x2', '\x2', '\x2', '\x458', '\x456', '\x3', 
		'\x2', '\x2', '\x2', '\x459', '\x45A', '\a', '\x80', '\x2', '\x2', '\x45A', 
		'u', '\x3', '\x2', '\x2', '\x2', '\x45B', '\x45D', '\x5', '\x90', 'I', 
		'\x2', '\x45C', '\x45B', '\x3', '\x2', '\x2', '\x2', '\x45D', '\x460', 
		'\x3', '\x2', '\x2', '\x2', '\x45E', '\x45C', '\x3', '\x2', '\x2', '\x2', 
		'\x45E', '\x45F', '\x3', '\x2', '\x2', '\x2', '\x45F', '\x469', '\x3', 
		'\x2', '\x2', '\x2', '\x460', '\x45E', '\x3', '\x2', '\x2', '\x2', '\x461', 
		'\x46A', '\x5', '\f', '\a', '\x2', '\x462', '\x464', '\x5', '\x17A', '\xBE', 
		'\x2', '\x463', '\x462', '\x3', '\x2', '\x2', '\x2', '\x463', '\x464', 
		'\x3', '\x2', '\x2', '\x2', '\x464', '\x467', '\x3', '\x2', '\x2', '\x2', 
		'\x465', '\x468', '\x5', 'j', '\x36', '\x2', '\x466', '\x468', '\x5', 
		'\x36', '\x1C', '\x2', '\x467', '\x465', '\x3', '\x2', '\x2', '\x2', '\x467', 
		'\x466', '\x3', '\x2', '\x2', '\x2', '\x468', '\x46A', '\x3', '\x2', '\x2', 
		'\x2', '\x469', '\x461', '\x3', '\x2', '\x2', '\x2', '\x469', '\x463', 
		'\x3', '\x2', '\x2', '\x2', '\x46A', 'w', '\x3', '\x2', '\x2', '\x2', 
		'\x46B', '\x478', '\a', 'm', '\x2', '\x2', '\x46C', '\x46D', '\x5', 'z', 
		'>', '\x2', '\x46D', '\x46E', '\a', 'v', '\x2', '\x2', '\x46E', '\x470', 
		'\x3', '\x2', '\x2', '\x2', '\x46F', '\x46C', '\x3', '\x2', '\x2', '\x2', 
		'\x470', '\x473', '\x3', '\x2', '\x2', '\x2', '\x471', '\x46F', '\x3', 
		'\x2', '\x2', '\x2', '\x471', '\x472', '\x3', '\x2', '\x2', '\x2', '\x472', 
		'\x474', '\x3', '\x2', '\x2', '\x2', '\x473', '\x471', '\x3', '\x2', '\x2', 
		'\x2', '\x474', '\x476', '\x5', 'z', '>', '\x2', '\x475', '\x477', '\a', 
		'v', '\x2', '\x2', '\x476', '\x475', '\x3', '\x2', '\x2', '\x2', '\x476', 
		'\x477', '\x3', '\x2', '\x2', '\x2', '\x477', '\x479', '\x3', '\x2', '\x2', 
		'\x2', '\x478', '\x471', '\x3', '\x2', '\x2', '\x2', '\x478', '\x479', 
		'\x3', '\x2', '\x2', '\x2', '\x479', '\x47A', '\x3', '\x2', '\x2', '\x2', 
		'\x47A', '\x47B', '\a', 'l', '\x2', '\x2', '\x47B', 'y', '\x3', '\x2', 
		'\x2', '\x2', '\x47C', '\x47E', '\x5', '\x90', 'I', '\x2', '\x47D', '\x47C', 
		'\x3', '\x2', '\x2', '\x2', '\x47E', '\x481', '\x3', '\x2', '\x2', '\x2', 
		'\x47F', '\x47D', '\x3', '\x2', '\x2', '\x2', '\x47F', '\x480', '\x3', 
		'\x2', '\x2', '\x2', '\x480', '\x485', '\x3', '\x2', '\x2', '\x2', '\x481', 
		'\x47F', '\x3', '\x2', '\x2', '\x2', '\x482', '\x486', '\x5', '|', '?', 
		'\x2', '\x483', '\x486', '\x5', '~', '@', '\x2', '\x484', '\x486', '\x5', 
		'\x80', '\x41', '\x2', '\x485', '\x482', '\x3', '\x2', '\x2', '\x2', '\x485', 
		'\x483', '\x3', '\x2', '\x2', '\x2', '\x485', '\x484', '\x3', '\x2', '\x2', 
		'\x2', '\x486', '{', '\x3', '\x2', '\x2', '\x2', '\x487', '\x489', '\x5', 
		'\x90', 'I', '\x2', '\x488', '\x487', '\x3', '\x2', '\x2', '\x2', '\x488', 
		'\x489', '\x3', '\x2', '\x2', '\x2', '\x489', '\x48A', '\x3', '\x2', '\x2', 
		'\x2', '\x48A', '\x48D', '\a', 'S', '\x2', '\x2', '\x48B', '\x48C', '\a', 
		'x', '\x2', '\x2', '\x48C', '\x48E', '\x5', '\x150', '\xA9', '\x2', '\x48D', 
		'\x48B', '\x3', '\x2', '\x2', '\x2', '\x48D', '\x48E', '\x3', '\x2', '\x2', 
		'\x2', '\x48E', '}', '\x3', '\x2', '\x2', '\x2', '\x48F', '\x491', '\x5', 
		'\x90', 'I', '\x2', '\x490', '\x48F', '\x3', '\x2', '\x2', '\x2', '\x490', 
		'\x491', '\x3', '\x2', '\x2', '\x2', '\x491', '\x492', '\x3', '\x2', '\x2', 
		'\x2', '\x492', '\x497', '\x5', '\x17C', '\xBF', '\x2', '\x493', '\x495', 
		'\a', 'x', '\x2', '\x2', '\x494', '\x496', '\x5', '\x14A', '\xA6', '\x2', 
		'\x495', '\x494', '\x3', '\x2', '\x2', '\x2', '\x495', '\x496', '\x3', 
		'\x2', '\x2', '\x2', '\x496', '\x498', '\x3', '\x2', '\x2', '\x2', '\x497', 
		'\x493', '\x3', '\x2', '\x2', '\x2', '\x497', '\x498', '\x3', '\x2', '\x2', 
		'\x2', '\x498', '\x49B', '\x3', '\x2', '\x2', '\x2', '\x499', '\x49A', 
		'\a', 'i', '\x2', '\x2', '\x49A', '\x49C', '\x5', '\x120', '\x91', '\x2', 
		'\x49B', '\x499', '\x3', '\x2', '\x2', '\x2', '\x49B', '\x49C', '\x3', 
		'\x2', '\x2', '\x2', '\x49C', '\x7F', '\x3', '\x2', '\x2', '\x2', '\x49D', 
		'\x49E', '\a', '\x5', '\x2', '\x2', '\x49E', '\x49F', '\x5', '\x17C', 
		'\xBF', '\x2', '\x49F', '\x4A0', '\a', 'x', '\x2', '\x2', '\x4A0', '\x4A1', 
		'\x5', '\x120', '\x91', '\x2', '\x4A1', '\x81', '\x3', '\x2', '\x2', '\x2', 
		'\x4A2', '\x4A8', '\a', '$', '\x2', '\x2', '\x4A3', '\x4A4', '\x5', '\x84', 
		'\x43', '\x2', '\x4A4', '\x4A5', '\a', 'v', '\x2', '\x2', '\x4A5', '\x4A7', 
		'\x3', '\x2', '\x2', '\x2', '\x4A6', '\x4A3', '\x3', '\x2', '\x2', '\x2', 
		'\x4A7', '\x4AA', '\x3', '\x2', '\x2', '\x2', '\x4A8', '\x4A6', '\x3', 
		'\x2', '\x2', '\x2', '\x4A8', '\x4A9', '\x3', '\x2', '\x2', '\x2', '\x4A9', 
		'\x4AC', '\x3', '\x2', '\x2', '\x2', '\x4AA', '\x4A8', '\x3', '\x2', '\x2', 
		'\x2', '\x4AB', '\x4AD', '\x5', '\x84', '\x43', '\x2', '\x4AC', '\x4AB', 
		'\x3', '\x2', '\x2', '\x2', '\x4AC', '\x4AD', '\x3', '\x2', '\x2', '\x2', 
		'\x4AD', '\x83', '\x3', '\x2', '\x2', '\x2', '\x4AE', '\x4B1', '\x5', 
		'\x86', '\x44', '\x2', '\x4AF', '\x4B1', '\x5', '\x88', '\x45', '\x2', 
		'\x4B0', '\x4AE', '\x3', '\x2', '\x2', '\x2', '\x4B0', '\x4AF', '\x3', 
		'\x2', '\x2', '\x2', '\x4B1', '\x85', '\x3', '\x2', '\x2', '\x2', '\x4B2', 
		'\x4B3', '\x5', '\x152', '\xAA', '\x2', '\x4B3', '\x4B4', '\a', 'x', '\x2', 
		'\x2', '\x4B4', '\x4B5', '\x5', '\x150', '\xA9', '\x2', '\x4B5', '\x87', 
		'\x3', '\x2', '\x2', '\x2', '\x4B6', '\x4B8', '\x5', '\x8A', '\x46', '\x2', 
		'\x4B7', '\x4B6', '\x3', '\x2', '\x2', '\x2', '\x4B7', '\x4B8', '\x3', 
		'\x2', '\x2', '\x2', '\x4B8', '\x4B9', '\x3', '\x2', '\x2', '\x2', '\x4B9', 
		'\x4BA', '\x5', '\x120', '\x91', '\x2', '\x4BA', '\x4BC', '\a', 'x', '\x2', 
		'\x2', '\x4BB', '\x4BD', '\x5', '\x14A', '\xA6', '\x2', '\x4BC', '\x4BB', 
		'\x3', '\x2', '\x2', '\x2', '\x4BC', '\x4BD', '\x3', '\x2', '\x2', '\x2', 
		'\x4BD', '\x89', '\x3', '\x2', '\x2', '\x2', '\x4BE', '\x4BF', '\a', '\r', 
		'\x2', '\x2', '\x4BF', '\x4C0', '\x5', 'x', '=', '\x2', '\x4C0', '\x8B', 
		'\x3', '\x2', '\x2', '\x2', '\x4C1', '\x4C3', '\x5', '\x90', 'I', '\x2', 
		'\x4C2', '\x4C1', '\x3', '\x2', '\x2', '\x2', '\x4C3', '\x4C6', '\x3', 
		'\x2', '\x2', '\x2', '\x4C4', '\x4C2', '\x3', '\x2', '\x2', '\x2', '\x4C4', 
		'\x4C5', '\x3', '\x2', '\x2', '\x2', '\x4C5', '\x4D0', '\x3', '\x2', '\x2', 
		'\x2', '\x4C6', '\x4C4', '\x3', '\x2', '\x2', '\x2', '\x4C7', '\x4D1', 
		'\x5', '\f', '\a', '\x2', '\x4C8', '\x4CA', '\x5', '\x17A', '\xBE', '\x2', 
		'\x4C9', '\x4C8', '\x3', '\x2', '\x2', '\x2', '\x4C9', '\x4CA', '\x3', 
		'\x2', '\x2', '\x2', '\x4CA', '\x4CE', '\x3', '\x2', '\x2', '\x2', '\x4CB', 
		'\x4CF', '\x5', 'J', '&', '\x2', '\x4CC', '\x4CF', '\x5', 'h', '\x35', 
		'\x2', '\x4CD', '\x4CF', '\x5', '\x36', '\x1C', '\x2', '\x4CE', '\x4CB', 
		'\x3', '\x2', '\x2', '\x2', '\x4CE', '\x4CC', '\x3', '\x2', '\x2', '\x2', 
		'\x4CE', '\x4CD', '\x3', '\x2', '\x2', '\x2', '\x4CF', '\x4D1', '\x3', 
		'\x2', '\x2', '\x2', '\x4D0', '\x4C7', '\x3', '\x2', '\x2', '\x2', '\x4D0', 
		'\x4C9', '\x3', '\x2', '\x2', '\x2', '\x4D1', '\x8D', '\x3', '\x2', '\x2', 
		'\x2', '\x4D2', '\x4D3', '\a', '|', '\x2', '\x2', '\x4D3', '\x4D4', '\a', 
		'Z', '\x2', '\x2', '\x4D4', '\x4D5', '\a', '\x81', '\x2', '\x2', '\x4D5', 
		'\x4D6', '\x5', '\x92', 'J', '\x2', '\x4D6', '\x4D7', '\a', '\x82', '\x2', 
		'\x2', '\x4D7', '\x8F', '\x3', '\x2', '\x2', '\x2', '\x4D8', '\x4D9', 
		'\a', '|', '\x2', '\x2', '\x4D9', '\x4DA', '\a', '\x81', '\x2', '\x2', 
		'\x4DA', '\x4DB', '\x5', '\x92', 'J', '\x2', '\x4DB', '\x4DC', '\a', '\x82', 
		'\x2', '\x2', '\x4DC', '\x91', '\x3', '\x2', '\x2', '\x2', '\x4DD', '\x4DF', 
		'\x5', '\x154', '\xAB', '\x2', '\x4DE', '\x4E0', '\x5', '\x94', 'K', '\x2', 
		'\x4DF', '\x4DE', '\x3', '\x2', '\x2', '\x2', '\x4DF', '\x4E0', '\x3', 
		'\x2', '\x2', '\x2', '\x4E0', '\x93', '\x3', '\x2', '\x2', '\x2', '\x4E1', 
		'\x4E5', '\x5', '\x6', '\x4', '\x2', '\x4E2', '\x4E3', '\a', 'i', '\x2', 
		'\x2', '\x4E3', '\x4E5', '\x5', '\xA4', 'S', '\x2', '\x4E4', '\x4E1', 
		'\x3', '\x2', '\x2', '\x2', '\x4E4', '\x4E2', '\x3', '\x2', '\x2', '\x2', 
		'\x4E5', '\x95', '\x3', '\x2', '\x2', '\x2', '\x4E6', '\x4EC', '\a', 'w', 
		'\x2', '\x2', '\x4E7', '\x4EC', '\x5', '$', '\x13', '\x2', '\x4E8', '\x4EC', 
		'\x5', '\x98', 'M', '\x2', '\x4E9', '\x4EC', '\x5', '\x9A', 'N', '\x2', 
		'\x4EA', '\x4EC', '\x5', '\f', '\a', '\x2', '\x4EB', '\x4E6', '\x3', '\x2', 
		'\x2', '\x2', '\x4EB', '\x4E7', '\x3', '\x2', '\x2', '\x2', '\x4EB', '\x4E8', 
		'\x3', '\x2', '\x2', '\x2', '\x4EB', '\x4E9', '\x3', '\x2', '\x2', '\x2', 
		'\x4EB', '\x4EA', '\x3', '\x2', '\x2', '\x2', '\x4EC', '\x97', '\x3', 
		'\x2', '\x2', '\x2', '\x4ED', '\x4EF', '\x5', '\x90', 'I', '\x2', '\x4EE', 
		'\x4ED', '\x3', '\x2', '\x2', '\x2', '\x4EF', '\x4F2', '\x3', '\x2', '\x2', 
		'\x2', '\x4F0', '\x4EE', '\x3', '\x2', '\x2', '\x2', '\x4F0', '\x4F1', 
		'\x3', '\x2', '\x2', '\x2', '\x4F1', '\x4F3', '\x3', '\x2', '\x2', '\x2', 
		'\x4F2', '\x4F0', '\x3', '\x2', '\x2', '\x2', '\x4F3', '\x4F4', '\a', 
		'\x11', '\x2', '\x2', '\x4F4', '\x4F7', '\x5', '\xF4', '{', '\x2', '\x4F5', 
		'\x4F6', '\a', 'x', '\x2', '\x2', '\x4F6', '\x4F8', '\x5', '\x120', '\x91', 
		'\x2', '\x4F7', '\x4F5', '\x3', '\x2', '\x2', '\x2', '\x4F7', '\x4F8', 
		'\x3', '\x2', '\x2', '\x2', '\x4F8', '\x4FB', '\x3', '\x2', '\x2', '\x2', 
		'\x4F9', '\x4FA', '\a', 'i', '\x2', '\x2', '\x4FA', '\x4FC', '\x5', '\x9C', 
		'O', '\x2', '\x4FB', '\x4F9', '\x3', '\x2', '\x2', '\x2', '\x4FB', '\x4FC', 
		'\x3', '\x2', '\x2', '\x2', '\x4FC', '\x4FD', '\x3', '\x2', '\x2', '\x2', 
		'\x4FD', '\x4FE', '\a', 'w', '\x2', '\x2', '\x4FE', '\x99', '\x3', '\x2', 
		'\x2', '\x2', '\x4FF', '\x500', '\x5', '\x9C', 'O', '\x2', '\x500', '\x501', 
		'\a', 'w', '\x2', '\x2', '\x501', '\x507', '\x3', '\x2', '\x2', '\x2', 
		'\x502', '\x504', '\x5', '\xA2', 'R', '\x2', '\x503', '\x505', '\a', 'w', 
		'\x2', '\x2', '\x504', '\x503', '\x3', '\x2', '\x2', '\x2', '\x504', '\x505', 
		'\x3', '\x2', '\x2', '\x2', '\x505', '\x507', '\x3', '\x2', '\x2', '\x2', 
		'\x506', '\x4FF', '\x3', '\x2', '\x2', '\x2', '\x506', '\x502', '\x3', 
		'\x2', '\x2', '\x2', '\x507', '\x9B', '\x3', '\x2', '\x2', '\x2', '\x508', 
		'\x50A', '\b', 'O', '\x1', '\x2', '\x509', '\x50B', '\x5', '\x90', 'I', 
		'\x2', '\x50A', '\x509', '\x3', '\x2', '\x2', '\x2', '\x50B', '\x50C', 
		'\x3', '\x2', '\x2', '\x2', '\x50C', '\x50A', '\x3', '\x2', '\x2', '\x2', 
		'\x50C', '\x50D', '\x3', '\x2', '\x2', '\x2', '\x50D', '\x50E', '\x3', 
		'\x2', '\x2', '\x2', '\x50E', '\x50F', '\x5', '\x9C', 'O', '*', '\x50F', 
		'\x559', '\x3', '\x2', '\x2', '\x2', '\x510', '\x559', '\x5', '\xA4', 
		'S', '\x2', '\x511', '\x559', '\x5', '\xA6', 'T', '\x2', '\x512', '\x514', 
		'\t', '\x4', '\x2', '\x2', '\x513', '\x515', '\a', '\x16', '\x2', '\x2', 
		'\x514', '\x513', '\x3', '\x2', '\x2', '\x2', '\x514', '\x515', '\x3', 
		'\x2', '\x2', '\x2', '\x515', '\x516', '\x3', '\x2', '\x2', '\x2', '\x516', 
		'\x559', '\x5', '\x9C', 'O', ' ', '\x517', '\x518', '\a', 'V', '\x2', 
		'\x2', '\x518', '\x559', '\x5', '\x9C', 'O', '\x1F', '\x519', '\x51A', 
		'\t', '\x5', '\x2', '\x2', '\x51A', '\x559', '\x5', '\x9C', 'O', '\x1E', 
		'\x51B', '\x51D', '\a', 's', '\x2', '\x2', '\x51C', '\x51E', '\x5', '\x9C', 
		'O', '\x2', '\x51D', '\x51C', '\x3', '\x2', '\x2', '\x2', '\x51D', '\x51E', 
		'\x3', '\x2', '\x2', '\x2', '\x51E', '\x559', '\x3', '\x2', '\x2', '\x2', 
		'\x51F', '\x520', '\a', 'u', '\x2', '\x2', '\x520', '\x559', '\x5', '\x9C', 
		'O', '\x11', '\x521', '\x523', '\a', '\x6', '\x2', '\x2', '\x522', '\x524', 
		'\a', 'S', '\x2', '\x2', '\x523', '\x522', '\x3', '\x2', '\x2', '\x2', 
		'\x523', '\x524', '\x3', '\x2', '\x2', '\x2', '\x524', '\x526', '\x3', 
		'\x2', '\x2', '\x2', '\x525', '\x527', '\x5', '\x9C', 'O', '\x2', '\x526', 
		'\x525', '\x3', '\x2', '\x2', '\x2', '\x526', '\x527', '\x3', '\x2', '\x2', 
		'\x2', '\x527', '\x559', '\x3', '\x2', '\x2', '\x2', '\x528', '\x52A', 
		'\a', '\x4', '\x2', '\x2', '\x529', '\x52B', '\a', 'S', '\x2', '\x2', 
		'\x52A', '\x529', '\x3', '\x2', '\x2', '\x2', '\x52A', '\x52B', '\x3', 
		'\x2', '\x2', '\x2', '\x52B', '\x52D', '\x3', '\x2', '\x2', '\x2', '\x52C', 
		'\x52E', '\x5', '\x9C', 'O', '\x2', '\x52D', '\x52C', '\x3', '\x2', '\x2', 
		'\x2', '\x52D', '\x52E', '\x3', '\x2', '\x2', '\x2', '\x52E', '\x559', 
		'\x3', '\x2', '\x2', '\x2', '\x52F', '\x531', '\a', '\x19', '\x2', '\x2', 
		'\x530', '\x532', '\x5', '\x9C', 'O', '\x2', '\x531', '\x530', '\x3', 
		'\x2', '\x2', '\x2', '\x531', '\x532', '\x3', '\x2', '\x2', '\x2', '\x532', 
		'\x559', '\x3', '\x2', '\x2', '\x2', '\x533', '\x537', '\a', '\x83', '\x2', 
		'\x2', '\x534', '\x536', '\x5', '\x8E', 'H', '\x2', '\x535', '\x534', 
		'\x3', '\x2', '\x2', '\x2', '\x536', '\x539', '\x3', '\x2', '\x2', '\x2', 
		'\x537', '\x535', '\x3', '\x2', '\x2', '\x2', '\x537', '\x538', '\x3', 
		'\x2', '\x2', '\x2', '\x538', '\x53A', '\x3', '\x2', '\x2', '\x2', '\x539', 
		'\x537', '\x3', '\x2', '\x2', '\x2', '\x53A', '\x53B', '\x5', '\x9C', 
		'O', '\x2', '\x53B', '\x53C', '\a', '\x84', '\x2', '\x2', '\x53C', '\x559', 
		'\x3', '\x2', '\x2', '\x2', '\x53D', '\x541', '\a', '\x81', '\x2', '\x2', 
		'\x53E', '\x540', '\x5', '\x8E', 'H', '\x2', '\x53F', '\x53E', '\x3', 
		'\x2', '\x2', '\x2', '\x540', '\x543', '\x3', '\x2', '\x2', '\x2', '\x541', 
		'\x53F', '\x3', '\x2', '\x2', '\x2', '\x541', '\x542', '\x3', '\x2', '\x2', 
		'\x2', '\x542', '\x545', '\x3', '\x2', '\x2', '\x2', '\x543', '\x541', 
		'\x3', '\x2', '\x2', '\x2', '\x544', '\x546', '\x5', '\xB0', 'Y', '\x2', 
		'\x545', '\x544', '\x3', '\x2', '\x2', '\x2', '\x545', '\x546', '\x3', 
		'\x2', '\x2', '\x2', '\x546', '\x547', '\x3', '\x2', '\x2', '\x2', '\x547', 
		'\x559', '\a', '\x82', '\x2', '\x2', '\x548', '\x54C', '\a', '\x83', '\x2', 
		'\x2', '\x549', '\x54B', '\x5', '\x8E', 'H', '\x2', '\x54A', '\x549', 
		'\x3', '\x2', '\x2', '\x2', '\x54B', '\x54E', '\x3', '\x2', '\x2', '\x2', 
		'\x54C', '\x54A', '\x3', '\x2', '\x2', '\x2', '\x54C', '\x54D', '\x3', 
		'\x2', '\x2', '\x2', '\x54D', '\x550', '\x3', '\x2', '\x2', '\x2', '\x54E', 
		'\x54C', '\x3', '\x2', '\x2', '\x2', '\x54F', '\x551', '\x5', '\xB2', 
		'Z', '\x2', '\x550', '\x54F', '\x3', '\x2', '\x2', '\x2', '\x550', '\x551', 
		'\x3', '\x2', '\x2', '\x2', '\x551', '\x552', '\x3', '\x2', '\x2', '\x2', 
		'\x552', '\x559', '\a', '\x84', '\x2', '\x2', '\x553', '\x559', '\x5', 
		'\xB6', '\\', '\x2', '\x554', '\x559', '\x5', '\xC4', '\x63', '\x2', '\x555', 
		'\x559', '\x5', '\xD2', 'j', '\x2', '\x556', '\x559', '\x5', '\xA2', 'R', 
		'\x2', '\x557', '\x559', '\x5', '\x4', '\x3', '\x2', '\x558', '\x508', 
		'\x3', '\x2', '\x2', '\x2', '\x558', '\x510', '\x3', '\x2', '\x2', '\x2', 
		'\x558', '\x511', '\x3', '\x2', '\x2', '\x2', '\x558', '\x512', '\x3', 
		'\x2', '\x2', '\x2', '\x558', '\x517', '\x3', '\x2', '\x2', '\x2', '\x558', 
		'\x519', '\x3', '\x2', '\x2', '\x2', '\x558', '\x51B', '\x3', '\x2', '\x2', 
		'\x2', '\x558', '\x51F', '\x3', '\x2', '\x2', '\x2', '\x558', '\x521', 
		'\x3', '\x2', '\x2', '\x2', '\x558', '\x528', '\x3', '\x2', '\x2', '\x2', 
		'\x558', '\x52F', '\x3', '\x2', '\x2', '\x2', '\x558', '\x533', '\x3', 
		'\x2', '\x2', '\x2', '\x558', '\x53D', '\x3', '\x2', '\x2', '\x2', '\x558', 
		'\x548', '\x3', '\x2', '\x2', '\x2', '\x558', '\x553', '\x3', '\x2', '\x2', 
		'\x2', '\x558', '\x554', '\x3', '\x2', '\x2', '\x2', '\x558', '\x555', 
		'\x3', '\x2', '\x2', '\x2', '\x558', '\x556', '\x3', '\x2', '\x2', '\x2', 
		'\x558', '\x557', '\x3', '\x2', '\x2', '\x2', '\x559', '\x5AD', '\x3', 
		'\x2', '\x2', '\x2', '\x55A', '\x55B', '\f', '\x1C', '\x2', '\x2', '\x55B', 
		'\x55C', '\t', '\x6', '\x2', '\x2', '\x55C', '\x5AC', '\x5', '\x9C', 'O', 
		'\x1D', '\x55D', '\x55E', '\f', '\x1B', '\x2', '\x2', '\x55E', '\x55F', 
		'\t', '\a', '\x2', '\x2', '\x55F', '\x5AC', '\x5', '\x9C', 'O', '\x1C', 
		'\x560', '\x563', '\f', '\x1A', '\x2', '\x2', '\x561', '\x564', '\x5', 
		'\x186', '\xC4', '\x2', '\x562', '\x564', '\x5', '\x188', '\xC5', '\x2', 
		'\x563', '\x561', '\x3', '\x2', '\x2', '\x2', '\x563', '\x562', '\x3', 
		'\x2', '\x2', '\x2', '\x564', '\x565', '\x3', '\x2', '\x2', '\x2', '\x565', 
		'\x566', '\x5', '\x9C', 'O', '\x1B', '\x566', '\x5AC', '\x3', '\x2', '\x2', 
		'\x2', '\x567', '\x568', '\f', '\x19', '\x2', '\x2', '\x568', '\x569', 
		'\a', '[', '\x2', '\x2', '\x569', '\x5AC', '\x5', '\x9C', 'O', '\x1A', 
		'\x56A', '\x56B', '\f', '\x18', '\x2', '\x2', '\x56B', '\x56C', '\a', 
		'Y', '\x2', '\x2', '\x56C', '\x5AC', '\x5', '\x9C', 'O', '\x19', '\x56D', 
		'\x56E', '\f', '\x17', '\x2', '\x2', '\x56E', '\x56F', '\a', '\\', '\x2', 
		'\x2', '\x56F', '\x5AC', '\x5', '\x9C', 'O', '\x18', '\x570', '\x571', 
		'\f', '\x16', '\x2', '\x2', '\x571', '\x572', '\x5', '\x9E', 'P', '\x2', 
		'\x572', '\x573', '\x5', '\x9C', 'O', '\x17', '\x573', '\x5AC', '\x3', 
		'\x2', '\x2', '\x2', '\x574', '\x575', '\f', '\x15', '\x2', '\x2', '\x575', 
		'\x576', '\a', ']', '\x2', '\x2', '\x576', '\x5AC', '\x5', '\x9C', 'O', 
		'\x16', '\x577', '\x578', '\f', '\x14', '\x2', '\x2', '\x578', '\x579', 
		'\a', '^', '\x2', '\x2', '\x579', '\x5AC', '\x5', '\x9C', 'O', '\x15', 
		'\x57A', '\x57B', '\f', '\x10', '\x2', '\x2', '\x57B', '\x57C', '\a', 
		'u', '\x2', '\x2', '\x57C', '\x5AC', '\x5', '\x9C', 'O', '\x11', '\x57D', 
		'\x57E', '\f', '\xF', '\x2', '\x2', '\x57E', '\x57F', '\a', 'i', '\x2', 
		'\x2', '\x57F', '\x5AC', '\x5', '\x9C', 'O', '\x10', '\x580', '\x581', 
		'\f', '\xE', '\x2', '\x2', '\x581', '\x582', '\x5', '\xA0', 'Q', '\x2', 
		'\x582', '\x583', '\x5', '\x9C', 'O', '\xF', '\x583', '\x5AC', '\x3', 
		'\x2', '\x2', '\x2', '\x584', '\x585', '\f', '\'', '\x2', '\x2', '\x585', 
		'\x586', '\a', 'r', '\x2', '\x2', '\x586', '\x587', '\x5', '\x15A', '\xAE', 
		'\x2', '\x587', '\x589', '\a', '\x83', '\x2', '\x2', '\x588', '\x58A', 
		'\x5', '\xD0', 'i', '\x2', '\x589', '\x588', '\x3', '\x2', '\x2', '\x2', 
		'\x589', '\x58A', '\x3', '\x2', '\x2', '\x2', '\x58A', '\x58B', '\x3', 
		'\x2', '\x2', '\x2', '\x58B', '\x58C', '\a', '\x84', '\x2', '\x2', '\x58C', 
		'\x5AC', '\x3', '\x2', '\x2', '\x2', '\x58D', '\x58E', '\f', '&', '\x2', 
		'\x2', '\x58E', '\x58F', '\a', 'r', '\x2', '\x2', '\x58F', '\x5AC', '\x5', 
		'\x17C', '\xBF', '\x2', '\x590', '\x591', '\f', '%', '\x2', '\x2', '\x591', 
		'\x592', '\a', 'r', '\x2', '\x2', '\x592', '\x5AC', '\x5', '\xB4', '[', 
		'\x2', '\x593', '\x594', '\f', '$', '\x2', '\x2', '\x594', '\x595', '\a', 
		'r', '\x2', '\x2', '\x595', '\x5AC', '\a', '\'', '\x2', '\x2', '\x596', 
		'\x597', '\f', '#', '\x2', '\x2', '\x597', '\x599', '\a', '\x83', '\x2', 
		'\x2', '\x598', '\x59A', '\x5', '\xD0', 'i', '\x2', '\x599', '\x598', 
		'\x3', '\x2', '\x2', '\x2', '\x599', '\x59A', '\x3', '\x2', '\x2', '\x2', 
		'\x59A', '\x59B', '\x3', '\x2', '\x2', '\x2', '\x59B', '\x5AC', '\a', 
		'\x84', '\x2', '\x2', '\x59C', '\x59D', '\f', '\"', '\x2', '\x2', '\x59D', 
		'\x59E', '\a', '\x81', '\x2', '\x2', '\x59E', '\x59F', '\x5', '\x9C', 
		'O', '\x2', '\x59F', '\x5A0', '\a', '\x82', '\x2', '\x2', '\x5A0', '\x5AC', 
		'\x3', '\x2', '\x2', '\x2', '\x5A1', '\x5A2', '\f', '!', '\x2', '\x2', 
		'\x5A2', '\x5AC', '\a', '~', '\x2', '\x2', '\x5A3', '\x5A4', '\f', '\x1D', 
		'\x2', '\x2', '\x5A4', '\x5A5', '\a', '\x3', '\x2', '\x2', '\x5A5', '\x5AC', 
		'\x5', '\x122', '\x92', '\x2', '\x5A6', '\x5A7', '\f', '\x13', '\x2', 
		'\x2', '\x5A7', '\x5A9', '\a', 's', '\x2', '\x2', '\x5A8', '\x5AA', '\x5', 
		'\x9C', 'O', '\x2', '\x5A9', '\x5A8', '\x3', '\x2', '\x2', '\x2', '\x5A9', 
		'\x5AA', '\x3', '\x2', '\x2', '\x2', '\x5AA', '\x5AC', '\x3', '\x2', '\x2', 
		'\x2', '\x5AB', '\x55A', '\x3', '\x2', '\x2', '\x2', '\x5AB', '\x55D', 
		'\x3', '\x2', '\x2', '\x2', '\x5AB', '\x560', '\x3', '\x2', '\x2', '\x2', 
		'\x5AB', '\x567', '\x3', '\x2', '\x2', '\x2', '\x5AB', '\x56A', '\x3', 
		'\x2', '\x2', '\x2', '\x5AB', '\x56D', '\x3', '\x2', '\x2', '\x2', '\x5AB', 
		'\x570', '\x3', '\x2', '\x2', '\x2', '\x5AB', '\x574', '\x3', '\x2', '\x2', 
		'\x2', '\x5AB', '\x577', '\x3', '\x2', '\x2', '\x2', '\x5AB', '\x57A', 
		'\x3', '\x2', '\x2', '\x2', '\x5AB', '\x57D', '\x3', '\x2', '\x2', '\x2', 
		'\x5AB', '\x580', '\x3', '\x2', '\x2', '\x2', '\x5AB', '\x584', '\x3', 
		'\x2', '\x2', '\x2', '\x5AB', '\x58D', '\x3', '\x2', '\x2', '\x2', '\x5AB', 
		'\x590', '\x3', '\x2', '\x2', '\x2', '\x5AB', '\x593', '\x3', '\x2', '\x2', 
		'\x2', '\x5AB', '\x596', '\x3', '\x2', '\x2', '\x2', '\x5AB', '\x59C', 
		'\x3', '\x2', '\x2', '\x2', '\x5AB', '\x5A1', '\x3', '\x2', '\x2', '\x2', 
		'\x5AB', '\x5A3', '\x3', '\x2', '\x2', '\x2', '\x5AB', '\x5A6', '\x3', 
		'\x2', '\x2', '\x2', '\x5AC', '\x5AF', '\x3', '\x2', '\x2', '\x2', '\x5AD', 
		'\x5AB', '\x3', '\x2', '\x2', '\x2', '\x5AD', '\x5AE', '\x3', '\x2', '\x2', 
		'\x2', '\x5AE', '\x9D', '\x3', '\x2', '\x2', '\x2', '\x5AF', '\x5AD', 
		'\x3', '\x2', '\x2', '\x2', '\x5B0', '\x5B1', '\t', '\b', '\x2', '\x2', 
		'\x5B1', '\x9F', '\x3', '\x2', '\x2', '\x2', '\x5B2', '\x5B3', '\t', '\t', 
		'\x2', '\x2', '\x5B3', '\xA1', '\x3', '\x2', '\x2', '\x2', '\x5B4', '\x5B6', 
		'\x5', '\x90', 'I', '\x2', '\x5B5', '\x5B4', '\x3', '\x2', '\x2', '\x2', 
		'\x5B6', '\x5B7', '\x3', '\x2', '\x2', '\x2', '\x5B7', '\x5B5', '\x3', 
		'\x2', '\x2', '\x2', '\x5B7', '\x5B8', '\x3', '\x2', '\x2', '\x2', '\x5B8', 
		'\x5B9', '\x3', '\x2', '\x2', '\x2', '\x5B9', '\x5BA', '\x5', '\xA2', 
		'R', '\x2', '\x5BA', '\x5C3', '\x3', '\x2', '\x2', '\x2', '\x5BB', '\x5C3', 
		'\x5', '\xA8', 'U', '\x2', '\x5BC', '\x5C3', '\x5', '\xAC', 'W', '\x2', 
		'\x5BD', '\x5C3', '\x5', '\xAE', 'X', '\x2', '\x5BE', '\x5C3', '\x5', 
		'\xD8', 'm', '\x2', '\x5BF', '\x5C3', '\x5', '\xE4', 's', '\x2', '\x5C0', 
		'\x5C3', '\x5', '\xE6', 't', '\x2', '\x5C1', '\x5C3', '\x5', '\xE8', 'u', 
		'\x2', '\x5C2', '\x5B5', '\x3', '\x2', '\x2', '\x2', '\x5C2', '\x5BB', 
		'\x3', '\x2', '\x2', '\x2', '\x5C2', '\x5BC', '\x3', '\x2', '\x2', '\x2', 
		'\x5C2', '\x5BD', '\x3', '\x2', '\x2', '\x2', '\x5C2', '\x5BE', '\x3', 
		'\x2', '\x2', '\x2', '\x5C2', '\x5BF', '\x3', '\x2', '\x2', '\x2', '\x5C2', 
		'\x5C0', '\x3', '\x2', '\x2', '\x2', '\x5C2', '\x5C1', '\x3', '\x2', '\x2', 
		'\x2', '\x5C3', '\xA3', '\x3', '\x2', '\x2', '\x2', '\x5C4', '\x5C5', 
		'\t', '\n', '\x2', '\x2', '\x5C5', '\xA5', '\x3', '\x2', '\x2', '\x2', 
		'\x5C6', '\x5C9', '\x5', '\x158', '\xAD', '\x2', '\x5C7', '\x5C9', '\x5', 
		'\x16C', '\xB7', '\x2', '\x5C8', '\x5C6', '\x3', '\x2', '\x2', '\x2', 
		'\x5C8', '\x5C7', '\x3', '\x2', '\x2', '\x2', '\x5C9', '\xA7', '\x3', 
		'\x2', '\x2', '\x2', '\x5CA', '\x5CE', '\a', '\x7F', '\x2', '\x2', '\x5CB', 
		'\x5CD', '\x5', '\x8E', 'H', '\x2', '\x5CC', '\x5CB', '\x3', '\x2', '\x2', 
		'\x2', '\x5CD', '\x5D0', '\x3', '\x2', '\x2', '\x2', '\x5CE', '\x5CC', 
		'\x3', '\x2', '\x2', '\x2', '\x5CE', '\x5CF', '\x3', '\x2', '\x2', '\x2', 
		'\x5CF', '\x5D2', '\x3', '\x2', '\x2', '\x2', '\x5D0', '\x5CE', '\x3', 
		'\x2', '\x2', '\x2', '\x5D1', '\x5D3', '\x5', '\xAA', 'V', '\x2', '\x5D2', 
		'\x5D1', '\x3', '\x2', '\x2', '\x2', '\x5D2', '\x5D3', '\x3', '\x2', '\x2', 
		'\x2', '\x5D3', '\x5D4', '\x3', '\x2', '\x2', '\x2', '\x5D4', '\x5D5', 
		'\a', '\x80', '\x2', '\x2', '\x5D5', '\xA9', '\x3', '\x2', '\x2', '\x2', 
		'\x5D6', '\x5D8', '\x5', '\x96', 'L', '\x2', '\x5D7', '\x5D6', '\x3', 
		'\x2', '\x2', '\x2', '\x5D8', '\x5D9', '\x3', '\x2', '\x2', '\x2', '\x5D9', 
		'\x5D7', '\x3', '\x2', '\x2', '\x2', '\x5D9', '\x5DA', '\x3', '\x2', '\x2', 
		'\x2', '\x5DA', '\x5DC', '\x3', '\x2', '\x2', '\x2', '\x5DB', '\x5DD', 
		'\x5', '\x9C', 'O', '\x2', '\x5DC', '\x5DB', '\x3', '\x2', '\x2', '\x2', 
		'\x5DC', '\x5DD', '\x3', '\x2', '\x2', '\x2', '\x5DD', '\x5E0', '\x3', 
		'\x2', '\x2', '\x2', '\x5DE', '\x5E0', '\x5', '\x9C', 'O', '\x2', '\x5DF', 
		'\x5D7', '\x3', '\x2', '\x2', '\x2', '\x5DF', '\x5DE', '\x3', '\x2', '\x2', 
		'\x2', '\x5E0', '\xAB', '\x3', '\x2', '\x2', '\x2', '\x5E1', '\x5E3', 
		'\a', '&', '\x2', '\x2', '\x5E2', '\x5E4', '\a', '\x15', '\x2', '\x2', 
		'\x5E3', '\x5E2', '\x3', '\x2', '\x2', '\x2', '\x5E3', '\x5E4', '\x3', 
		'\x2', '\x2', '\x2', '\x5E4', '\x5E5', '\x3', '\x2', '\x2', '\x2', '\x5E5', 
		'\x5E6', '\x5', '\xA8', 'U', '\x2', '\x5E6', '\xAD', '\x3', '\x2', '\x2', 
		'\x2', '\x5E7', '\x5E8', '\a', '\"', '\x2', '\x2', '\x5E8', '\x5E9', '\x5', 
		'\xA8', 'U', '\x2', '\x5E9', '\xAF', '\x3', '\x2', '\x2', '\x2', '\x5EA', 
		'\x5EF', '\x5', '\x9C', 'O', '\x2', '\x5EB', '\x5EC', '\a', 'v', '\x2', 
		'\x2', '\x5EC', '\x5EE', '\x5', '\x9C', 'O', '\x2', '\x5ED', '\x5EB', 
		'\x3', '\x2', '\x2', '\x2', '\x5EE', '\x5F1', '\x3', '\x2', '\x2', '\x2', 
		'\x5EF', '\x5ED', '\x3', '\x2', '\x2', '\x2', '\x5EF', '\x5F0', '\x3', 
		'\x2', '\x2', '\x2', '\x5F0', '\x5F3', '\x3', '\x2', '\x2', '\x2', '\x5F1', 
		'\x5EF', '\x3', '\x2', '\x2', '\x2', '\x5F2', '\x5F4', '\a', 'v', '\x2', 
		'\x2', '\x5F3', '\x5F2', '\x3', '\x2', '\x2', '\x2', '\x5F3', '\x5F4', 
		'\x3', '\x2', '\x2', '\x2', '\x5F4', '\x5FA', '\x3', '\x2', '\x2', '\x2', 
		'\x5F5', '\x5F6', '\x5', '\x9C', 'O', '\x2', '\x5F6', '\x5F7', '\a', 'w', 
		'\x2', '\x2', '\x5F7', '\x5F8', '\x5', '\x9C', 'O', '\x2', '\x5F8', '\x5FA', 
		'\x3', '\x2', '\x2', '\x2', '\x5F9', '\x5EA', '\x3', '\x2', '\x2', '\x2', 
		'\x5F9', '\x5F5', '\x3', '\x2', '\x2', '\x2', '\x5FA', '\xB1', '\x3', 
		'\x2', '\x2', '\x2', '\x5FB', '\x5FC', '\x5', '\x9C', 'O', '\x2', '\x5FC', 
		'\x5FD', '\a', 'v', '\x2', '\x2', '\x5FD', '\x5FF', '\x3', '\x2', '\x2', 
		'\x2', '\x5FE', '\x5FB', '\x3', '\x2', '\x2', '\x2', '\x5FF', '\x600', 
		'\x3', '\x2', '\x2', '\x2', '\x600', '\x5FE', '\x3', '\x2', '\x2', '\x2', 
		'\x600', '\x601', '\x3', '\x2', '\x2', '\x2', '\x601', '\x603', '\x3', 
		'\x2', '\x2', '\x2', '\x602', '\x604', '\x5', '\x9C', 'O', '\x2', '\x603', 
		'\x602', '\x3', '\x2', '\x2', '\x2', '\x603', '\x604', '\x3', '\x2', '\x2', 
		'\x2', '\x604', '\xB3', '\x3', '\x2', '\x2', '\x2', '\x605', '\x606', 
		'\a', 'M', '\x2', '\x2', '\x606', '\xB5', '\x3', '\x2', '\x2', '\x2', 
		'\x607', '\x60B', '\x5', '\xB8', ']', '\x2', '\x608', '\x60B', '\x5', 
		'\xC0', '\x61', '\x2', '\x609', '\x60B', '\x5', '\xC2', '\x62', '\x2', 
		'\x60A', '\x607', '\x3', '\x2', '\x2', '\x2', '\x60A', '\x608', '\x3', 
		'\x2', '\x2', '\x2', '\x60A', '\x609', '\x3', '\x2', '\x2', '\x2', '\x60B', 
		'\xB7', '\x3', '\x2', '\x2', '\x2', '\x60C', '\x60D', '\x5', '\x158', 
		'\xAD', '\x2', '\x60D', '\x611', '\a', '\x7F', '\x2', '\x2', '\x60E', 
		'\x610', '\x5', '\x8E', 'H', '\x2', '\x60F', '\x60E', '\x3', '\x2', '\x2', 
		'\x2', '\x610', '\x613', '\x3', '\x2', '\x2', '\x2', '\x611', '\x60F', 
		'\x3', '\x2', '\x2', '\x2', '\x611', '\x612', '\x3', '\x2', '\x2', '\x2', 
		'\x612', '\x616', '\x3', '\x2', '\x2', '\x2', '\x613', '\x611', '\x3', 
		'\x2', '\x2', '\x2', '\x614', '\x617', '\x5', '\xBA', '^', '\x2', '\x615', 
		'\x617', '\x5', '\xBE', '`', '\x2', '\x616', '\x614', '\x3', '\x2', '\x2', 
		'\x2', '\x616', '\x615', '\x3', '\x2', '\x2', '\x2', '\x616', '\x617', 
		'\x3', '\x2', '\x2', '\x2', '\x617', '\x618', '\x3', '\x2', '\x2', '\x2', 
		'\x618', '\x619', '\a', '\x80', '\x2', '\x2', '\x619', '\xB9', '\x3', 
		'\x2', '\x2', '\x2', '\x61A', '\x61F', '\x5', '\xBC', '_', '\x2', '\x61B', 
		'\x61C', '\a', 'v', '\x2', '\x2', '\x61C', '\x61E', '\x5', '\xBC', '_', 
		'\x2', '\x61D', '\x61B', '\x3', '\x2', '\x2', '\x2', '\x61E', '\x621', 
		'\x3', '\x2', '\x2', '\x2', '\x61F', '\x61D', '\x3', '\x2', '\x2', '\x2', 
		'\x61F', '\x620', '\x3', '\x2', '\x2', '\x2', '\x620', '\x627', '\x3', 
		'\x2', '\x2', '\x2', '\x621', '\x61F', '\x3', '\x2', '\x2', '\x2', '\x622', 
		'\x623', '\a', 'v', '\x2', '\x2', '\x623', '\x628', '\x5', '\xBE', '`', 
		'\x2', '\x624', '\x626', '\a', 'v', '\x2', '\x2', '\x625', '\x624', '\x3', 
		'\x2', '\x2', '\x2', '\x625', '\x626', '\x3', '\x2', '\x2', '\x2', '\x626', 
		'\x628', '\x3', '\x2', '\x2', '\x2', '\x627', '\x622', '\x3', '\x2', '\x2', 
		'\x2', '\x627', '\x625', '\x3', '\x2', '\x2', '\x2', '\x628', '\xBB', 
		'\x3', '\x2', '\x2', '\x2', '\x629', '\x62B', '\x5', '\x90', 'I', '\x2', 
		'\x62A', '\x629', '\x3', '\x2', '\x2', '\x2', '\x62B', '\x62E', '\x3', 
		'\x2', '\x2', '\x2', '\x62C', '\x62A', '\x3', '\x2', '\x2', '\x2', '\x62C', 
		'\x62D', '\x3', '\x2', '\x2', '\x2', '\x62D', '\x637', '\x3', '\x2', '\x2', 
		'\x2', '\x62E', '\x62C', '\x3', '\x2', '\x2', '\x2', '\x62F', '\x638', 
		'\x5', '\x17C', '\xBF', '\x2', '\x630', '\x633', '\x5', '\x17C', '\xBF', 
		'\x2', '\x631', '\x633', '\x5', '\xB4', '[', '\x2', '\x632', '\x630', 
		'\x3', '\x2', '\x2', '\x2', '\x632', '\x631', '\x3', '\x2', '\x2', '\x2', 
		'\x633', '\x634', '\x3', '\x2', '\x2', '\x2', '\x634', '\x635', '\a', 
		'x', '\x2', '\x2', '\x635', '\x636', '\x5', '\x9C', 'O', '\x2', '\x636', 
		'\x638', '\x3', '\x2', '\x2', '\x2', '\x637', '\x62F', '\x3', '\x2', '\x2', 
		'\x2', '\x637', '\x632', '\x3', '\x2', '\x2', '\x2', '\x638', '\xBD', 
		'\x3', '\x2', '\x2', '\x2', '\x639', '\x63A', '\a', 's', '\x2', '\x2', 
		'\x63A', '\x63B', '\x5', '\x9C', 'O', '\x2', '\x63B', '\xBF', '\x3', '\x2', 
		'\x2', '\x2', '\x63C', '\x63D', '\x5', '\x158', '\xAD', '\x2', '\x63D', 
		'\x641', '\a', '\x83', '\x2', '\x2', '\x63E', '\x640', '\x5', '\x8E', 
		'H', '\x2', '\x63F', '\x63E', '\x3', '\x2', '\x2', '\x2', '\x640', '\x643', 
		'\x3', '\x2', '\x2', '\x2', '\x641', '\x63F', '\x3', '\x2', '\x2', '\x2', 
		'\x641', '\x642', '\x3', '\x2', '\x2', '\x2', '\x642', '\x64F', '\x3', 
		'\x2', '\x2', '\x2', '\x643', '\x641', '\x3', '\x2', '\x2', '\x2', '\x644', 
		'\x649', '\x5', '\x9C', 'O', '\x2', '\x645', '\x646', '\a', 'v', '\x2', 
		'\x2', '\x646', '\x648', '\x5', '\x9C', 'O', '\x2', '\x647', '\x645', 
		'\x3', '\x2', '\x2', '\x2', '\x648', '\x64B', '\x3', '\x2', '\x2', '\x2', 
		'\x649', '\x647', '\x3', '\x2', '\x2', '\x2', '\x649', '\x64A', '\x3', 
		'\x2', '\x2', '\x2', '\x64A', '\x64D', '\x3', '\x2', '\x2', '\x2', '\x64B', 
		'\x649', '\x3', '\x2', '\x2', '\x2', '\x64C', '\x64E', '\a', 'v', '\x2', 
		'\x2', '\x64D', '\x64C', '\x3', '\x2', '\x2', '\x2', '\x64D', '\x64E', 
		'\x3', '\x2', '\x2', '\x2', '\x64E', '\x650', '\x3', '\x2', '\x2', '\x2', 
		'\x64F', '\x644', '\x3', '\x2', '\x2', '\x2', '\x64F', '\x650', '\x3', 
		'\x2', '\x2', '\x2', '\x650', '\x651', '\x3', '\x2', '\x2', '\x2', '\x651', 
		'\x652', '\a', '\x84', '\x2', '\x2', '\x652', '\xC1', '\x3', '\x2', '\x2', 
		'\x2', '\x653', '\x654', '\x5', '\x158', '\xAD', '\x2', '\x654', '\xC3', 
		'\x3', '\x2', '\x2', '\x2', '\x655', '\x659', '\x5', '\xC6', '\x64', '\x2', 
		'\x656', '\x659', '\x5', '\xCC', 'g', '\x2', '\x657', '\x659', '\x5', 
		'\xCE', 'h', '\x2', '\x658', '\x655', '\x3', '\x2', '\x2', '\x2', '\x658', 
		'\x656', '\x3', '\x2', '\x2', '\x2', '\x658', '\x657', '\x3', '\x2', '\x2', 
		'\x2', '\x659', '\xC5', '\x3', '\x2', '\x2', '\x2', '\x65A', '\x65B', 
		'\x5', '\x158', '\xAD', '\x2', '\x65B', '\x65D', '\a', '\x7F', '\x2', 
		'\x2', '\x65C', '\x65E', '\x5', '\xC8', '\x65', '\x2', '\x65D', '\x65C', 
		'\x3', '\x2', '\x2', '\x2', '\x65D', '\x65E', '\x3', '\x2', '\x2', '\x2', 
		'\x65E', '\x65F', '\x3', '\x2', '\x2', '\x2', '\x65F', '\x660', '\a', 
		'\x80', '\x2', '\x2', '\x660', '\xC7', '\x3', '\x2', '\x2', '\x2', '\x661', 
		'\x666', '\x5', '\xCA', '\x66', '\x2', '\x662', '\x663', '\a', 'v', '\x2', 
		'\x2', '\x663', '\x665', '\x5', '\xCA', '\x66', '\x2', '\x664', '\x662', 
		'\x3', '\x2', '\x2', '\x2', '\x665', '\x668', '\x3', '\x2', '\x2', '\x2', 
		'\x666', '\x664', '\x3', '\x2', '\x2', '\x2', '\x666', '\x667', '\x3', 
		'\x2', '\x2', '\x2', '\x667', '\x66A', '\x3', '\x2', '\x2', '\x2', '\x668', 
		'\x666', '\x3', '\x2', '\x2', '\x2', '\x669', '\x66B', '\a', 'v', '\x2', 
		'\x2', '\x66A', '\x669', '\x3', '\x2', '\x2', '\x2', '\x66A', '\x66B', 
		'\x3', '\x2', '\x2', '\x2', '\x66B', '\xC9', '\x3', '\x2', '\x2', '\x2', 
		'\x66C', '\x675', '\x5', '\x17C', '\xBF', '\x2', '\x66D', '\x670', '\x5', 
		'\x17C', '\xBF', '\x2', '\x66E', '\x670', '\x5', '\xB4', '[', '\x2', '\x66F', 
		'\x66D', '\x3', '\x2', '\x2', '\x2', '\x66F', '\x66E', '\x3', '\x2', '\x2', 
		'\x2', '\x670', '\x671', '\x3', '\x2', '\x2', '\x2', '\x671', '\x672', 
		'\a', 'x', '\x2', '\x2', '\x672', '\x673', '\x5', '\x9C', 'O', '\x2', 
		'\x673', '\x675', '\x3', '\x2', '\x2', '\x2', '\x674', '\x66C', '\x3', 
		'\x2', '\x2', '\x2', '\x674', '\x66F', '\x3', '\x2', '\x2', '\x2', '\x675', 
		'\xCB', '\x3', '\x2', '\x2', '\x2', '\x676', '\x677', '\x5', '\x158', 
		'\xAD', '\x2', '\x677', '\x683', '\a', '\x83', '\x2', '\x2', '\x678', 
		'\x67D', '\x5', '\x9C', 'O', '\x2', '\x679', '\x67A', '\a', 'v', '\x2', 
		'\x2', '\x67A', '\x67C', '\x5', '\x9C', 'O', '\x2', '\x67B', '\x679', 
		'\x3', '\x2', '\x2', '\x2', '\x67C', '\x67F', '\x3', '\x2', '\x2', '\x2', 
		'\x67D', '\x67B', '\x3', '\x2', '\x2', '\x2', '\x67D', '\x67E', '\x3', 
		'\x2', '\x2', '\x2', '\x67E', '\x681', '\x3', '\x2', '\x2', '\x2', '\x67F', 
		'\x67D', '\x3', '\x2', '\x2', '\x2', '\x680', '\x682', '\a', 'v', '\x2', 
		'\x2', '\x681', '\x680', '\x3', '\x2', '\x2', '\x2', '\x681', '\x682', 
		'\x3', '\x2', '\x2', '\x2', '\x682', '\x684', '\x3', '\x2', '\x2', '\x2', 
		'\x683', '\x678', '\x3', '\x2', '\x2', '\x2', '\x683', '\x684', '\x3', 
		'\x2', '\x2', '\x2', '\x684', '\x685', '\x3', '\x2', '\x2', '\x2', '\x685', 
		'\x686', '\a', '\x84', '\x2', '\x2', '\x686', '\xCD', '\x3', '\x2', '\x2', 
		'\x2', '\x687', '\x688', '\x5', '\x158', '\xAD', '\x2', '\x688', '\xCF', 
		'\x3', '\x2', '\x2', '\x2', '\x689', '\x68E', '\x5', '\x9C', 'O', '\x2', 
		'\x68A', '\x68B', '\a', 'v', '\x2', '\x2', '\x68B', '\x68D', '\x5', '\x9C', 
		'O', '\x2', '\x68C', '\x68A', '\x3', '\x2', '\x2', '\x2', '\x68D', '\x690', 
		'\x3', '\x2', '\x2', '\x2', '\x68E', '\x68C', '\x3', '\x2', '\x2', '\x2', 
		'\x68E', '\x68F', '\x3', '\x2', '\x2', '\x2', '\x68F', '\x692', '\x3', 
		'\x2', '\x2', '\x2', '\x690', '\x68E', '\x3', '\x2', '\x2', '\x2', '\x691', 
		'\x693', '\a', 'v', '\x2', '\x2', '\x692', '\x691', '\x3', '\x2', '\x2', 
		'\x2', '\x692', '\x693', '\x3', '\x2', '\x2', '\x2', '\x693', '\xD1', 
		'\x3', '\x2', '\x2', '\x2', '\x694', '\x696', '\a', '\x15', '\x2', '\x2', 
		'\x695', '\x694', '\x3', '\x2', '\x2', '\x2', '\x695', '\x696', '\x3', 
		'\x2', '\x2', '\x2', '\x696', '\x69D', '\x3', '\x2', '\x2', '\x2', '\x697', 
		'\x69E', '\a', '^', '\x2', '\x2', '\x698', '\x69A', '\a', '\\', '\x2', 
		'\x2', '\x699', '\x69B', '\x5', '\xD4', 'k', '\x2', '\x69A', '\x699', 
		'\x3', '\x2', '\x2', '\x2', '\x69A', '\x69B', '\x3', '\x2', '\x2', '\x2', 
		'\x69B', '\x69C', '\x3', '\x2', '\x2', '\x2', '\x69C', '\x69E', '\a', 
		'\\', '\x2', '\x2', '\x69D', '\x697', '\x3', '\x2', '\x2', '\x2', '\x69D', 
		'\x698', '\x3', '\x2', '\x2', '\x2', '\x69E', '\x6A4', '\x3', '\x2', '\x2', 
		'\x2', '\x69F', '\x6A5', '\x5', '\x9C', 'O', '\x2', '\x6A0', '\x6A1', 
		'\a', 'z', '\x2', '\x2', '\x6A1', '\x6A2', '\x5', '\x122', '\x92', '\x2', 
		'\x6A2', '\x6A3', '\x5', '\xA8', 'U', '\x2', '\x6A3', '\x6A5', '\x3', 
		'\x2', '\x2', '\x2', '\x6A4', '\x69F', '\x3', '\x2', '\x2', '\x2', '\x6A4', 
		'\x6A0', '\x3', '\x2', '\x2', '\x2', '\x6A5', '\xD3', '\x3', '\x2', '\x2', 
		'\x2', '\x6A6', '\x6AB', '\x5', '\xD6', 'l', '\x2', '\x6A7', '\x6A8', 
		'\a', 'v', '\x2', '\x2', '\x6A8', '\x6AA', '\x5', '\xD6', 'l', '\x2', 
		'\x6A9', '\x6A7', '\x3', '\x2', '\x2', '\x2', '\x6AA', '\x6AD', '\x3', 
		'\x2', '\x2', '\x2', '\x6AB', '\x6A9', '\x3', '\x2', '\x2', '\x2', '\x6AB', 
		'\x6AC', '\x3', '\x2', '\x2', '\x2', '\x6AC', '\x6AF', '\x3', '\x2', '\x2', 
		'\x2', '\x6AD', '\x6AB', '\x3', '\x2', '\x2', '\x2', '\x6AE', '\x6B0', 
		'\a', 'v', '\x2', '\x2', '\x6AF', '\x6AE', '\x3', '\x2', '\x2', '\x2', 
		'\x6AF', '\x6B0', '\x3', '\x2', '\x2', '\x2', '\x6B0', '\xD5', '\x3', 
		'\x2', '\x2', '\x2', '\x6B1', '\x6B3', '\x5', '\x90', 'I', '\x2', '\x6B2', 
		'\x6B1', '\x3', '\x2', '\x2', '\x2', '\x6B3', '\x6B6', '\x3', '\x2', '\x2', 
		'\x2', '\x6B4', '\x6B2', '\x3', '\x2', '\x2', '\x2', '\x6B4', '\x6B5', 
		'\x3', '\x2', '\x2', '\x2', '\x6B5', '\x6B7', '\x3', '\x2', '\x2', '\x2', 
		'\x6B6', '\x6B4', '\x3', '\x2', '\x2', '\x2', '\x6B7', '\x6BA', '\x5', 
		'\xF2', 'z', '\x2', '\x6B8', '\x6B9', '\a', 'x', '\x2', '\x2', '\x6B9', 
		'\x6BB', '\x5', '\x120', '\x91', '\x2', '\x6BA', '\x6B8', '\x3', '\x2', 
		'\x2', '\x2', '\x6BA', '\x6BB', '\x3', '\x2', '\x2', '\x2', '\x6BB', '\xD7', 
		'\x3', '\x2', '\x2', '\x2', '\x6BC', '\x6BE', '\x5', '\xE2', 'r', '\x2', 
		'\x6BD', '\x6BC', '\x3', '\x2', '\x2', '\x2', '\x6BD', '\x6BE', '\x3', 
		'\x2', '\x2', '\x2', '\x6BE', '\x6C3', '\x3', '\x2', '\x2', '\x2', '\x6BF', 
		'\x6C4', '\x5', '\xDA', 'n', '\x2', '\x6C0', '\x6C4', '\x5', '\xDC', 'o', 
		'\x2', '\x6C1', '\x6C4', '\x5', '\xDE', 'p', '\x2', '\x6C2', '\x6C4', 
		'\x5', '\xE0', 'q', '\x2', '\x6C3', '\x6BF', '\x3', '\x2', '\x2', '\x2', 
		'\x6C3', '\x6C0', '\x3', '\x2', '\x2', '\x2', '\x6C3', '\x6C1', '\x3', 
		'\x2', '\x2', '\x2', '\x6C3', '\x6C2', '\x3', '\x2', '\x2', '\x2', '\x6C4', 
		'\xD9', '\x3', '\x2', '\x2', '\x2', '\x6C5', '\x6C6', '\a', '\x12', '\x2', 
		'\x2', '\x6C6', '\x6C7', '\x5', '\xA8', 'U', '\x2', '\x6C7', '\xDB', '\x3', 
		'\x2', '\x2', '\x2', '\x6C8', '\x6C9', '\a', '%', '\x2', '\x2', '\x6C9', 
		'\x6CA', '\x5', '\x9C', 'O', '\x2', '\x6CA', '\x6CB', '\x5', '\xA8', 'U', 
		'\x2', '\x6CB', '\xDD', '\x3', '\x2', '\x2', '\x2', '\x6CC', '\x6CD', 
		'\a', '%', '\x2', '\x2', '\x6CD', '\x6CE', '\a', '\x11', '\x2', '\x2', 
		'\x6CE', '\x6CF', '\x5', '\xF2', 'z', '\x2', '\x6CF', '\x6D0', '\a', 'i', 
		'\x2', '\x2', '\x6D0', '\x6D1', '\x5', '\x9C', 'O', '\x2', '\x6D1', '\x6D2', 
		'\x5', '\xA8', 'U', '\x2', '\x6D2', '\xDF', '\x3', '\x2', '\x2', '\x2', 
		'\x6D3', '\x6D4', '\a', '\r', '\x2', '\x2', '\x6D4', '\x6D5', '\x5', '\xF2', 
		'z', '\x2', '\x6D5', '\x6D6', '\a', '\x10', '\x2', '\x2', '\x6D6', '\x6D7', 
		'\x5', '\x9C', 'O', '\x2', '\x6D7', '\x6D8', '\x5', '\xA8', 'U', '\x2', 
		'\x6D8', '\xE1', '\x3', '\x2', '\x2', '\x2', '\x6D9', '\x6DA', '\a', 'S', 
		'\x2', '\x2', '\x6DA', '\x6DB', '\a', 'x', '\x2', '\x2', '\x6DB', '\xE3', 
		'\x3', '\x2', '\x2', '\x2', '\x6DC', '\x6DD', '\a', '\xE', '\x2', '\x2', 
		'\x6DD', '\x6DE', '\x5', '\x9C', 'O', '\x2', '\x6DE', '\x6E5', '\x5', 
		'\xA8', 'U', '\x2', '\x6DF', '\x6E3', '\a', '\b', '\x2', '\x2', '\x6E0', 
		'\x6E4', '\x5', '\xA8', 'U', '\x2', '\x6E1', '\x6E4', '\x5', '\xE4', 's', 
		'\x2', '\x6E2', '\x6E4', '\x5', '\xE6', 't', '\x2', '\x6E3', '\x6E0', 
		'\x3', '\x2', '\x2', '\x2', '\x6E3', '\x6E1', '\x3', '\x2', '\x2', '\x2', 
		'\x6E3', '\x6E2', '\x3', '\x2', '\x2', '\x2', '\x6E4', '\x6E6', '\x3', 
		'\x2', '\x2', '\x2', '\x6E5', '\x6DF', '\x3', '\x2', '\x2', '\x2', '\x6E5', 
		'\x6E6', '\x3', '\x2', '\x2', '\x2', '\x6E6', '\xE5', '\x3', '\x2', '\x2', 
		'\x2', '\x6E7', '\x6E8', '\a', '\xE', '\x2', '\x2', '\x6E8', '\x6E9', 
		'\a', '\x11', '\x2', '\x2', '\x6E9', '\x6EA', '\x5', '\xF2', 'z', '\x2', 
		'\x6EA', '\x6EB', '\a', 'i', '\x2', '\x2', '\x6EB', '\x6EC', '\x5', '\x9C', 
		'O', '\x2', '\x6EC', '\x6F3', '\x5', '\xA8', 'U', '\x2', '\x6ED', '\x6F1', 
		'\a', '\b', '\x2', '\x2', '\x6EE', '\x6F2', '\x5', '\xA8', 'U', '\x2', 
		'\x6EF', '\x6F2', '\x5', '\xE4', 's', '\x2', '\x6F0', '\x6F2', '\x5', 
		'\xE6', 't', '\x2', '\x6F1', '\x6EE', '\x3', '\x2', '\x2', '\x2', '\x6F1', 
		'\x6EF', '\x3', '\x2', '\x2', '\x2', '\x6F1', '\x6F0', '\x3', '\x2', '\x2', 
		'\x2', '\x6F2', '\x6F4', '\x3', '\x2', '\x2', '\x2', '\x6F3', '\x6ED', 
		'\x3', '\x2', '\x2', '\x2', '\x6F3', '\x6F4', '\x3', '\x2', '\x2', '\x2', 
		'\x6F4', '\xE7', '\x3', '\x2', '\x2', '\x2', '\x6F5', '\x6F6', '\a', '\x13', 
		'\x2', '\x2', '\x6F6', '\x6F7', '\x5', '\x9C', 'O', '\x2', '\x6F7', '\x6FB', 
		'\a', '\x7F', '\x2', '\x2', '\x6F8', '\x6FA', '\x5', '\x8E', 'H', '\x2', 
		'\x6F9', '\x6F8', '\x3', '\x2', '\x2', '\x2', '\x6FA', '\x6FD', '\x3', 
		'\x2', '\x2', '\x2', '\x6FB', '\x6F9', '\x3', '\x2', '\x2', '\x2', '\x6FB', 
		'\x6FC', '\x3', '\x2', '\x2', '\x2', '\x6FC', '\x6FF', '\x3', '\x2', '\x2', 
		'\x2', '\x6FD', '\x6FB', '\x3', '\x2', '\x2', '\x2', '\x6FE', '\x700', 
		'\x5', '\xEA', 'v', '\x2', '\x6FF', '\x6FE', '\x3', '\x2', '\x2', '\x2', 
		'\x6FF', '\x700', '\x3', '\x2', '\x2', '\x2', '\x700', '\x701', '\x3', 
		'\x2', '\x2', '\x2', '\x701', '\x702', '\a', '\x80', '\x2', '\x2', '\x702', 
		'\xE9', '\x3', '\x2', '\x2', '\x2', '\x703', '\x704', '\x5', '\xEE', 'x', 
		'\x2', '\x704', '\x705', '\a', '{', '\x2', '\x2', '\x705', '\x706', '\x5', 
		'\xEC', 'w', '\x2', '\x706', '\x708', '\x3', '\x2', '\x2', '\x2', '\x707', 
		'\x703', '\x3', '\x2', '\x2', '\x2', '\x708', '\x70B', '\x3', '\x2', '\x2', 
		'\x2', '\x709', '\x707', '\x3', '\x2', '\x2', '\x2', '\x709', '\x70A', 
		'\x3', '\x2', '\x2', '\x2', '\x70A', '\x70C', '\x3', '\x2', '\x2', '\x2', 
		'\x70B', '\x709', '\x3', '\x2', '\x2', '\x2', '\x70C', '\x70D', '\x5', 
		'\xEE', 'x', '\x2', '\x70D', '\x70E', '\a', '{', '\x2', '\x2', '\x70E', 
		'\x710', '\x5', '\x9C', 'O', '\x2', '\x70F', '\x711', '\a', 'v', '\x2', 
		'\x2', '\x710', '\x70F', '\x3', '\x2', '\x2', '\x2', '\x710', '\x711', 
		'\x3', '\x2', '\x2', '\x2', '\x711', '\xEB', '\x3', '\x2', '\x2', '\x2', 
		'\x712', '\x713', '\x5', '\x9C', 'O', '\x2', '\x713', '\x714', '\a', 'v', 
		'\x2', '\x2', '\x714', '\x71A', '\x3', '\x2', '\x2', '\x2', '\x715', '\x717', 
		'\x5', '\xA2', 'R', '\x2', '\x716', '\x718', '\a', 'v', '\x2', '\x2', 
		'\x717', '\x716', '\x3', '\x2', '\x2', '\x2', '\x717', '\x718', '\x3', 
		'\x2', '\x2', '\x2', '\x718', '\x71A', '\x3', '\x2', '\x2', '\x2', '\x719', 
		'\x712', '\x3', '\x2', '\x2', '\x2', '\x719', '\x715', '\x3', '\x2', '\x2', 
		'\x2', '\x71A', '\xED', '\x3', '\x2', '\x2', '\x2', '\x71B', '\x71D', 
		'\x5', '\x90', 'I', '\x2', '\x71C', '\x71B', '\x3', '\x2', '\x2', '\x2', 
		'\x71D', '\x720', '\x3', '\x2', '\x2', '\x2', '\x71E', '\x71C', '\x3', 
		'\x2', '\x2', '\x2', '\x71E', '\x71F', '\x3', '\x2', '\x2', '\x2', '\x71F', 
		'\x721', '\x3', '\x2', '\x2', '\x2', '\x720', '\x71E', '\x3', '\x2', '\x2', 
		'\x2', '\x721', '\x723', '\x5', '\xF2', 'z', '\x2', '\x722', '\x724', 
		'\x5', '\xF0', 'y', '\x2', '\x723', '\x722', '\x3', '\x2', '\x2', '\x2', 
		'\x723', '\x724', '\x3', '\x2', '\x2', '\x2', '\x724', '\xEF', '\x3', 
		'\x2', '\x2', '\x2', '\x725', '\x726', '\a', '\xE', '\x2', '\x2', '\x726', 
		'\x727', '\x5', '\x9C', 'O', '\x2', '\x727', '\xF1', '\x3', '\x2', '\x2', 
		'\x2', '\x728', '\x72A', '\a', '\\', '\x2', '\x2', '\x729', '\x728', '\x3', 
		'\x2', '\x2', '\x2', '\x729', '\x72A', '\x3', '\x2', '\x2', '\x2', '\x72A', 
		'\x72B', '\x3', '\x2', '\x2', '\x2', '\x72B', '\x730', '\x5', '\xF4', 
		'{', '\x2', '\x72C', '\x72D', '\a', '\\', '\x2', '\x2', '\x72D', '\x72F', 
		'\x5', '\xF4', '{', '\x2', '\x72E', '\x72C', '\x3', '\x2', '\x2', '\x2', 
		'\x72F', '\x732', '\x3', '\x2', '\x2', '\x2', '\x730', '\x72E', '\x3', 
		'\x2', '\x2', '\x2', '\x730', '\x731', '\x3', '\x2', '\x2', '\x2', '\x731', 
		'\xF3', '\x3', '\x2', '\x2', '\x2', '\x732', '\x730', '\x3', '\x2', '\x2', 
		'\x2', '\x733', '\x736', '\x5', '\xF6', '|', '\x2', '\x734', '\x736', 
		'\x5', '\x100', '\x81', '\x2', '\x735', '\x733', '\x3', '\x2', '\x2', 
		'\x2', '\x735', '\x734', '\x3', '\x2', '\x2', '\x2', '\x736', '\xF5', 
		'\x3', '\x2', '\x2', '\x2', '\x737', '\x744', '\x5', '\xF8', '}', '\x2', 
		'\x738', '\x744', '\x5', '\xFA', '~', '\x2', '\x739', '\x744', '\x5', 
		'\xFC', '\x7F', '\x2', '\x73A', '\x744', '\x5', '\xFE', '\x80', '\x2', 
		'\x73B', '\x744', '\x5', '\x104', '\x83', '\x2', '\x73C', '\x744', '\x5', 
		'\x106', '\x84', '\x2', '\x73D', '\x744', '\x5', '\x110', '\x89', '\x2', 
		'\x73E', '\x744', '\x5', '\x114', '\x8B', '\x2', '\x73F', '\x744', '\x5', 
		'\x118', '\x8D', '\x2', '\x740', '\x744', '\x5', '\x11A', '\x8E', '\x2', 
		'\x741', '\x744', '\x5', '\x11E', '\x90', '\x2', '\x742', '\x744', '\x5', 
		'\x4', '\x3', '\x2', '\x743', '\x737', '\x3', '\x2', '\x2', '\x2', '\x743', 
		'\x738', '\x3', '\x2', '\x2', '\x2', '\x743', '\x739', '\x3', '\x2', '\x2', 
		'\x2', '\x743', '\x73A', '\x3', '\x2', '\x2', '\x2', '\x743', '\x73B', 
		'\x3', '\x2', '\x2', '\x2', '\x743', '\x73C', '\x3', '\x2', '\x2', '\x2', 
		'\x743', '\x73D', '\x3', '\x2', '\x2', '\x2', '\x743', '\x73E', '\x3', 
		'\x2', '\x2', '\x2', '\x743', '\x73F', '\x3', '\x2', '\x2', '\x2', '\x743', 
		'\x740', '\x3', '\x2', '\x2', '\x2', '\x743', '\x741', '\x3', '\x2', '\x2', 
		'\x2', '\x743', '\x742', '\x3', '\x2', '\x2', '\x2', '\x744', '\xF7', 
		'\x3', '\x2', '\x2', '\x2', '\x745', '\x756', '\a', ' ', '\x2', '\x2', 
		'\x746', '\x756', '\a', '\v', '\x2', '\x2', '\x747', '\x756', '\a', 'G', 
		'\x2', '\x2', '\x748', '\x756', '\a', 'J', '\x2', '\x2', '\x749', '\x756', 
		'\a', 'H', '\x2', '\x2', '\x74A', '\x756', '\a', 'I', '\x2', '\x2', '\x74B', 
		'\x756', '\a', 'K', '\x2', '\x2', '\x74C', '\x756', '\a', 'L', '\x2', 
		'\x2', '\x74D', '\x74F', '\a', 'U', '\x2', '\x2', '\x74E', '\x74D', '\x3', 
		'\x2', '\x2', '\x2', '\x74E', '\x74F', '\x3', '\x2', '\x2', '\x2', '\x74F', 
		'\x750', '\x3', '\x2', '\x2', '\x2', '\x750', '\x756', '\a', 'M', '\x2', 
		'\x2', '\x751', '\x753', '\a', 'U', '\x2', '\x2', '\x752', '\x751', '\x3', 
		'\x2', '\x2', '\x2', '\x752', '\x753', '\x3', '\x2', '\x2', '\x2', '\x753', 
		'\x754', '\x3', '\x2', '\x2', '\x2', '\x754', '\x756', '\a', 'R', '\x2', 
		'\x2', '\x755', '\x745', '\x3', '\x2', '\x2', '\x2', '\x755', '\x746', 
		'\x3', '\x2', '\x2', '\x2', '\x755', '\x747', '\x3', '\x2', '\x2', '\x2', 
		'\x755', '\x748', '\x3', '\x2', '\x2', '\x2', '\x755', '\x749', '\x3', 
		'\x2', '\x2', '\x2', '\x755', '\x74A', '\x3', '\x2', '\x2', '\x2', '\x755', 
		'\x74B', '\x3', '\x2', '\x2', '\x2', '\x755', '\x74C', '\x3', '\x2', '\x2', 
		'\x2', '\x755', '\x74E', '\x3', '\x2', '\x2', '\x2', '\x755', '\x752', 
		'\x3', '\x2', '\x2', '\x2', '\x756', '\xF9', '\x3', '\x2', '\x2', '\x2', 
		'\x757', '\x759', '\a', '\x18', '\x2', '\x2', '\x758', '\x757', '\x3', 
		'\x2', '\x2', '\x2', '\x758', '\x759', '\x3', '\x2', '\x2', '\x2', '\x759', 
		'\x75B', '\x3', '\x2', '\x2', '\x2', '\x75A', '\x75C', '\a', '\x16', '\x2', 
		'\x2', '\x75B', '\x75A', '\x3', '\x2', '\x2', '\x2', '\x75B', '\x75C', 
		'\x3', '\x2', '\x2', '\x2', '\x75C', '\x75D', '\x3', '\x2', '\x2', '\x2', 
		'\x75D', '\x760', '\x5', '\x17C', '\xBF', '\x2', '\x75E', '\x75F', '\a', 
		'p', '\x2', '\x2', '\x75F', '\x761', '\x5', '\xF2', 'z', '\x2', '\x760', 
		'\x75E', '\x3', '\x2', '\x2', '\x2', '\x760', '\x761', '\x3', '\x2', '\x2', 
		'\x2', '\x761', '\xFB', '\x3', '\x2', '\x2', '\x2', '\x762', '\x763', 
		'\a', 'q', '\x2', '\x2', '\x763', '\xFD', '\x3', '\x2', '\x2', '\x2', 
		'\x764', '\x765', '\a', 's', '\x2', '\x2', '\x765', '\xFF', '\x3', '\x2', 
		'\x2', '\x2', '\x766', '\x767', '\x5', '\x102', '\x82', '\x2', '\x767', 
		'\x768', '\a', 'u', '\x2', '\x2', '\x768', '\x769', '\x5', '\x102', '\x82', 
		'\x2', '\x769', '\x772', '\x3', '\x2', '\x2', '\x2', '\x76A', '\x76B', 
		'\x5', '\x102', '\x82', '\x2', '\x76B', '\x76C', '\a', 's', '\x2', '\x2', 
		'\x76C', '\x772', '\x3', '\x2', '\x2', '\x2', '\x76D', '\x76E', '\x5', 
		'\x102', '\x82', '\x2', '\x76E', '\x76F', '\a', 't', '\x2', '\x2', '\x76F', 
		'\x770', '\x5', '\x102', '\x82', '\x2', '\x770', '\x772', '\x3', '\x2', 
		'\x2', '\x2', '\x771', '\x766', '\x3', '\x2', '\x2', '\x2', '\x771', '\x76A', 
		'\x3', '\x2', '\x2', '\x2', '\x771', '\x76D', '\x3', '\x2', '\x2', '\x2', 
		'\x772', '\x101', '\x3', '\x2', '\x2', '\x2', '\x773', '\x77F', '\a', 
		'G', '\x2', '\x2', '\x774', '\x77F', '\a', 'J', '\x2', '\x2', '\x775', 
		'\x777', '\a', 'U', '\x2', '\x2', '\x776', '\x775', '\x3', '\x2', '\x2', 
		'\x2', '\x776', '\x777', '\x3', '\x2', '\x2', '\x2', '\x777', '\x778', 
		'\x3', '\x2', '\x2', '\x2', '\x778', '\x77F', '\a', 'M', '\x2', '\x2', 
		'\x779', '\x77B', '\a', 'U', '\x2', '\x2', '\x77A', '\x779', '\x3', '\x2', 
		'\x2', '\x2', '\x77A', '\x77B', '\x3', '\x2', '\x2', '\x2', '\x77B', '\x77C', 
		'\x3', '\x2', '\x2', '\x2', '\x77C', '\x77F', '\a', 'R', '\x2', '\x2', 
		'\x77D', '\x77F', '\x5', '\x11E', '\x90', '\x2', '\x77E', '\x773', '\x3', 
		'\x2', '\x2', '\x2', '\x77E', '\x774', '\x3', '\x2', '\x2', '\x2', '\x77E', 
		'\x776', '\x3', '\x2', '\x2', '\x2', '\x77E', '\x77A', '\x3', '\x2', '\x2', 
		'\x2', '\x77E', '\x77D', '\x3', '\x2', '\x2', '\x2', '\x77F', '\x103', 
		'\x3', '\x2', '\x2', '\x2', '\x780', '\x782', '\t', '\x4', '\x2', '\x2', 
		'\x781', '\x783', '\a', '\x16', '\x2', '\x2', '\x782', '\x781', '\x3', 
		'\x2', '\x2', '\x2', '\x782', '\x783', '\x3', '\x2', '\x2', '\x2', '\x783', 
		'\x784', '\x3', '\x2', '\x2', '\x2', '\x784', '\x785', '\x5', '\xF6', 
		'|', '\x2', '\x785', '\x105', '\x3', '\x2', '\x2', '\x2', '\x786', '\x787', 
		'\x5', '\x158', '\xAD', '\x2', '\x787', '\x789', '\a', '\x7F', '\x2', 
		'\x2', '\x788', '\x78A', '\x5', '\x108', '\x85', '\x2', '\x789', '\x788', 
		'\x3', '\x2', '\x2', '\x2', '\x789', '\x78A', '\x3', '\x2', '\x2', '\x2', 
		'\x78A', '\x78B', '\x3', '\x2', '\x2', '\x2', '\x78B', '\x78C', '\a', 
		'\x80', '\x2', '\x2', '\x78C', '\x107', '\x3', '\x2', '\x2', '\x2', '\x78D', 
		'\x792', '\x5', '\x10A', '\x86', '\x2', '\x78E', '\x790', '\a', 'v', '\x2', 
		'\x2', '\x78F', '\x791', '\x5', '\x10E', '\x88', '\x2', '\x790', '\x78F', 
		'\x3', '\x2', '\x2', '\x2', '\x790', '\x791', '\x3', '\x2', '\x2', '\x2', 
		'\x791', '\x793', '\x3', '\x2', '\x2', '\x2', '\x792', '\x78E', '\x3', 
		'\x2', '\x2', '\x2', '\x792', '\x793', '\x3', '\x2', '\x2', '\x2', '\x793', 
		'\x796', '\x3', '\x2', '\x2', '\x2', '\x794', '\x796', '\x5', '\x10E', 
		'\x88', '\x2', '\x795', '\x78D', '\x3', '\x2', '\x2', '\x2', '\x795', 
		'\x794', '\x3', '\x2', '\x2', '\x2', '\x796', '\x109', '\x3', '\x2', '\x2', 
		'\x2', '\x797', '\x79C', '\x5', '\x10C', '\x87', '\x2', '\x798', '\x799', 
		'\a', 'v', '\x2', '\x2', '\x799', '\x79B', '\x5', '\x10C', '\x87', '\x2', 
		'\x79A', '\x798', '\x3', '\x2', '\x2', '\x2', '\x79B', '\x79E', '\x3', 
		'\x2', '\x2', '\x2', '\x79C', '\x79A', '\x3', '\x2', '\x2', '\x2', '\x79C', 
		'\x79D', '\x3', '\x2', '\x2', '\x2', '\x79D', '\x10B', '\x3', '\x2', '\x2', 
		'\x2', '\x79E', '\x79C', '\x3', '\x2', '\x2', '\x2', '\x79F', '\x7A1', 
		'\x5', '\x90', 'I', '\x2', '\x7A0', '\x79F', '\x3', '\x2', '\x2', '\x2', 
		'\x7A1', '\x7A4', '\x3', '\x2', '\x2', '\x2', '\x7A2', '\x7A0', '\x3', 
		'\x2', '\x2', '\x2', '\x7A2', '\x7A3', '\x3', '\x2', '\x2', '\x2', '\x7A3', 
		'\x7B4', '\x3', '\x2', '\x2', '\x2', '\x7A4', '\x7A2', '\x3', '\x2', '\x2', 
		'\x2', '\x7A5', '\x7A6', '\x5', '\xB4', '[', '\x2', '\x7A6', '\x7A7', 
		'\a', 'x', '\x2', '\x2', '\x7A7', '\x7A8', '\x5', '\xF2', 'z', '\x2', 
		'\x7A8', '\x7B5', '\x3', '\x2', '\x2', '\x2', '\x7A9', '\x7AA', '\x5', 
		'\x17C', '\xBF', '\x2', '\x7AA', '\x7AB', '\a', 'x', '\x2', '\x2', '\x7AB', 
		'\x7AC', '\x5', '\xF2', 'z', '\x2', '\x7AC', '\x7B5', '\x3', '\x2', '\x2', 
		'\x2', '\x7AD', '\x7AF', '\a', '\x18', '\x2', '\x2', '\x7AE', '\x7AD', 
		'\x3', '\x2', '\x2', '\x2', '\x7AE', '\x7AF', '\x3', '\x2', '\x2', '\x2', 
		'\x7AF', '\x7B1', '\x3', '\x2', '\x2', '\x2', '\x7B0', '\x7B2', '\a', 
		'\x16', '\x2', '\x2', '\x7B1', '\x7B0', '\x3', '\x2', '\x2', '\x2', '\x7B1', 
		'\x7B2', '\x3', '\x2', '\x2', '\x2', '\x7B2', '\x7B3', '\x3', '\x2', '\x2', 
		'\x2', '\x7B3', '\x7B5', '\x5', '\x17C', '\xBF', '\x2', '\x7B4', '\x7A5', 
		'\x3', '\x2', '\x2', '\x2', '\x7B4', '\x7A9', '\x3', '\x2', '\x2', '\x2', 
		'\x7B4', '\x7AE', '\x3', '\x2', '\x2', '\x2', '\x7B5', '\x10D', '\x3', 
		'\x2', '\x2', '\x2', '\x7B6', '\x7B8', '\x5', '\x90', 'I', '\x2', '\x7B7', 
		'\x7B6', '\x3', '\x2', '\x2', '\x2', '\x7B8', '\x7BB', '\x3', '\x2', '\x2', 
		'\x2', '\x7B9', '\x7B7', '\x3', '\x2', '\x2', '\x2', '\x7B9', '\x7BA', 
		'\x3', '\x2', '\x2', '\x2', '\x7BA', '\x7BC', '\x3', '\x2', '\x2', '\x2', 
		'\x7BB', '\x7B9', '\x3', '\x2', '\x2', '\x2', '\x7BC', '\x7BD', '\a', 
		's', '\x2', '\x2', '\x7BD', '\x10F', '\x3', '\x2', '\x2', '\x2', '\x7BE', 
		'\x7BF', '\x5', '\x158', '\xAD', '\x2', '\x7BF', '\x7C1', '\a', '\x83', 
		'\x2', '\x2', '\x7C0', '\x7C2', '\x5', '\x112', '\x8A', '\x2', '\x7C1', 
		'\x7C0', '\x3', '\x2', '\x2', '\x2', '\x7C1', '\x7C2', '\x3', '\x2', '\x2', 
		'\x2', '\x7C2', '\x7C3', '\x3', '\x2', '\x2', '\x2', '\x7C3', '\x7C4', 
		'\a', '\x84', '\x2', '\x2', '\x7C4', '\x111', '\x3', '\x2', '\x2', '\x2', 
		'\x7C5', '\x7CA', '\x5', '\xF2', 'z', '\x2', '\x7C6', '\x7C7', '\a', 'v', 
		'\x2', '\x2', '\x7C7', '\x7C9', '\x5', '\xF2', 'z', '\x2', '\x7C8', '\x7C6', 
		'\x3', '\x2', '\x2', '\x2', '\x7C9', '\x7CC', '\x3', '\x2', '\x2', '\x2', 
		'\x7CA', '\x7C8', '\x3', '\x2', '\x2', '\x2', '\x7CA', '\x7CB', '\x3', 
		'\x2', '\x2', '\x2', '\x7CB', '\x7CE', '\x3', '\x2', '\x2', '\x2', '\x7CC', 
		'\x7CA', '\x3', '\x2', '\x2', '\x2', '\x7CD', '\x7CF', '\a', 'v', '\x2', 
		'\x2', '\x7CE', '\x7CD', '\x3', '\x2', '\x2', '\x2', '\x7CE', '\x7CF', 
		'\x3', '\x2', '\x2', '\x2', '\x7CF', '\x113', '\x3', '\x2', '\x2', '\x2', 
		'\x7D0', '\x7D2', '\a', '\x83', '\x2', '\x2', '\x7D1', '\x7D3', '\x5', 
		'\x116', '\x8C', '\x2', '\x7D2', '\x7D1', '\x3', '\x2', '\x2', '\x2', 
		'\x7D2', '\x7D3', '\x3', '\x2', '\x2', '\x2', '\x7D3', '\x7D4', '\x3', 
		'\x2', '\x2', '\x2', '\x7D4', '\x7D5', '\a', '\x84', '\x2', '\x2', '\x7D5', 
		'\x115', '\x3', '\x2', '\x2', '\x2', '\x7D6', '\x7D7', '\x5', '\xF2', 
		'z', '\x2', '\x7D7', '\x7D8', '\a', 'v', '\x2', '\x2', '\x7D8', '\x7E5', 
		'\x3', '\x2', '\x2', '\x2', '\x7D9', '\x7E5', '\x5', '\xFE', '\x80', '\x2', 
		'\x7DA', '\x7DD', '\x5', '\xF2', 'z', '\x2', '\x7DB', '\x7DC', '\a', 'v', 
		'\x2', '\x2', '\x7DC', '\x7DE', '\x5', '\xF2', 'z', '\x2', '\x7DD', '\x7DB', 
		'\x3', '\x2', '\x2', '\x2', '\x7DE', '\x7DF', '\x3', '\x2', '\x2', '\x2', 
		'\x7DF', '\x7DD', '\x3', '\x2', '\x2', '\x2', '\x7DF', '\x7E0', '\x3', 
		'\x2', '\x2', '\x2', '\x7E0', '\x7E2', '\x3', '\x2', '\x2', '\x2', '\x7E1', 
		'\x7E3', '\a', 'v', '\x2', '\x2', '\x7E2', '\x7E1', '\x3', '\x2', '\x2', 
		'\x2', '\x7E2', '\x7E3', '\x3', '\x2', '\x2', '\x2', '\x7E3', '\x7E5', 
		'\x3', '\x2', '\x2', '\x2', '\x7E4', '\x7D6', '\x3', '\x2', '\x2', '\x2', 
		'\x7E4', '\x7D9', '\x3', '\x2', '\x2', '\x2', '\x7E4', '\x7DA', '\x3', 
		'\x2', '\x2', '\x2', '\x7E5', '\x117', '\x3', '\x2', '\x2', '\x2', '\x7E6', 
		'\x7E7', '\a', '\x83', '\x2', '\x2', '\x7E7', '\x7E8', '\x5', '\xF2', 
		'z', '\x2', '\x7E8', '\x7E9', '\a', '\x84', '\x2', '\x2', '\x7E9', '\x119', 
		'\x3', '\x2', '\x2', '\x2', '\x7EA', '\x7EC', '\a', '\x81', '\x2', '\x2', 
		'\x7EB', '\x7ED', '\x5', '\x11C', '\x8F', '\x2', '\x7EC', '\x7EB', '\x3', 
		'\x2', '\x2', '\x2', '\x7EC', '\x7ED', '\x3', '\x2', '\x2', '\x2', '\x7ED', 
		'\x7EE', '\x3', '\x2', '\x2', '\x2', '\x7EE', '\x7EF', '\a', '\x82', '\x2', 
		'\x2', '\x7EF', '\x11B', '\x3', '\x2', '\x2', '\x2', '\x7F0', '\x7F5', 
		'\x5', '\xF2', 'z', '\x2', '\x7F1', '\x7F2', '\a', 'v', '\x2', '\x2', 
		'\x7F2', '\x7F4', '\x5', '\xF2', 'z', '\x2', '\x7F3', '\x7F1', '\x3', 
		'\x2', '\x2', '\x2', '\x7F4', '\x7F7', '\x3', '\x2', '\x2', '\x2', '\x7F5', 
		'\x7F3', '\x3', '\x2', '\x2', '\x2', '\x7F5', '\x7F6', '\x3', '\x2', '\x2', 
		'\x2', '\x7F6', '\x7F9', '\x3', '\x2', '\x2', '\x2', '\x7F7', '\x7F5', 
		'\x3', '\x2', '\x2', '\x2', '\x7F8', '\x7FA', '\a', 'v', '\x2', '\x2', 
		'\x7F9', '\x7F8', '\x3', '\x2', '\x2', '\x2', '\x7F9', '\x7FA', '\x3', 
		'\x2', '\x2', '\x2', '\x7FA', '\x11D', '\x3', '\x2', '\x2', '\x2', '\x7FB', 
		'\x7FE', '\x5', '\x158', '\xAD', '\x2', '\x7FC', '\x7FE', '\x5', '\x16C', 
		'\xB7', '\x2', '\x7FD', '\x7FB', '\x3', '\x2', '\x2', '\x2', '\x7FD', 
		'\x7FC', '\x3', '\x2', '\x2', '\x2', '\x7FE', '\x11F', '\x3', '\x2', '\x2', 
		'\x2', '\x7FF', '\x803', '\x5', '\x122', '\x92', '\x2', '\x800', '\x803', 
		'\x5', '\x144', '\xA3', '\x2', '\x801', '\x803', '\x5', '\x140', '\xA1', 
		'\x2', '\x802', '\x7FF', '\x3', '\x2', '\x2', '\x2', '\x802', '\x800', 
		'\x3', '\x2', '\x2', '\x2', '\x802', '\x801', '\x3', '\x2', '\x2', '\x2', 
		'\x803', '\x121', '\x3', '\x2', '\x2', '\x2', '\x804', '\x813', '\x5', 
		'\x124', '\x93', '\x2', '\x805', '\x813', '\x5', '\x146', '\xA4', '\x2', 
		'\x806', '\x813', '\x5', '\x142', '\xA2', '\x2', '\x807', '\x813', '\x5', 
		'\x172', '\xBA', '\x2', '\x808', '\x813', '\x5', '\x128', '\x95', '\x2', 
		'\x809', '\x813', '\x5', '\x126', '\x94', '\x2', '\x80A', '\x813', '\x5', 
		'\x130', '\x99', '\x2', '\x80B', '\x813', '\x5', '\x12E', '\x98', '\x2', 
		'\x80C', '\x813', '\x5', '\x12A', '\x96', '\x2', '\x80D', '\x813', '\x5', 
		'\x12C', '\x97', '\x2', '\x80E', '\x813', '\x5', '\x148', '\xA5', '\x2', 
		'\x80F', '\x813', '\x5', '\x170', '\xB9', '\x2', '\x810', '\x813', '\x5', 
		'\x132', '\x9A', '\x2', '\x811', '\x813', '\x5', '\x4', '\x3', '\x2', 
		'\x812', '\x804', '\x3', '\x2', '\x2', '\x2', '\x812', '\x805', '\x3', 
		'\x2', '\x2', '\x2', '\x812', '\x806', '\x3', '\x2', '\x2', '\x2', '\x812', 
		'\x807', '\x3', '\x2', '\x2', '\x2', '\x812', '\x808', '\x3', '\x2', '\x2', 
		'\x2', '\x812', '\x809', '\x3', '\x2', '\x2', '\x2', '\x812', '\x80A', 
		'\x3', '\x2', '\x2', '\x2', '\x812', '\x80B', '\x3', '\x2', '\x2', '\x2', 
		'\x812', '\x80C', '\x3', '\x2', '\x2', '\x2', '\x812', '\x80D', '\x3', 
		'\x2', '\x2', '\x2', '\x812', '\x80E', '\x3', '\x2', '\x2', '\x2', '\x812', 
		'\x80F', '\x3', '\x2', '\x2', '\x2', '\x812', '\x810', '\x3', '\x2', '\x2', 
		'\x2', '\x812', '\x811', '\x3', '\x2', '\x2', '\x2', '\x813', '\x123', 
		'\x3', '\x2', '\x2', '\x2', '\x814', '\x815', '\a', '\x83', '\x2', '\x2', 
		'\x815', '\x816', '\x5', '\x120', '\x91', '\x2', '\x816', '\x817', '\a', 
		'\x84', '\x2', '\x2', '\x817', '\x125', '\x3', '\x2', '\x2', '\x2', '\x818', 
		'\x819', '\a', 'Z', '\x2', '\x2', '\x819', '\x127', '\x3', '\x2', '\x2', 
		'\x2', '\x81A', '\x825', '\a', '\x83', '\x2', '\x2', '\x81B', '\x81C', 
		'\x5', '\x120', '\x91', '\x2', '\x81C', '\x81D', '\a', 'v', '\x2', '\x2', 
		'\x81D', '\x81F', '\x3', '\x2', '\x2', '\x2', '\x81E', '\x81B', '\x3', 
		'\x2', '\x2', '\x2', '\x81F', '\x820', '\x3', '\x2', '\x2', '\x2', '\x820', 
		'\x81E', '\x3', '\x2', '\x2', '\x2', '\x820', '\x821', '\x3', '\x2', '\x2', 
		'\x2', '\x821', '\x823', '\x3', '\x2', '\x2', '\x2', '\x822', '\x824', 
		'\x5', '\x120', '\x91', '\x2', '\x823', '\x822', '\x3', '\x2', '\x2', 
		'\x2', '\x823', '\x824', '\x3', '\x2', '\x2', '\x2', '\x824', '\x826', 
		'\x3', '\x2', '\x2', '\x2', '\x825', '\x81E', '\x3', '\x2', '\x2', '\x2', 
		'\x825', '\x826', '\x3', '\x2', '\x2', '\x2', '\x826', '\x827', '\x3', 
		'\x2', '\x2', '\x2', '\x827', '\x828', '\a', '\x84', '\x2', '\x2', '\x828', 
		'\x129', '\x3', '\x2', '\x2', '\x2', '\x829', '\x82A', '\a', '\x81', '\x2', 
		'\x2', '\x82A', '\x82B', '\x5', '\x120', '\x91', '\x2', '\x82B', '\x82C', 
		'\a', 'w', '\x2', '\x2', '\x82C', '\x82D', '\x5', '\x9C', 'O', '\x2', 
		'\x82D', '\x82E', '\a', '\x82', '\x2', '\x2', '\x82E', '\x12B', '\x3', 
		'\x2', '\x2', '\x2', '\x82F', '\x830', '\a', '\x81', '\x2', '\x2', '\x830', 
		'\x831', '\x5', '\x120', '\x91', '\x2', '\x831', '\x832', '\a', '\x82', 
		'\x2', '\x2', '\x832', '\x12D', '\x3', '\x2', '\x2', '\x2', '\x833', '\x835', 
		'\a', '[', '\x2', '\x2', '\x834', '\x836', '\x5', '\x152', '\xAA', '\x2', 
		'\x835', '\x834', '\x3', '\x2', '\x2', '\x2', '\x835', '\x836', '\x3', 
		'\x2', '\x2', '\x2', '\x836', '\x838', '\x3', '\x2', '\x2', '\x2', '\x837', 
		'\x839', '\a', '\x16', '\x2', '\x2', '\x838', '\x837', '\x3', '\x2', '\x2', 
		'\x2', '\x838', '\x839', '\x3', '\x2', '\x2', '\x2', '\x839', '\x83A', 
		'\x3', '\x2', '\x2', '\x2', '\x83A', '\x83B', '\x5', '\x122', '\x92', 
		'\x2', '\x83B', '\x12F', '\x3', '\x2', '\x2', '\x2', '\x83C', '\x83D', 
		'\a', 'V', '\x2', '\x2', '\x83D', '\x83E', '\t', '\v', '\x2', '\x2', '\x83E', 
		'\x83F', '\x5', '\x122', '\x92', '\x2', '\x83F', '\x131', '\x3', '\x2', 
		'\x2', '\x2', '\x840', '\x842', '\x5', '\x8A', '\x46', '\x2', '\x841', 
		'\x840', '\x3', '\x2', '\x2', '\x2', '\x841', '\x842', '\x3', '\x2', '\x2', 
		'\x2', '\x842', '\x843', '\x3', '\x2', '\x2', '\x2', '\x843', '\x844', 
		'\x5', '\x134', '\x9B', '\x2', '\x844', '\x845', '\a', '\f', '\x2', '\x2', 
		'\x845', '\x847', '\a', '\x83', '\x2', '\x2', '\x846', '\x848', '\x5', 
		'\x138', '\x9D', '\x2', '\x847', '\x846', '\x3', '\x2', '\x2', '\x2', 
		'\x847', '\x848', '\x3', '\x2', '\x2', '\x2', '\x848', '\x849', '\x3', 
		'\x2', '\x2', '\x2', '\x849', '\x84B', '\a', '\x84', '\x2', '\x2', '\x84A', 
		'\x84C', '\x5', '\x136', '\x9C', '\x2', '\x84B', '\x84A', '\x3', '\x2', 
		'\x2', '\x2', '\x84B', '\x84C', '\x3', '\x2', '\x2', '\x2', '\x84C', '\x133', 
		'\x3', '\x2', '\x2', '\x2', '\x84D', '\x84F', '\a', '\"', '\x2', '\x2', 
		'\x84E', '\x84D', '\x3', '\x2', '\x2', '\x2', '\x84E', '\x84F', '\x3', 
		'\x2', '\x2', '\x2', '\x84F', '\x854', '\x3', '\x2', '\x2', '\x2', '\x850', 
		'\x852', '\a', '\n', '\x2', '\x2', '\x851', '\x853', '\x5', ':', '\x1E', 
		'\x2', '\x852', '\x851', '\x3', '\x2', '\x2', '\x2', '\x852', '\x853', 
		'\x3', '\x2', '\x2', '\x2', '\x853', '\x855', '\x3', '\x2', '\x2', '\x2', 
		'\x854', '\x850', '\x3', '\x2', '\x2', '\x2', '\x854', '\x855', '\x3', 
		'\x2', '\x2', '\x2', '\x855', '\x135', '\x3', '\x2', '\x2', '\x2', '\x856', 
		'\x857', '\a', 'z', '\x2', '\x2', '\x857', '\x858', '\x5', '\x122', '\x92', 
		'\x2', '\x858', '\x137', '\x3', '\x2', '\x2', '\x2', '\x859', '\x85C', 
		'\x5', '\x13A', '\x9E', '\x2', '\x85A', '\x85C', '\x5', '\x13E', '\xA0', 
		'\x2', '\x85B', '\x859', '\x3', '\x2', '\x2', '\x2', '\x85B', '\x85A', 
		'\x3', '\x2', '\x2', '\x2', '\x85C', '\x139', '\x3', '\x2', '\x2', '\x2', 
		'\x85D', '\x862', '\x5', '\x13C', '\x9F', '\x2', '\x85E', '\x85F', '\a', 
		'v', '\x2', '\x2', '\x85F', '\x861', '\x5', '\x13C', '\x9F', '\x2', '\x860', 
		'\x85E', '\x3', '\x2', '\x2', '\x2', '\x861', '\x864', '\x3', '\x2', '\x2', 
		'\x2', '\x862', '\x860', '\x3', '\x2', '\x2', '\x2', '\x862', '\x863', 
		'\x3', '\x2', '\x2', '\x2', '\x863', '\x866', '\x3', '\x2', '\x2', '\x2', 
		'\x864', '\x862', '\x3', '\x2', '\x2', '\x2', '\x865', '\x867', '\a', 
		'v', '\x2', '\x2', '\x866', '\x865', '\x3', '\x2', '\x2', '\x2', '\x866', 
		'\x867', '\x3', '\x2', '\x2', '\x2', '\x867', '\x13B', '\x3', '\x2', '\x2', 
		'\x2', '\x868', '\x86A', '\x5', '\x90', 'I', '\x2', '\x869', '\x868', 
		'\x3', '\x2', '\x2', '\x2', '\x86A', '\x86D', '\x3', '\x2', '\x2', '\x2', 
		'\x86B', '\x869', '\x3', '\x2', '\x2', '\x2', '\x86B', '\x86C', '\x3', 
		'\x2', '\x2', '\x2', '\x86C', '\x873', '\x3', '\x2', '\x2', '\x2', '\x86D', 
		'\x86B', '\x3', '\x2', '\x2', '\x2', '\x86E', '\x871', '\x5', '\x17C', 
		'\xBF', '\x2', '\x86F', '\x871', '\a', 'q', '\x2', '\x2', '\x870', '\x86E', 
		'\x3', '\x2', '\x2', '\x2', '\x870', '\x86F', '\x3', '\x2', '\x2', '\x2', 
		'\x871', '\x872', '\x3', '\x2', '\x2', '\x2', '\x872', '\x874', '\a', 
		'x', '\x2', '\x2', '\x873', '\x870', '\x3', '\x2', '\x2', '\x2', '\x873', 
		'\x874', '\x3', '\x2', '\x2', '\x2', '\x874', '\x875', '\x3', '\x2', '\x2', 
		'\x2', '\x875', '\x876', '\x5', '\x120', '\x91', '\x2', '\x876', '\x13D', 
		'\x3', '\x2', '\x2', '\x2', '\x877', '\x878', '\x5', '\x13C', '\x9F', 
		'\x2', '\x878', '\x879', '\a', 'v', '\x2', '\x2', '\x879', '\x87B', '\x3', 
		'\x2', '\x2', '\x2', '\x87A', '\x877', '\x3', '\x2', '\x2', '\x2', '\x87B', 
		'\x87E', '\x3', '\x2', '\x2', '\x2', '\x87C', '\x87A', '\x3', '\x2', '\x2', 
		'\x2', '\x87C', '\x87D', '\x3', '\x2', '\x2', '\x2', '\x87D', '\x87F', 
		'\x3', '\x2', '\x2', '\x2', '\x87E', '\x87C', '\x3', '\x2', '\x2', '\x2', 
		'\x87F', '\x880', '\x5', '\x13C', '\x9F', '\x2', '\x880', '\x884', '\a', 
		'v', '\x2', '\x2', '\x881', '\x883', '\x5', '\x90', 'I', '\x2', '\x882', 
		'\x881', '\x3', '\x2', '\x2', '\x2', '\x883', '\x886', '\x3', '\x2', '\x2', 
		'\x2', '\x884', '\x882', '\x3', '\x2', '\x2', '\x2', '\x884', '\x885', 
		'\x3', '\x2', '\x2', '\x2', '\x885', '\x887', '\x3', '\x2', '\x2', '\x2', 
		'\x886', '\x884', '\x3', '\x2', '\x2', '\x2', '\x887', '\x888', '\a', 
		't', '\x2', '\x2', '\x888', '\x13F', '\x3', '\x2', '\x2', '\x2', '\x889', 
		'\x88B', '\a', '(', '\x2', '\x2', '\x88A', '\x889', '\x3', '\x2', '\x2', 
		'\x2', '\x88A', '\x88B', '\x3', '\x2', '\x2', '\x2', '\x88B', '\x88C', 
		'\x3', '\x2', '\x2', '\x2', '\x88C', '\x88D', '\x5', '\x14A', '\xA6', 
		'\x2', '\x88D', '\x141', '\x3', '\x2', '\x2', '\x2', '\x88E', '\x890', 
		'\a', '(', '\x2', '\x2', '\x88F', '\x88E', '\x3', '\x2', '\x2', '\x2', 
		'\x88F', '\x890', '\x3', '\x2', '\x2', '\x2', '\x890', '\x891', '\x3', 
		'\x2', '\x2', '\x2', '\x891', '\x892', '\x5', '\x14E', '\xA8', '\x2', 
		'\x892', '\x143', '\x3', '\x2', '\x2', '\x2', '\x893', '\x894', '\a', 
		'\xF', '\x2', '\x2', '\x894', '\x895', '\x5', '\x14A', '\xA6', '\x2', 
		'\x895', '\x145', '\x3', '\x2', '\x2', '\x2', '\x896', '\x897', '\a', 
		'\xF', '\x2', '\x2', '\x897', '\x898', '\x5', '\x14E', '\xA8', '\x2', 
		'\x898', '\x147', '\x3', '\x2', '\x2', '\x2', '\x899', '\x89A', '\a', 
		'q', '\x2', '\x2', '\x89A', '\x149', '\x3', '\x2', '\x2', '\x2', '\x89B', 
		'\x8A0', '\x5', '\x14C', '\xA7', '\x2', '\x89C', '\x89D', '\a', 'T', '\x2', 
		'\x2', '\x89D', '\x89F', '\x5', '\x14C', '\xA7', '\x2', '\x89E', '\x89C', 
		'\x3', '\x2', '\x2', '\x2', '\x89F', '\x8A2', '\x3', '\x2', '\x2', '\x2', 
		'\x8A0', '\x89E', '\x3', '\x2', '\x2', '\x2', '\x8A0', '\x8A1', '\x3', 
		'\x2', '\x2', '\x2', '\x8A1', '\x8A4', '\x3', '\x2', '\x2', '\x2', '\x8A2', 
		'\x8A0', '\x3', '\x2', '\x2', '\x2', '\x8A3', '\x8A5', '\a', 'T', '\x2', 
		'\x2', '\x8A4', '\x8A3', '\x3', '\x2', '\x2', '\x2', '\x8A4', '\x8A5', 
		'\x3', '\x2', '\x2', '\x2', '\x8A5', '\x14B', '\x3', '\x2', '\x2', '\x2', 
		'\x8A6', '\x8A9', '\x5', '\x152', '\xAA', '\x2', '\x8A7', '\x8A9', '\x5', 
		'\x14E', '\xA8', '\x2', '\x8A8', '\x8A6', '\x3', '\x2', '\x2', '\x2', 
		'\x8A8', '\x8A7', '\x3', '\x2', '\x2', '\x2', '\x8A9', '\x14D', '\x3', 
		'\x2', '\x2', '\x2', '\x8AA', '\x8AC', '\a', '~', '\x2', '\x2', '\x8AB', 
		'\x8AA', '\x3', '\x2', '\x2', '\x2', '\x8AB', '\x8AC', '\x3', '\x2', '\x2', 
		'\x2', '\x8AC', '\x8AE', '\x3', '\x2', '\x2', '\x2', '\x8AD', '\x8AF', 
		'\x5', '\x8A', '\x46', '\x2', '\x8AE', '\x8AD', '\x3', '\x2', '\x2', '\x2', 
		'\x8AE', '\x8AF', '\x3', '\x2', '\x2', '\x2', '\x8AF', '\x8B0', '\x3', 
		'\x2', '\x2', '\x2', '\x8B0', '\x8BC', '\x5', '\x172', '\xBA', '\x2', 
		'\x8B1', '\x8B3', '\a', '\x83', '\x2', '\x2', '\x8B2', '\x8B4', '\a', 
		'~', '\x2', '\x2', '\x8B3', '\x8B2', '\x3', '\x2', '\x2', '\x2', '\x8B3', 
		'\x8B4', '\x3', '\x2', '\x2', '\x2', '\x8B4', '\x8B6', '\x3', '\x2', '\x2', 
		'\x2', '\x8B5', '\x8B7', '\x5', '\x8A', '\x46', '\x2', '\x8B6', '\x8B5', 
		'\x3', '\x2', '\x2', '\x2', '\x8B6', '\x8B7', '\x3', '\x2', '\x2', '\x2', 
		'\x8B7', '\x8B8', '\x3', '\x2', '\x2', '\x2', '\x8B8', '\x8B9', '\x5', 
		'\x172', '\xBA', '\x2', '\x8B9', '\x8BA', '\a', '\x84', '\x2', '\x2', 
		'\x8BA', '\x8BC', '\x3', '\x2', '\x2', '\x2', '\x8BB', '\x8AB', '\x3', 
		'\x2', '\x2', '\x2', '\x8BB', '\x8B1', '\x3', '\x2', '\x2', '\x2', '\x8BC', 
		'\x14F', '\x3', '\x2', '\x2', '\x2', '\x8BD', '\x8BE', '\x5', '\x152', 
		'\xAA', '\x2', '\x8BE', '\x8BF', '\a', 'T', '\x2', '\x2', '\x8BF', '\x8C1', 
		'\x3', '\x2', '\x2', '\x2', '\x8C0', '\x8BD', '\x3', '\x2', '\x2', '\x2', 
		'\x8C1', '\x8C4', '\x3', '\x2', '\x2', '\x2', '\x8C2', '\x8C0', '\x3', 
		'\x2', '\x2', '\x2', '\x8C2', '\x8C3', '\x3', '\x2', '\x2', '\x2', '\x8C3', 
		'\x8C6', '\x3', '\x2', '\x2', '\x2', '\x8C4', '\x8C2', '\x3', '\x2', '\x2', 
		'\x2', '\x8C5', '\x8C7', '\x5', '\x152', '\xAA', '\x2', '\x8C6', '\x8C5', 
		'\x3', '\x2', '\x2', '\x2', '\x8C6', '\x8C7', '\x3', '\x2', '\x2', '\x2', 
		'\x8C7', '\x151', '\x3', '\x2', '\x2', '\x2', '\x8C8', '\x8C9', '\t', 
		'\f', '\x2', '\x2', '\x8C9', '\x153', '\x3', '\x2', '\x2', '\x2', '\x8CA', 
		'\x8CC', '\a', 'y', '\x2', '\x2', '\x8CB', '\x8CA', '\x3', '\x2', '\x2', 
		'\x2', '\x8CB', '\x8CC', '\x3', '\x2', '\x2', '\x2', '\x8CC', '\x8CD', 
		'\x3', '\x2', '\x2', '\x2', '\x8CD', '\x8D2', '\x5', '\x156', '\xAC', 
		'\x2', '\x8CE', '\x8CF', '\a', 'y', '\x2', '\x2', '\x8CF', '\x8D1', '\x5', 
		'\x156', '\xAC', '\x2', '\x8D0', '\x8CE', '\x3', '\x2', '\x2', '\x2', 
		'\x8D1', '\x8D4', '\x3', '\x2', '\x2', '\x2', '\x8D2', '\x8D0', '\x3', 
		'\x2', '\x2', '\x2', '\x8D2', '\x8D3', '\x3', '\x2', '\x2', '\x2', '\x8D3', 
		'\x155', '\x3', '\x2', '\x2', '\x2', '\x8D4', '\x8D2', '\x3', '\x2', '\x2', 
		'\x2', '\x8D5', '\x8DB', '\x5', '\x17C', '\xBF', '\x2', '\x8D6', '\x8DB', 
		'\a', '\x1E', '\x2', '\x2', '\x8D7', '\x8DB', '\a', '\x1A', '\x2', '\x2', 
		'\x8D8', '\x8DB', '\a', '\a', '\x2', '\x2', '\x8D9', '\x8DB', '\a', ':', 
		'\x2', '\x2', '\x8DA', '\x8D5', '\x3', '\x2', '\x2', '\x2', '\x8DA', '\x8D6', 
		'\x3', '\x2', '\x2', '\x2', '\x8DA', '\x8D7', '\x3', '\x2', '\x2', '\x2', 
		'\x8DA', '\x8D8', '\x3', '\x2', '\x2', '\x2', '\x8DA', '\x8D9', '\x3', 
		'\x2', '\x2', '\x2', '\x8DB', '\x157', '\x3', '\x2', '\x2', '\x2', '\x8DC', 
		'\x8DE', '\a', 'y', '\x2', '\x2', '\x8DD', '\x8DC', '\x3', '\x2', '\x2', 
		'\x2', '\x8DD', '\x8DE', '\x3', '\x2', '\x2', '\x2', '\x8DE', '\x8DF', 
		'\x3', '\x2', '\x2', '\x2', '\x8DF', '\x8E4', '\x5', '\x15A', '\xAE', 
		'\x2', '\x8E0', '\x8E1', '\a', 'y', '\x2', '\x2', '\x8E1', '\x8E3', '\x5', 
		'\x15A', '\xAE', '\x2', '\x8E2', '\x8E0', '\x3', '\x2', '\x2', '\x2', 
		'\x8E3', '\x8E6', '\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8E2', '\x3', 
		'\x2', '\x2', '\x2', '\x8E4', '\x8E5', '\x3', '\x2', '\x2', '\x2', '\x8E5', 
		'\x159', '\x3', '\x2', '\x2', '\x2', '\x8E6', '\x8E4', '\x3', '\x2', '\x2', 
		'\x2', '\x8E7', '\x8EA', '\x5', '\x15C', '\xAF', '\x2', '\x8E8', '\x8E9', 
		'\a', 'y', '\x2', '\x2', '\x8E9', '\x8EB', '\x5', '\x15E', '\xB0', '\x2', 
		'\x8EA', '\x8E8', '\x3', '\x2', '\x2', '\x2', '\x8EA', '\x8EB', '\x3', 
		'\x2', '\x2', '\x2', '\x8EB', '\x15B', '\x3', '\x2', '\x2', '\x2', '\x8EC', 
		'\x8F3', '\x5', '\x17C', '\xBF', '\x2', '\x8ED', '\x8F3', '\a', '\x1E', 
		'\x2', '\x2', '\x8EE', '\x8F3', '\a', '\x1A', '\x2', '\x2', '\x8EF', '\x8F3', 
		'\a', '\x1B', '\x2', '\x2', '\x8F0', '\x8F3', '\a', '\a', '\x2', '\x2', 
		'\x8F1', '\x8F3', '\a', ':', '\x2', '\x2', '\x8F2', '\x8EC', '\x3', '\x2', 
		'\x2', '\x2', '\x8F2', '\x8ED', '\x3', '\x2', '\x2', '\x2', '\x8F2', '\x8EE', 
		'\x3', '\x2', '\x2', '\x2', '\x8F2', '\x8EF', '\x3', '\x2', '\x2', '\x2', 
		'\x8F2', '\x8F0', '\x3', '\x2', '\x2', '\x2', '\x8F2', '\x8F1', '\x3', 
		'\x2', '\x2', '\x2', '\x8F3', '\x15D', '\x3', '\x2', '\x2', '\x2', '\x8F4', 
		'\x8F5', '\a', 'm', '\x2', '\x2', '\x8F5', '\x920', '\a', 'l', '\x2', 
		'\x2', '\x8F6', '\x8F7', '\a', 'm', '\x2', '\x2', '\x8F7', '\x8FA', '\x5', 
		'\x164', '\xB3', '\x2', '\x8F8', '\x8F9', '\a', 'v', '\x2', '\x2', '\x8F9', 
		'\x8FB', '\x5', '\x166', '\xB4', '\x2', '\x8FA', '\x8F8', '\x3', '\x2', 
		'\x2', '\x2', '\x8FA', '\x8FB', '\x3', '\x2', '\x2', '\x2', '\x8FB', '\x8FE', 
		'\x3', '\x2', '\x2', '\x2', '\x8FC', '\x8FD', '\a', 'v', '\x2', '\x2', 
		'\x8FD', '\x8FF', '\x5', '\x168', '\xB5', '\x2', '\x8FE', '\x8FC', '\x3', 
		'\x2', '\x2', '\x2', '\x8FE', '\x8FF', '\x3', '\x2', '\x2', '\x2', '\x8FF', 
		'\x901', '\x3', '\x2', '\x2', '\x2', '\x900', '\x902', '\a', 'v', '\x2', 
		'\x2', '\x901', '\x900', '\x3', '\x2', '\x2', '\x2', '\x901', '\x902', 
		'\x3', '\x2', '\x2', '\x2', '\x902', '\x903', '\x3', '\x2', '\x2', '\x2', 
		'\x903', '\x904', '\a', 'l', '\x2', '\x2', '\x904', '\x920', '\x3', '\x2', 
		'\x2', '\x2', '\x905', '\x906', '\a', 'm', '\x2', '\x2', '\x906', '\x909', 
		'\x5', '\x166', '\xB4', '\x2', '\x907', '\x908', '\a', 'v', '\x2', '\x2', 
		'\x908', '\x90A', '\x5', '\x168', '\xB5', '\x2', '\x909', '\x907', '\x3', 
		'\x2', '\x2', '\x2', '\x909', '\x90A', '\x3', '\x2', '\x2', '\x2', '\x90A', 
		'\x90C', '\x3', '\x2', '\x2', '\x2', '\x90B', '\x90D', '\a', 'v', '\x2', 
		'\x2', '\x90C', '\x90B', '\x3', '\x2', '\x2', '\x2', '\x90C', '\x90D', 
		'\x3', '\x2', '\x2', '\x2', '\x90D', '\x90E', '\x3', '\x2', '\x2', '\x2', 
		'\x90E', '\x90F', '\a', 'l', '\x2', '\x2', '\x90F', '\x920', '\x3', '\x2', 
		'\x2', '\x2', '\x910', '\x916', '\a', 'm', '\x2', '\x2', '\x911', '\x912', 
		'\x5', '\x160', '\xB1', '\x2', '\x912', '\x913', '\a', 'v', '\x2', '\x2', 
		'\x913', '\x915', '\x3', '\x2', '\x2', '\x2', '\x914', '\x911', '\x3', 
		'\x2', '\x2', '\x2', '\x915', '\x918', '\x3', '\x2', '\x2', '\x2', '\x916', 
		'\x914', '\x3', '\x2', '\x2', '\x2', '\x916', '\x917', '\x3', '\x2', '\x2', 
		'\x2', '\x917', '\x919', '\x3', '\x2', '\x2', '\x2', '\x918', '\x916', 
		'\x3', '\x2', '\x2', '\x2', '\x919', '\x91B', '\x5', '\x160', '\xB1', 
		'\x2', '\x91A', '\x91C', '\a', 'v', '\x2', '\x2', '\x91B', '\x91A', '\x3', 
		'\x2', '\x2', '\x2', '\x91B', '\x91C', '\x3', '\x2', '\x2', '\x2', '\x91C', 
		'\x91D', '\x3', '\x2', '\x2', '\x2', '\x91D', '\x91E', '\a', 'l', '\x2', 
		'\x2', '\x91E', '\x920', '\x3', '\x2', '\x2', '\x2', '\x91F', '\x8F4', 
		'\x3', '\x2', '\x2', '\x2', '\x91F', '\x8F6', '\x3', '\x2', '\x2', '\x2', 
		'\x91F', '\x905', '\x3', '\x2', '\x2', '\x2', '\x91F', '\x910', '\x3', 
		'\x2', '\x2', '\x2', '\x920', '\x15F', '\x3', '\x2', '\x2', '\x2', '\x921', 
		'\x926', '\x5', '\x152', '\xAA', '\x2', '\x922', '\x926', '\x5', '\x120', 
		'\x91', '\x2', '\x923', '\x926', '\x5', '\x162', '\xB2', '\x2', '\x924', 
		'\x926', '\x5', '\x16A', '\xB6', '\x2', '\x925', '\x921', '\x3', '\x2', 
		'\x2', '\x2', '\x925', '\x922', '\x3', '\x2', '\x2', '\x2', '\x925', '\x923', 
		'\x3', '\x2', '\x2', '\x2', '\x925', '\x924', '\x3', '\x2', '\x2', '\x2', 
		'\x926', '\x161', '\x3', '\x2', '\x2', '\x2', '\x927', '\x92E', '\x5', 
		'\xA8', 'U', '\x2', '\x928', '\x92A', '\a', 'U', '\x2', '\x2', '\x929', 
		'\x928', '\x3', '\x2', '\x2', '\x2', '\x929', '\x92A', '\x3', '\x2', '\x2', 
		'\x2', '\x92A', '\x92B', '\x3', '\x2', '\x2', '\x2', '\x92B', '\x92E', 
		'\x5', '\xA4', 'S', '\x2', '\x92C', '\x92E', '\x5', '\x156', '\xAC', '\x2', 
		'\x92D', '\x927', '\x3', '\x2', '\x2', '\x2', '\x92D', '\x929', '\x3', 
		'\x2', '\x2', '\x2', '\x92D', '\x92C', '\x3', '\x2', '\x2', '\x2', '\x92E', 
		'\x163', '\x3', '\x2', '\x2', '\x2', '\x92F', '\x934', '\x5', '\x152', 
		'\xAA', '\x2', '\x930', '\x931', '\a', 'v', '\x2', '\x2', '\x931', '\x933', 
		'\x5', '\x152', '\xAA', '\x2', '\x932', '\x930', '\x3', '\x2', '\x2', 
		'\x2', '\x933', '\x936', '\x3', '\x2', '\x2', '\x2', '\x934', '\x932', 
		'\x3', '\x2', '\x2', '\x2', '\x934', '\x935', '\x3', '\x2', '\x2', '\x2', 
		'\x935', '\x165', '\x3', '\x2', '\x2', '\x2', '\x936', '\x934', '\x3', 
		'\x2', '\x2', '\x2', '\x937', '\x93C', '\x5', '\x120', '\x91', '\x2', 
		'\x938', '\x939', '\a', 'v', '\x2', '\x2', '\x939', '\x93B', '\x5', '\x120', 
		'\x91', '\x2', '\x93A', '\x938', '\x3', '\x2', '\x2', '\x2', '\x93B', 
		'\x93E', '\x3', '\x2', '\x2', '\x2', '\x93C', '\x93A', '\x3', '\x2', '\x2', 
		'\x2', '\x93C', '\x93D', '\x3', '\x2', '\x2', '\x2', '\x93D', '\x167', 
		'\x3', '\x2', '\x2', '\x2', '\x93E', '\x93C', '\x3', '\x2', '\x2', '\x2', 
		'\x93F', '\x944', '\x5', '\x16A', '\xB6', '\x2', '\x940', '\x941', '\a', 
		'v', '\x2', '\x2', '\x941', '\x943', '\x5', '\x16A', '\xB6', '\x2', '\x942', 
		'\x940', '\x3', '\x2', '\x2', '\x2', '\x943', '\x946', '\x3', '\x2', '\x2', 
		'\x2', '\x944', '\x942', '\x3', '\x2', '\x2', '\x2', '\x944', '\x945', 
		'\x3', '\x2', '\x2', '\x2', '\x945', '\x169', '\x3', '\x2', '\x2', '\x2', 
		'\x946', '\x944', '\x3', '\x2', '\x2', '\x2', '\x947', '\x948', '\x5', 
		'\x17C', '\xBF', '\x2', '\x948', '\x949', '\a', 'i', '\x2', '\x2', '\x949', 
		'\x94A', '\x5', '\x120', '\x91', '\x2', '\x94A', '\x16B', '\x3', '\x2', 
		'\x2', '\x2', '\x94B', '\x94E', '\x5', '\x16E', '\xB8', '\x2', '\x94C', 
		'\x94D', '\a', 'y', '\x2', '\x2', '\x94D', '\x94F', '\x5', '\x15A', '\xAE', 
		'\x2', '\x94E', '\x94C', '\x3', '\x2', '\x2', '\x2', '\x94F', '\x950', 
		'\x3', '\x2', '\x2', '\x2', '\x950', '\x94E', '\x3', '\x2', '\x2', '\x2', 
		'\x950', '\x951', '\x3', '\x2', '\x2', '\x2', '\x951', '\x16D', '\x3', 
		'\x2', '\x2', '\x2', '\x952', '\x953', '\a', 'm', '\x2', '\x2', '\x953', 
		'\x956', '\x5', '\x120', '\x91', '\x2', '\x954', '\x955', '\a', '\x3', 
		'\x2', '\x2', '\x955', '\x957', '\x5', '\x172', '\xBA', '\x2', '\x956', 
		'\x954', '\x3', '\x2', '\x2', '\x2', '\x956', '\x957', '\x3', '\x2', '\x2', 
		'\x2', '\x957', '\x958', '\x3', '\x2', '\x2', '\x2', '\x958', '\x959', 
		'\a', 'l', '\x2', '\x2', '\x959', '\x16F', '\x3', '\x2', '\x2', '\x2', 
		'\x95A', '\x95D', '\x5', '\x16E', '\xB8', '\x2', '\x95B', '\x95C', '\a', 
		'y', '\x2', '\x2', '\x95C', '\x95E', '\x5', '\x174', '\xBB', '\x2', '\x95D', 
		'\x95B', '\x3', '\x2', '\x2', '\x2', '\x95E', '\x95F', '\x3', '\x2', '\x2', 
		'\x2', '\x95F', '\x95D', '\x3', '\x2', '\x2', '\x2', '\x95F', '\x960', 
		'\x3', '\x2', '\x2', '\x2', '\x960', '\x171', '\x3', '\x2', '\x2', '\x2', 
		'\x961', '\x963', '\a', 'y', '\x2', '\x2', '\x962', '\x961', '\x3', '\x2', 
		'\x2', '\x2', '\x962', '\x963', '\x3', '\x2', '\x2', '\x2', '\x963', '\x964', 
		'\x3', '\x2', '\x2', '\x2', '\x964', '\x969', '\x5', '\x174', '\xBB', 
		'\x2', '\x965', '\x966', '\a', 'y', '\x2', '\x2', '\x966', '\x968', '\x5', 
		'\x174', '\xBB', '\x2', '\x967', '\x965', '\x3', '\x2', '\x2', '\x2', 
		'\x968', '\x96B', '\x3', '\x2', '\x2', '\x2', '\x969', '\x967', '\x3', 
		'\x2', '\x2', '\x2', '\x969', '\x96A', '\x3', '\x2', '\x2', '\x2', '\x96A', 
		'\x173', '\x3', '\x2', '\x2', '\x2', '\x96B', '\x969', '\x3', '\x2', '\x2', 
		'\x2', '\x96C', '\x96E', '\x5', '\x15C', '\xAF', '\x2', '\x96D', '\x96F', 
		'\a', 'y', '\x2', '\x2', '\x96E', '\x96D', '\x3', '\x2', '\x2', '\x2', 
		'\x96E', '\x96F', '\x3', '\x2', '\x2', '\x2', '\x96F', '\x972', '\x3', 
		'\x2', '\x2', '\x2', '\x970', '\x973', '\x5', '\x15E', '\xB0', '\x2', 
		'\x971', '\x973', '\x5', '\x176', '\xBC', '\x2', '\x972', '\x970', '\x3', 
		'\x2', '\x2', '\x2', '\x972', '\x971', '\x3', '\x2', '\x2', '\x2', '\x972', 
		'\x973', '\x3', '\x2', '\x2', '\x2', '\x973', '\x175', '\x3', '\x2', '\x2', 
		'\x2', '\x974', '\x976', '\a', '\x83', '\x2', '\x2', '\x975', '\x977', 
		'\x5', '\x178', '\xBD', '\x2', '\x976', '\x975', '\x3', '\x2', '\x2', 
		'\x2', '\x976', '\x977', '\x3', '\x2', '\x2', '\x2', '\x977', '\x978', 
		'\x3', '\x2', '\x2', '\x2', '\x978', '\x97B', '\a', '\x84', '\x2', '\x2', 
		'\x979', '\x97A', '\a', 'z', '\x2', '\x2', '\x97A', '\x97C', '\x5', '\x120', 
		'\x91', '\x2', '\x97B', '\x979', '\x3', '\x2', '\x2', '\x2', '\x97B', 
		'\x97C', '\x3', '\x2', '\x2', '\x2', '\x97C', '\x177', '\x3', '\x2', '\x2', 
		'\x2', '\x97D', '\x982', '\x5', '\x120', '\x91', '\x2', '\x97E', '\x97F', 
		'\a', 'v', '\x2', '\x2', '\x97F', '\x981', '\x5', '\x120', '\x91', '\x2', 
		'\x980', '\x97E', '\x3', '\x2', '\x2', '\x2', '\x981', '\x984', '\x3', 
		'\x2', '\x2', '\x2', '\x982', '\x980', '\x3', '\x2', '\x2', '\x2', '\x982', 
		'\x983', '\x3', '\x2', '\x2', '\x2', '\x983', '\x986', '\x3', '\x2', '\x2', 
		'\x2', '\x984', '\x982', '\x3', '\x2', '\x2', '\x2', '\x985', '\x987', 
		'\a', 'v', '\x2', '\x2', '\x986', '\x985', '\x3', '\x2', '\x2', '\x2', 
		'\x986', '\x987', '\x3', '\x2', '\x2', '\x2', '\x987', '\x179', '\x3', 
		'\x2', '\x2', '\x2', '\x988', '\x992', '\a', '\x17', '\x2', '\x2', '\x989', 
		'\x98F', '\a', '\x83', '\x2', '\x2', '\x98A', '\x990', '\a', '\a', '\x2', 
		'\x2', '\x98B', '\x990', '\a', '\x1A', '\x2', '\x2', '\x98C', '\x990', 
		'\a', '\x1E', '\x2', '\x2', '\x98D', '\x98E', '\a', '\x10', '\x2', '\x2', 
		'\x98E', '\x990', '\x5', '\x154', '\xAB', '\x2', '\x98F', '\x98A', '\x3', 
		'\x2', '\x2', '\x2', '\x98F', '\x98B', '\x3', '\x2', '\x2', '\x2', '\x98F', 
		'\x98C', '\x3', '\x2', '\x2', '\x2', '\x98F', '\x98D', '\x3', '\x2', '\x2', 
		'\x2', '\x990', '\x991', '\x3', '\x2', '\x2', '\x2', '\x991', '\x993', 
		'\a', '\x84', '\x2', '\x2', '\x992', '\x989', '\x3', '\x2', '\x2', '\x2', 
		'\x992', '\x993', '\x3', '\x2', '\x2', '\x2', '\x993', '\x17B', '\x3', 
		'\x2', '\x2', '\x2', '\x994', '\x995', '\t', '\r', '\x2', '\x2', '\x995', 
		'\x17D', '\x3', '\x2', '\x2', '\x2', '\x996', '\x997', '\t', '\xE', '\x2', 
		'\x2', '\x997', '\x17F', '\x3', '\x2', '\x2', '\x2', '\x998', '\x99F', 
		'\x5', '\x17E', '\xC0', '\x2', '\x999', '\x99F', '\x5', '\x17C', '\xBF', 
		'\x2', '\x99A', '\x99F', '\a', '\x38', '\x2', '\x2', '\x99B', '\x99F', 
		'\a', '\x39', '\x2', '\x2', '\x99C', '\x99F', '\a', ':', '\x2', '\x2', 
		'\x99D', '\x99F', '\a', 'S', '\x2', '\x2', '\x99E', '\x998', '\x3', '\x2', 
		'\x2', '\x2', '\x99E', '\x999', '\x3', '\x2', '\x2', '\x2', '\x99E', '\x99A', 
		'\x3', '\x2', '\x2', '\x2', '\x99E', '\x99B', '\x3', '\x2', '\x2', '\x2', 
		'\x99E', '\x99C', '\x3', '\x2', '\x2', '\x2', '\x99E', '\x99D', '\x3', 
		'\x2', '\x2', '\x2', '\x99F', '\x181', '\x3', '\x2', '\x2', '\x2', '\x9A0', 
		'\x9A1', '\x5', '\xA4', 'S', '\x2', '\x9A1', '\x183', '\x3', '\x2', '\x2', 
		'\x2', '\x9A2', '\x9A3', '\t', '\xF', '\x2', '\x2', '\x9A3', '\x185', 
		'\x3', '\x2', '\x2', '\x2', '\x9A4', '\x9A5', '\a', 'm', '\x2', '\x2', 
		'\x9A5', '\x9A6', '\x6', '\xC4', '\x17', '\x2', '\x9A6', '\x9A7', '\a', 
		'm', '\x2', '\x2', '\x9A7', '\x187', '\x3', '\x2', '\x2', '\x2', '\x9A8', 
		'\x9A9', '\a', 'l', '\x2', '\x2', '\x9A9', '\x9AA', '\x6', '\xC5', '\x18', 
		'\x2', '\x9AA', '\x9AB', '\a', 'l', '\x2', '\x2', '\x9AB', '\x189', '\x3', 
		'\x2', '\x2', '\x2', '\x15B', '\x18D', '\x193', '\x1A0', '\x1A8', '\x1B0', 
		'\x1B4', '\x1B9', '\x1BC', '\x1C3', '\x1CB', '\x1D7', '\x1E3', '\x1E8', 
		'\x1FD', '\x204', '\x208', '\x212', '\x21A', '\x222', '\x226', '\x22B', 
		'\x231', '\x23A', '\x23E', '\x242', '\x248', '\x250', '\x259', '\x25E', 
		'\x261', '\x270', '\x274', '\x277', '\x280', '\x286', '\x28A', '\x290', 
		'\x296', '\x29B', '\x2A2', '\x2A5', '\x2AE', '\x2B2', '\x2B4', '\x2B7', 
		'\x2BD', '\x2BF', '\x2C1', '\x2C7', '\x2CB', '\x2CF', '\x2D2', '\x2D6', 
		'\x2D9', '\x2DC', '\x2DF', '\x2E3', '\x2E5', '\x2EB', '\x2F0', '\x2F7', 
		'\x2FB', '\x2FD', '\x302', '\x307', '\x30B', '\x30D', '\x310', '\x315', 
		'\x31E', '\x324', '\x32A', '\x332', '\x335', '\x339', '\x33F', '\x344', 
		'\x347', '\x34B', '\x34F', '\x354', '\x358', '\x35C', '\x365', '\x369', 
		'\x36E', '\x372', '\x37D', '\x381', '\x386', '\x38A', '\x391', '\x394', 
		'\x398', '\x3A1', '\x3A5', '\x3AA', '\x3AE', '\x3B4', '\x3B8', '\x3BE', 
		'\x3C8', '\x3CB', '\x3D4', '\x3DA', '\x3E0', '\x3E7', '\x3EC', '\x3F1', 
		'\x3F5', '\x3F7', '\x3FA', '\x400', '\x406', '\x40D', '\x411', '\x415', 
		'\x41B', '\x421', '\x427', '\x42B', '\x42E', '\x434', '\x43A', '\x440', 
		'\x446', '\x44A', '\x450', '\x456', '\x45E', '\x463', '\x467', '\x469', 
		'\x471', '\x476', '\x478', '\x47F', '\x485', '\x488', '\x48D', '\x490', 
		'\x495', '\x497', '\x49B', '\x4A8', '\x4AC', '\x4B0', '\x4B7', '\x4BC', 
		'\x4C4', '\x4C9', '\x4CE', '\x4D0', '\x4DF', '\x4E4', '\x4EB', '\x4F0', 
		'\x4F7', '\x4FB', '\x504', '\x506', '\x50C', '\x514', '\x51D', '\x523', 
		'\x526', '\x52A', '\x52D', '\x531', '\x537', '\x541', '\x545', '\x54C', 
		'\x550', '\x558', '\x563', '\x589', '\x599', '\x5A9', '\x5AB', '\x5AD', 
		'\x5B7', '\x5C2', '\x5C8', '\x5CE', '\x5D2', '\x5D9', '\x5DC', '\x5DF', 
		'\x5E3', '\x5EF', '\x5F3', '\x5F9', '\x600', '\x603', '\x60A', '\x611', 
		'\x616', '\x61F', '\x625', '\x627', '\x62C', '\x632', '\x637', '\x641', 
		'\x649', '\x64D', '\x64F', '\x658', '\x65D', '\x666', '\x66A', '\x66F', 
		'\x674', '\x67D', '\x681', '\x683', '\x68E', '\x692', '\x695', '\x69A', 
		'\x69D', '\x6A4', '\x6AB', '\x6AF', '\x6B4', '\x6BA', '\x6BD', '\x6C3', 
		'\x6E3', '\x6E5', '\x6F1', '\x6F3', '\x6FB', '\x6FF', '\x709', '\x710', 
		'\x717', '\x719', '\x71E', '\x723', '\x729', '\x730', '\x735', '\x743', 
		'\x74E', '\x752', '\x755', '\x758', '\x75B', '\x760', '\x771', '\x776', 
		'\x77A', '\x77E', '\x782', '\x789', '\x790', '\x792', '\x795', '\x79C', 
		'\x7A2', '\x7AE', '\x7B1', '\x7B4', '\x7B9', '\x7C1', '\x7CA', '\x7CE', 
		'\x7D2', '\x7DF', '\x7E2', '\x7E4', '\x7EC', '\x7F5', '\x7F9', '\x7FD', 
		'\x802', '\x812', '\x820', '\x823', '\x825', '\x835', '\x838', '\x841', 
		'\x847', '\x84B', '\x84E', '\x852', '\x854', '\x85B', '\x862', '\x866', 
		'\x86B', '\x870', '\x873', '\x87C', '\x884', '\x88A', '\x88F', '\x8A0', 
		'\x8A4', '\x8A8', '\x8AB', '\x8AE', '\x8B3', '\x8B6', '\x8BB', '\x8C2', 
		'\x8C6', '\x8CB', '\x8D2', '\x8DA', '\x8DD', '\x8E4', '\x8EA', '\x8F2', 
		'\x8FA', '\x8FE', '\x901', '\x909', '\x90C', '\x916', '\x91B', '\x91F', 
		'\x925', '\x929', '\x92D', '\x934', '\x93C', '\x944', '\x950', '\x956', 
		'\x95F', '\x962', '\x969', '\x96E', '\x972', '\x976', '\x97B', '\x982', 
		'\x986', '\x98F', '\x992', '\x99E',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
